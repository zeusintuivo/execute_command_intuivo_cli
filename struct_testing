#!/usr/bin/env bash
#!/bin/bash
#
# @author Zeus Intuivo <zeus@intuivo.com>
#
#
# Helper For testing installations, check files, softlinks, etc......checklist style

# Sample use

function sample_use_verify_mongo() {


    MONGO_VERSION="3.0.11"
    if [ ! -z "${1}" ] ;  then
        MONGO_VERSION="${1}"
    fi

    echo -e "${GREEN} Verify mongo version"
    CURRENT_VERSION=$(mongo --version  | egrep "MongoDB shell version" | head -1  | cut -d' ' -f4 | cut -d'v' -f2)
    check_equality "${CURRENT_VERSION}=${MONGO_VERSION}"
    echo -e "${GREEN} Verify mongod version"
    MONGOD_VERSION=$(mongod --version | egrep "db version" | head -1 | cut -d'v' -f3)
    check_equality "${MONGOD_VERSION}=${MONGO_VERSION}"

    TESTING=" verify that MongoDB has started ${CYAN}successfully${LIGHTYELLOW}"
    if [ ! -z "${MONGO_PID}" ] && [ ! -z "${MONGO_TASKID}" ] && [[ "${MONGO_SERVICE_STATUS}" == *"mongod start/running"* ]] ; then
    {

        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}       Service Status: ${CYAN}${MONGO_SERVICE_STATUS} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}            Mongo PID: ${CYAN}${MONGO_PID} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}        Mongo Task ID: ${CYAN}${MONGO_TASKID} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}      Which Mongo cli: ${CYAN}${WHICH_MONGO} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}        Mongo version: ${CYAN}${CURRENT_VERSION} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}   Which Mongo Server: ${CYAN}${WHICH_MONGOD} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW} Mongo Server version: ${CYAN}${MONGOD_VERSION} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}     Log last 4 lines: ${CYAN}${MONGO_LOG} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}     hugepage/enabled: ${CYAN}${FILE_CONTENTS_ENABLED} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}      hugepage/defrag: ${CYAN}${FILE_CONTENTS_DEFRAG} "
        passed "${TESTING}"

    }
    else
    {
        failed "${TESTING}"
    }
    fi

    directory_exists "
    /data
    /data/db
    /var/log/mongodb
    "

    # Disabled
    #/_/version-manager                             # Patch mongoo-manager form nodejs
    #/home/vagrant/.mongodb
    #softlink_exists "/root/.mongodb>/home/vagrant/.mongodb"

    file_exists "/etc/mongod.conf
    /etc/init/mongod.conf
    /etc/sysfs.conf
    /etc/mongo_vm_settings.conf
    /sys/kernel/mm/transparent_hugepage/khugepaged/defrag
    /sys/kernel/mm/transparent_hugepage/defrag
    /sys/kernel/mm/transparent_hugepage/enabled
    "
    # Extra notes
    # /etc/init/mongod.conf                           # This is the mongo service start|stop|status
    # /etc/default/mongod                             # There is ref to this file inside the service /etc/init/mongod.conf

    # Disabled
    #/etc/systemd/system/mongodb-hugepage-fix.service # service systemd  16.04
    #/etc/systemd/system/mongodb.service              # service systemd  16.04
    #/_/version-manager/bin/m.js                      # Patch mongoo-manager form nodejs
    #/_/version-manager/package.json                  # Patch mongoo-manager form nodejs

    #  softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
    #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
    #

} # end function sample_use_verify_mongo

function HOW_TO_LOAD_SEVERAL_FILES() {

    load_execute_commands_wget(){
        local URL=""
        local cached_directory="/_/clis/execute_command_intuivo_cli/"
        local EXECOMCLI=""
        local provider=""
        [   -d "${cached_directory}" ] &&  provider="file://${cached_directory}"
        [ ! -d "${cached_directory}" ] &&  provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/"
        local BASH_SCRIPTS="
    struct_testing
    execute_command
    "
    #execute_command
        while read -r ONE_SCRIPT; do
        {
            if [ ! -z "${ONE_SCRIPT}" ] ; then         # if not empty
            {
                URL="${provider}${ONE_SCRIPT}"
                [   -d "${cached_directory}" ] && source "$URL"
                [ ! -d "${cached_directory}" ] &&eval """$(wget --quiet --no-check-certificate $URL  -O -  2>/dev/null )"""   # suppress only wget download messages, but keep wget output for variable
                echo "$URL Loaded"
            }
            fi
        }
        done <<< "${BASH_SCRIPTS}"
        unset URL
        unset EXECOMCLI
        unset ONE_SCRIPT
        unset BASH_SCRIPTS
        unset provider
        ( ( ! command -v type passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_execute_commands_wget
    load_execute_commands_wget

    load_execute_commands_curl(){
        local URL=""
        local EXECOMCLI=""
        local cached_directory="/_/clis/execute_command_intuivo_cli/"
        local provider=""
        [   -d "${cached_directory}" ] &&  provider="file://${cached_directory}"
        [ ! -d "${cached_directory}" ] &&  provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/"
        local BASH_SCRIPTS="
    struct_testing
    execute_command
    "
    #execute_command
        while read -r ONE_SCRIPT; do
        {
            if [ ! -z "${ONE_SCRIPT}" ] ; then         # if not empty
            {
                URL="${provider}${ONE_SCRIPT}"
                eval """$(curl $URL  2>/dev/null )"""  # suppress only curl download messages, but keep curl output for variable
                echo "$URL Loaded"
            }
            fi
        }
        done <<< "${BASH_SCRIPTS}"
        unset URL
        unset EXECOMCLI
        unset ONE_SCRIPT
        unset BASH_SCRIPTS
        unset provider
        ( ( ! command -v type passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_execute_commands_curl
    load_execute_commands_curl

} # end function HOW_TO_LOAD_SEVERAL_FILES

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_EXECUTE_COMMAND() {

    #Sample short call for loading execute command
    load_execute_command_curl(){
        local provider="file:///_/clis/execute_command_intuivo_cli/execute_command"
        [ ! -d "/_/clis/execute_command_intuivo_cli/" ] && provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/execute_command"
        local EXECOMCLI=$(curl $provider  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading execute_command \n \n " && exit 69; )
    } # end load_struct_testing_curl
    load_struct_testing_curl
} # end HOW_TO_LOAD_JUST_ONE_SCRIPT_EXECUTE_COMMAND

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL() {

    #Sample short call for loading struct_testing
    load_struct_testing_curl(){
        local provider="file:///_/clis/execute_command_intuivo_cli/struct_testing"
        [ ! -d "/_/clis/execute_command_intuivo_cli/" ] && provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing"
        local EXECOMCLI=$(curl $provider  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_struct_testing_curl
    load_struct_testing_curl

} # end HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_WGET() {

    #Sample short call for loading struct_testing
    load_struct_testing_wget(){
        local provider="/_/clis/execute_command_intuivo_cli/struct_testing"
        [   -e "${provider}"  ] && source "${provider}"
        [ ! -e "${provider}"  ] && eval """$(wget --quiet --no-check-certificate  https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing -O -  2>/dev/null )"""   # suppress only wget download messages, but keep wget output for variable
        ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_struct_testing_wget
    load_struct_testing_wget

} # end HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL

function HOW_TO_LOAD_JUST_ONE_SCRIPT_ONLINE_ALWAYS_STRUCT_USING_WGET() {

    load_struct_testing_wget(){
        # HOW TO LOAD JUST ONE SCRIPT
        EXECOMCLI=$(wget --quiet --no-check-certificate https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing -O -  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v type passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_struct_testing_wget
    load_struct_testing_wget

} # end HOW_TO_LOAD_JUST_ONE_SCRIPT_ONLINE_ALWAYS_STRUCT_USING_WGET





 ######  ######## ########  ##     ##  ######  ########
##    ##    ##    ##     ## ##     ## ##    ##    ##
##          ##    ##     ## ##     ## ##          ##
 ######     ##    ########  ##     ## ##          ##
      ##    ##    ##   ##   ##     ## ##          ##
##    ##    ##    ##    ##  ##     ## ##    ##    ##
 ######     ##    ##     ##  #######   ######     ##

######## ########  ######  ######## #### ##    ##  ######
   ##    ##       ##    ##    ##     ##  ###   ## ##    ##
   ##    ##       ##          ##     ##  ####  ## ##
   ##    ######    ######     ##     ##  ## ## ## ##   ####
   ##    ##             ##    ##     ##  ##  #### ##    ##
   ##    ##       ##    ##    ##     ##  ##   ### ##    ##
   ##    ########  ######     ##    #### ##    ##  ######

 ######  ########    ###    ########  ########                    ##
##    ##    ##      ## ##   ##     ##    ##                        ##
##          ##     ##   ##  ##     ##    ##                         ##
 ######     ##    ##     ## ########     ##       ####### #######    ##
      ##    ##    ######### ##   ##      ##                         ##
##    ##    ##    ##     ## ##    ##     ##                        ##
 ######     ##    ##     ## ##     ##    ##                       ##


#
# STRUCT TESTING - START
#

RED="\033[01;31m"
#RED="\033[38;5;1m"
ORANGE="\033[38;5;202m"

WHITE="\033[38;5;15m"
WHITEBOLD="\033[01;37m"
YELLOW="\033[01;33m"
YELLOW226="\033[38;5;226m"


GRAY="\033[38;5;8m"
GRAY241="\033[38;5;241m"
GRAYEDOUT="\033[01;30m"

GREEN="\033[01;32m"
LIGHTGREEN="\033[38;5;83m"
LIGHTPINK="\033[1;204m"
LIGHTYELLOW="\033[38;5;227m"


CYAN="\033[01;36m"
PURPLE="\033[01;35m"
DARKBLUE="\033[01;34m"
PURPLE_BLUE="\033[38;5;93m"
BRIGHT_BLUE87="\033[38;5;87m"

YELLOW_OVER_DARKBLUE="\033[38;5;220m\033[48;5;20m"
YELLOW_OVER_DARKBLUE2="\033[38;5;11m\033[48;5;18m"

RESET="\033[0m"
CERO="\033[01;0m"

        function passed() {
            ARGS="${@}"
            if [ ! -z "${ARGS-x}" ] ; then # if its set and not empty
            {
                echo -e "${LIGHTGREEN} âœ” ${LIGHTYELLOW} ${ARGS}  ${RESET}"
            }
            fi
        }
        function kill_execution() {
            echo -e " â˜  ${LIGHTPINK} KILL EXECUTION SIGNAL SEND ${RESET}"
            exit 69;
        }

        function failed() {
            ARGS="${@}"
            if [[ ! -z "${ARGS-x}" ]] ; then # if its set and not empty
            {
                echo -e "${RED} ðž¦ ${LIGHTYELLOW} ${ARGS} ${RED} has failed!  ${RESET}"
                kill_execution
            }
            fi
        }

        function assert(){
            # Sample usage
            #
            #     assert not empty "${SUBLIMEDEVLASTESTBUILD}"
            #     assert not empty "${SUBLIMEDEVLASTESTBUILD}"
            #     /home/vagrant/.pyenv"
            #
                0     1    2    3
            # assert not empty $VALUE
            if [  -z "${1+x}" ] || [ -z "${2+x}" ] || [ -z "${3+x}" ] ; then # check if all parameters are set and not empty
            {
                failed ${FUNCNAME[1]} requires to have 3 parameters :: ${FUNCNAME[1]} not empty \$VALUE ::
            }
            fi
            local not="${1}"
            local empty="${2}"
            local value="${2}"
            TESTING="that value ${CYAN}${value}${LIGHTYELLOW} is not empty"
            if [[ ! -z "${value+x}" ]] ; then
            {
                passed "${TESTING}"
            }
            else
            {
                failed "${TESTING}"
            }
            fi

        } # end assert

        function ensure() {
            # Sample usage:
            # assuming mongo bin is in your path
            #            ensure mongo or " Cancel export"
            #            ensure mongoexport or " Cancel export"
            #            ensure bsondump or " Cancel export"
            #
            if ! command -v "${1}" >/dev/null 2>&1; then # Command Does not-exist
                echo " "
                echo "Error! '${1}' is not in your PATH environment or cannot be reached.!"
                return 1
            else
                local msg=""
                [[ ! -z "${3+x}"  ]] &&     msg="${3}"  ;  # check if a variable is set and not empty and reassign value
                msg=$(echo "${msg}" | sed  -e 's/ancel /anceling /g')
                msg=$(echo "${msg}" | sed  -e 's/uit /uiting /g')
                msg=$(echo "${msg}" | sed  -e 's/xit /xiting /g')
                echo "${msg}"
                [[ "${msg}" == *"anceling "* ]] && exit 69
                [[ "${msg}" == *"uiting "* ]] && exit 69
                [[ "${msg}" == *"xiting "* ]] && exit 69
                return 1
            fi
        }

        function Installing() {
            echo -e "${GREEN} Installing ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${7} ${GREEN}.${RESET}"
        }
        alias installing=Installing
        function Configuring() {
            echo -e "${GREEN} Configuring ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${7} ${GREEN}.${RESET}"
        }
        alias configuring=Configuring
        function Setting() {
            echo -e "${GREEN} Setting ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${7} ${GREEN}.${RESET}"
        }
        alias setting=Setting
        function Final() {
            echo -e "${GREEN} Setting ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${7} ${GREEN}.${RESET}"
        }
        alias final=Final

        function not() {
            local order="empty"  # Tasjgjgggg
            if [[ ! -z "${1+x}"  ]] ; then  # check if a variable is set and not empty
                NODE_VERSION="${1}"
            fi
        }

        function directory_exists(){
            # Sample usage
            #
            #     directory_exists "/home/vagrant/.pyenv"
            #     directory_exists "/root/.pyenv
            #     /home/vagrant/.pyenv"
            #
            DIRS="${@}"
            if [ ! -z "${DIRS-x}" ] ; then # if its set and not empty
            {
                DIRS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_DIR; do
                # if not empty
                if [ ! -z "${ONE_DIR}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # ONE_DIR="/Users/administrator/.pyenv"
                    TESTING="that directory ${CYAN}${ONE_DIR}${LIGHTYELLOW} exists"
                    if [[ -d "${ONE_DIR}" && ! -L "${ONE_DIR}" ]] ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${DIRS}"
            }
            fi

        }

        function does_not_exist(){
            # Sample usage
            #
            #     does_not_exist "/home/vagrant/.pyenv"
            #     does_not_exist "/root/.pyenv
            #     /home/vagrant/.pyenv"
            #
            DIRS="${@}"
            if [ ! -z "${DIRS-x}" ] ; then # if its set and not empty
            {
                DIRS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_DIR; do
                # if not empty
                if [ ! -z "${ONE_DIR}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # ONE_DIR="/Users/administrator/.pyenv"
                    TESTING="that ${CYAN}${ONE_DIR}${LIGHTYELLOW} does not exist"
                    if [[ ! -e "${ONE_DIR}" ]] ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${DIRS}"
            }
            fi
        }

        function directory_does_not_exist() {
            does_not_exist $@
        }

        function file_does_not_exist() {
            does_not_exist $@
        }

        function file_exists(){
            # Sample usage
            #
            #     file_exists "/home/vagrant/.zshrc"
            #     file_exists "/root/.zshrc
            #     /home/vagrant/.pyenzshrcv"
            #
            FILES="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                FILES=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_FILE; do
                # if not empty
                if [ ! -z "${ONE_FILE}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.zshrc <-- will fail always
                    # But /home/user/.zshrc  <-- will pass
                    # OR Users/administrator/.zshrc  in mac <-- will pass
                    # ONE_FILE="/Users/administrator/.zshrc"
                    TESTING="that file ${CYAN}${ONE_FILE}${LIGHTYELLOW} exists"
                    if [[ -s "${ONE_FILE}" && ! -L "${ONE_FILE}" ]] ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${FILES}"
            }
            fi

        }

        function softlink_exists(){
            # Sample usage
            #
            #     softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
            #     softlink_exists "/Users/administrator/.nix-profile
            #     /Users/administrator/.nix-profile>/nix/var/nix/profiles/default"
            #     softlink_exists "/root/.pyenv"
            #     softlink_exists "/root/.pyenv
            #     /root/.pyenv>/home/vagrant/.pyenv"
            #
            LINKS="${@}"
            if [ ! -z "${LINKS-x}" ] ; then # if its set and not empty
            {
                LINKS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_LINK_ORDER; do
                    # if not empty
                    if [ ! -z "${ONE_LINK_ORDER}" ] ; then
                    {
                        CHECK_TARGET_TOO="NO"
                        ONE_LINK_LOCATION="${ONE_LINK_ORDER}"
                        ONE_LINK_TARGET=""

                        [[ "${ONE_LINK_ORDER}" == *">"* ]] && CHECK_TARGET_TOO="YES"
                        if [[ "${CHECK_TARGET_TOO}" == "YES" ]] ; then
                        {
                            ONE_LINK_LOCATION=$(cut -d'>' -f1 <<< "${ONE_LINK_ORDER}")
                            ONE_LINK_TARGET=$(cut -d'>' -f2 <<< "${ONE_LINK_ORDER}")
                        }
                        fi
                        # AS a NOTE ~/  <-- will fail always
                        # SO ~/.pyenv <-- will fail always
                        # But /home/user/.pyenv  <-- will pass
                        # OR Users/administrator/.pyenv  in mac <-- will pass
                        # ONE_LINK_LOCATION="/Users/administrator/.nix-profile"
                        TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} exists"
                        if [[ -L "${ONE_LINK_LOCATION}" ]] ; then
                        {
                            # Test pointing
                            passed "${TESTING}"

                            if [[ "${CHECK_TARGET_TOO}" == "YES" && ! -z "${ONE_LINK_TARGET}" ]] ; then
                            {
                                TESTING="${PURPLE} +-- and that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} points to ${CYAN}${ONE_LINK_TARGET}${GREEN} location"

                                FOUND_LINK_TARGET=$(ls -l ${ONE_LINK_LOCATION} | awk '{print $11}') # Find target symlink
                                if [[ "${FOUND_LINK_TARGET}" == "${ONE_LINK_TARGET}" ]] ; then
                                {
                                    passed "${TESTING}"
                                }
                                else
                                {
                                    failed "${TESTING}"
                                }
                                fi
                            }
                            fi # TACHECK_TARGET_TOO is correct

                        }
                        else
                        {
                            failed "${TESTING}"
                        }
                        fi # ONE_LINK_LOCATION Exists
                    }
                    fi # not empty one link
                done <<< "${LINKS}"
            }
            fi # not empty links
        } # end function

        function check_equality(){
            # Sample usage
            #
            #     check_equality "$(cat /home/vagrant/.pyenv/version)=${PYTHON_VERSION}
            #     $(cat /home/vagrant/.pyenv/version)=2.7.11"
            #
            #     check_equality $(cat ~/.pyenv/version)="2.7.11"
            #
            ARGS="${@}"
            if [ ! -z "${ARGS-x}" ] ; then # if its set and not empty
            {
                #ARGS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_EQUALITY_ORDER; do
                    # if not empty
                    if [ ! -z "${ONE_EQUALITY_ORDER}" ] ; then
                    {
                        LEFT_VALUE=$(cut -d'=' -f1 <<< "${ONE_EQUALITY_ORDER}")
                        RIGHT_VALUE=$(cut -d'=' -f2 <<< "${ONE_EQUALITY_ORDER}")

                        TESTING="that value left value: ${CYAN}${LEFT_VALUE}${LIGHTYELLOW} exists"
                        if [[ -z "${LEFT_VALUE-x}" ]] ; then
                        {
                            failed "${TESTING}"
                        }
                        fi

                        TESTING="that value right value: ${CYAN}${RIGHT_VALUE}${LIGHTYELLOW} exists"
                        if [[ -z "${RIGHT_VALUE-x}" ]] ; then
                        {
                            failed "${TESTING}"
                        }
                        fi

                        TESTING="that value ${YELLOW_OVER_DARKBLUE}${LEFT_VALUE}${RESET}${LIGHTYELLOW} is equal to ${YELLOW_OVER_DARKBLUE}${RIGHT_VALUE}${RESET}"
                        if [[ "${LEFT_VALUE}" ==  "${RIGHT_VALUE}" ]] ; then
                        {
                            passed "${TESTING}"
                        }
                        else
                        {
                            failed "${TESTING}"
                        }
                        fi
                    }
                    fi # not empty
                done <<< "${ARGS}"
            }
            fi
        } # end function check_equality
        alias verify_equality=check_equality
        alias ensure_equality=check_equality

        function check_to_be_installed(){
            # Sample usage
            #
            # ...  you want to APT-GET install  ... sysfsutils
            # ...  and you want to say          ... fix for transparent_hugepage
            #
            #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
            #
            package="$1"
            message="$2"
            CHECK_INSTALLED=$(dpkg -s "${package}")
            if [[ "${CHECK_INSTALLED}" == *"Package: ${package}"* ]] ; then
                echo -e "${GREEN} PACKAGE: ${message}  ${package} is there  ${CERO}"
            else
                echo -e "${YELLOW} Installing ${message}   ${CERO}"
                sudo apt install "${package}" -y
            fi
        }


        function is_service_reponse_not_this_fail() {
            #Sample use
            # ( command -v nginx >/dev/null 2>&1; ) && sudo service nginx start
            #
            # is_service_reponse_not_this_fail "nginx" "$(sudo service nginx status)" "not running"
            # is_service_reponse_not_this_fail "puma" "$(sudo /etc/init.d/pumacontrol.sh status)" "not running"
            #
            local SERVICE_NAME SERVICE_STATUS SERVICE_FAIL_RESPONSE
            SERVICE_NAME="${1}"
            SERVICE_STATUS="${2}"
            SERVICE_FAIL_RESPONSE="${3}"
            TESTING="that service ${CYAN}${SERVICE_NAME}${LIGHTYELLOW} is running"
            if [[ "${SERVICE_STATUS}" == *"${SERVICE_FAIL_RESPONSE}"* ]] ; then
            {
                echo "${SERVICE_STATUS}"
                failed "${TESTING}"
            }
            else
            {
                passed "${TESTING}"
            }
            fi
        }

        function is_service_running() {
            #Sample use
            # ( command -v nginx >/dev/null 2>&1; ) && sudo service nginx start
            #
            # is_service_running "nginx" "$(sudo service nginx status)" "is running"
            # is_service_running "puma" "$(sudo /etc/init.d/pumacontrol.sh status)" "is running"
            #
            local SERVICE_NAME="${1}"
            local SERVICE_STATUS="${2}"
            local EXPECTED_RESPONSE="${3}"
            echo SERVICE_NAME="${1}"
            echo SERVICE_STATUS="${2}"
            echo EXPECTED_RESPONSE="${3}"
            TESTING="that service ${CYAN}${SERVICE_NAME}${LIGHTYELLOW} ${EXPECTED_RESPONSE}"
            if [[ "${SERVICE_STATUS}" == *"${EXPECTED_RESPONSE}"* ]] ; then
            {
                passed "${TESTING}"
            }
            else
            {
                echo "${SERVICE_STATUS}"
                failed "${TESTING}"
            }
            fi
        }

        type_function_exists() {
          type "$1" > /dev/null 2>&1
        } # type_function_exists


        function is_installed() {
            # Sample use
            #
            #          if  ! is_installed wget ; then    is like is NOT installed
            #          if  is_installed wget ; then      it makes more sense to make it this way
            #
            local SERVICE_NAME="${1}"
            if ! type_function_exists "${SERVICE_NAME}"; then
            {
                #failed "${TESTING}"
                return 1
            }
            else
            {
                #passed "${TESTING}"
                return 0
            }
            fi
        }

        function is_not_installed() {
            # Sample use
            #
            #          if  ! is_not_installed wget ; then # you can, but not recommended, because it is confusing to read
            #          if  is_not_installed wget ; then
            #
            local SERVICE_NAME="${1}"
            if ! type_function_exists "${SERVICE_NAME}"; then
            {
                #passed "${TESTING}"
                return 0
            }
            else
            {
                #failed "${TESTING}"
                return 1
            }
            fi
        }

        function verify_is_installed() {
            # Sample use
            #
            #            verify_is_installed wget
            #
            local SERVICE_NAME="${1}"
            TESTING="that: ${CYAN}${SERVICE_NAME}${GREEN} is installed"
            if ! is_installed "${SERVICE_NAME}"; then
            {
                failed "${TESTING}"
            }
            else
            {
                passed "${TESTING}"
            }
            fi
        }

        function version_installed_is() {
            # Sample use
            #
            #          if  ! version_installed_is "node --version"  "${node_version}" ;           then    is like     version installed is  12.3.4.1 ?
            #          if  version_installed_is   "phantomjs --version"  "${phantomjs_version}" ; then    it like     NOT version is installed version 12.31.23 ?
            #
            local give_me_something=$(eval """${1}""" 2>&1 | extract_version | head -1)
            local expected="${2}"

            if [[ "${give_me_something}" == *"${expected}"* ]] || [[ "${give_me_something}" == "${expected}" ]]; then
            {
                return 0  #failed  "${TESTING}"
            }
            else
            {
                return 1  #passed  "${TESTING}"
            }
            fi
        }
        alias is_version_installed=version_installed_is
        alias is_installed_version=version_installed_is
        alias is_version=version_installed_is
        alias version_is=version_installed_is

        function verify_installed_version() {
            # Sample use
            #
            #            verify_installed_version "node --version"  "${node_version}"
            #            verify_installed_version "phantomjs --version"  "${phantomjs_version}"
            #            verify_installed_version "casperjs --version"  "${casper_version}"
            #
            local COMMAND_TO_EVAL="${1}"
            local VERSION_EXPECTED="${2}"

            local TESTING="that installed version for ${COMMAND_TO_EVAL} is ${CYAN}${VERSION_EXPECTED}${GREEN}"
            if ! version_installed_is "${COMMAND_TO_EVAL}" "${SERVICE_NAME}"; then
            {
                failed "${TESTING}"
            }
            else
            {
                passed "${TESTING}"
            }
            fi
        }

        function verify_installed_version_old() {
            # Sample use
            #
            #            verify_installed_version "node --version"  "${node_version}"
            #            verify_installed_version "phantomjs --version"  "${phantomjs_version}"
            #            verify_installed_version "casperjs --version"  "${casper_version}"
            #
            local EVAL_GET_VERSION_STRING=$(eval """${1}""" 2>&1 | head -1)
            local VERSION_EXPECTED="${2}"

            local TESTING="that installed version for ${1} is ${CYAN}${VERSION_EXPECTED}${GREEN}"
            if [[ "${EVAL_GET_VERSION_STRING}" == *"${VERSION_EXPECTED}"* ]] || [[ "${EVAL_GET_VERSION_STRING}" == "${VERSION_EXPECTED}" ]]; then
            {
                passed "${TESTING}"
            }
            else
            {
                echo -e "${RED} ðž¦ I got response: ${YELLOW_OVER_DARKBLUE}${EVAL_GET_VERSION_STRING}"
                failed "${TESTING}"
            }
            fi
        }

        function if_user_exists(){
            # Sample use
            #
            #            ( ! if_user_exists "postgres"  ) && failed "${TESTING}"
            #            ( if_user_exists "postgres"  ) && passed "${TESTING}"
            #
            local ${TARGET_USER}="${1}"
            local TESTING="that user ${TARGET_USER} is ${CYAN}exists${GREEN}"
            local LIST_ALL_USERS=$(cut -d: -f1 /etc/passwd) # REF: http://askubuntu.com/questions/410244/a-command-to-list-all-users-and-how-to-add-delete-modify-users
            local USERID=$(id -u ${TARGET_USER})
            # Alternative to check getent passwd $user  > /dev/null
            # Alternative to check getent passwd mongodb  > /dev/null
            [ -z "${USERID}" ] &&  return 1 #failed
            return 0 #found
        }
        function check_if_user_exists(){
            # Sample use
            #
            #            check_if_user_exists "postgres"
            #
            local ${TARGET_USER}="${1}"
            local TESTING="checking that user ${TARGET_USER} is ${CYAN}exists${GREEN}"
            ( ! if_user_exists "${TARGET_USER}"  ) && failed "${TESTING}"
            passed "${TESTING}"
        }

        function has_error_keyword() {
            # Sample use
            #
            #            has_error_keyword "${bulk}"
            #
            local bulk="${*}"
            if    [[ "${bulk}" == *"Could not resolve"*    ]] || \
                  [[ "${bulk}" == *"Repository not found"* ]] || \
                  [[ "${bulk}" == *"Could not read from"*  ]] || \
                  [[ "${bulk}" == *"Could not"*            ]] || \
                  [[ "${bulk}" == *"could not"*            ]] || \
                  [[ "${bulk}" == *"unmatched"*            ]] || \
                  [[ "${bulk}" == *"Fatal"*                ]] || \
                  [[ "${bulk}" == *"FATAL"*                ]] || \
                  [[ "${bulk}" == *"fatal"*                ]] || \
                  [[ "${bulk}" == *"FAILED"*               ]] || \
                  [[ "${bulk}" == *"failed"*               ]] || \
                  [[ "${bulk}" == *"Failed"*               ]] || \
                  [[ "${bulk}" == *"error"*                ]] || \
                  [[ "${bulk}" == *"ERROR"*                ]] || \
                  [[ "${bulk}" == *"Error"*                ]] || \
                  [[ "${bulk}" == *"Denied"*               ]] || \
                  [[ "${bulk}" == *"denied"*               ]] ; then
            {
                #passed "${TESTING}"
                return 0
            }
            else
            {
                #failed "${TESTING}"
                return 1
            }
            fi

        } # end has_error_keyword

        function handle_error() {
            # Sample use
            #
            #            local install_result=$(sudo apt-get install ${missing} -yfq   2>&1)  # capture all input and output
            #            [[ ! -z "${install_result}" ]] && handle_error "${install_result}"
            #
            local bulk="${*}"
            local error_happened=""
            [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $? != 0 ] && error_happened="1"
            [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $? != 0 )) && error_happened="1"
            if [ "${error_happened}" ]  ||  ( has_error_keyword "${bulk}" ) ; then
            {
              echo -e "${PURPLE_BLUE} action ${RED}failed ${YELLOW226}!!!  ${RESET}"
              [[ "${bulk}" == *"Could not resolve"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO INTERNET CONNECTION \o_0/ ${RESET}"
              [[ "${bulk}" == *"Repository not found"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO ACCESS TO THIS FOR YOU ${RED} ${GIT_USER_NAME} ${RESET}"
              [[ "${bulk}" == *"Could not read from"* ]] && echo -e "${BRIGHT_BLUE87} It appears it exists but you are ${RED}NOT ${YELLOW226} ALLOWED ${RED} ${GIT_USER_NAME} ${YELLOW226}!!! ${RESET}"
              failed "${RESET}${bulk}  "
            }
            fi

        } # end handle_error

        function install_apt_get_requirements(){
            # Sample use
            #               local OS="${1}"
            #               install_apt_get_requirements "${OS}" "
            #                        build-essential
            #                        libreadline-dev
            #                        zlib1g-dev
            #                        flex
            #                        bison
            #                        libxml2-dev
            #                        libxslt-dev
            #                        libssl-dev
            #
            #                        libreadline6-dev
            #                        libossp-uuid-dev
            #                        uuid"
            #
            #

            # room for detecting Linux and OS systems
            local OS="${1}"
            local missing=""
            local one_required=""
            local required=$(grep -vE '^\s+#'<<<"${2}")
            for one_required in ${required}; do
            {
                dpkg -l | egrep "$one_required" &>/dev/null
                if [ $? == 0 ]; then
                {
                    passed " ${GREEN} $one_required ${YELLOW} INSTALLED${RESET} ."
                }
                else
                {
                    echo -e " ${RED}  NEED TO INSTALL ${YELLOW} $one_required${RESET} ."
                    missing="${missing} ${one_required}"
                }
                fi
            }
            done
            missing=$(echo ${missing} | sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g' ) # trim_start_space

            # Check Requirements OS Ubuntu 14.04 REF: https://wiki.postgresql.org/wiki/Compile_and_Install_from_source_code#Ubuntu
            [[ ! -z "${missing}" ]] && echo -e " ${CYAN} Installing missing packages: ${YELLOW} ${missing} ${RESET} ."
            [[ ! -z "${missing}" ]] && local install_result=$(sudo apt-get install ${missing} -yfq   2>&1) # capture all input and output
            [[ ! -z "${install_result}" ]] && handle_error "${install_result}"
        } # end install_apt_get_requirements

        function install_apt_get_should_not_be_installed(){
            # Sample use
            #               local OS="${1}"
            #               install_apt_get_should_not_be_installed "${OS}" "
            #                        build-essential
            #                        libreadline-dev
            #                        zlib1g-dev
            #                        flex
            #                        bison
            #                        libxml2-dev
            #                        libxslt-dev
            #                        libssl-dev
            #
            #                        libreadline6-dev
            #                        libossp-uuid-dev
            #                        uuid"
            #
            #

            # room for detecting Linux and OS systems
            local OS="${1}"
            local removing=""
            local one_required=""
            local required=$(grep -vE '^\s+#'<<<"${2}")
            for one_required in ${required}; do
            {
                dpkg -l | egrep "$one_required" &>/dev/null
                if [ $? == 0 ]; then
                {
                    echo -e " ${RED}  NEED TO REMOVE ${YELLOW} $one_required${RESET} ."
                    removing="${removing} ${one_required}"
                }
                else
                {
                    passed " ${GREEN} $one_required ${YELLOW} NOT PRESENT${RESET} ."
                }
                fi
            }
            done
            removing=$(echo ${removing} | sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g' ) # trim_start_space

            [[ ! -z "${removing}" ]] && echo -e " ${CYAN} Apt-get removing packages: ${YELLOW} ${removing} ${RESET} ."
            [[ ! -z "${removing}" ]] && local remove_result=$(sudo apt-get remove ${removing} -yfq   2>&1 && sudo apt-get purge ${removing} -yfq   2>&1 && sudo apt-get autoremove -yfq   2>&1) # capture all input and output
            [[ ! -z "${remove_result}" ]] && handle_error "${remove_result}"
        } # end install_apt_get_should_not_be_installed
        #
        # C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --Start
        #
        function test_positives(){
            # Sample use
            #
            #
            #    local message_response=$(ls asdasdfas1234  2>&1 )  # Perform an action with error ,capture all output, error will return 1 to $?
            #    local ERROR_HAPPENED=""
            #    [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $? != 0 ] && ERROR_HAPPENED="1"
            #    [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $? != 0 )) && ERROR_HAPPENED="1"
            #    if [ "${ERROR_HAPPENED}" ] || \
            #        [[ "${message_response}" == *"error"* ]] || \
            #        [[ "${message_response}" == *"ERROR"* ]] || \
            #        [[ "${message_response}" == *"denied"* ]] \
            #    ; then
            #    {
            #        failed "There was an error- do something- show something ${message_response}"
            #    }
            #    fi

            KIND=""
            ls werwerwerwerwerwerwerwerwerwerwerr >/dev/null 2>&1;
            if (( $? == 0 )) ;  then  # Intel processor
            KIND="INTEL"
            fi
            if [ $? == 0 ]; then   # Mac Intel processor
            KIND="${KIND}MAC"
            fi
            echo "clear_error_output" >/dev/null 2>&1;
            echo "${KIND}"
        }
        PROCESSOR_ERROR=$(test_positives)
        # DEBUG test_positives echo "${PROCESSOR_ERROR}"
        # DEBUG test_positives exit 1
        #
        # C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --End
        #


        # Bash extract version from a string REF:  https://superuser.com/questions/363865/how-to-extract-a-version-number-using-sed
        function extract_version(){
          sed -nre 's/^[^0-9]*(([0-9]+\.)*[0-9]+).*/\1/p'
        }
        function remove_letters() {
          sed 's/[a-z-]\|[A-Z-]\|[ -]\|[(-)-]\|[, -]\|86_64//g'
        }
        function trim_start_space() {
            sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g'
        }
        function trim_end_space() {
            sed -e 's/[[:space:]]*$//' | sed 's/\ $//g' | sed 's/\t$//g'
        }
        function trim() {
            trim_start_space | trim_end_space
        }
        # duplicated at commit
        function get_longest_name_length() {
          # Sample usage:
          #               LONGEST_NAME=$(get_longest_name_length "${LIST_OF_FILENAMES_OR_STRINGS}")
          local ONE_CHANGED_FILES_WITH_STATUS
          local CHANGED_FILES_WITH_STATUS_WITH_TAB_CHANGED_TO_PIPE="${1}"
          local FILENAME_LENGTH=0
          local LONGEST_NAME=0

          #while read -r ONE_CHANGED_FILES_WITH_STATUS; do                                                  # Get longest file name
          while read -r ONE_CHANGED_FILES_WITH_STATUS; do
          {
            # if not empty
            if [ ! -z "${ONE_CHANGED_FILES_WITH_STATUS}" ] ; then
            {
              FILENAME_LENGTH="${#ONE_CHANGED_FILES_WITH_STATUS}"   # get string length
              (( FILENAME_LENGTH > LONGEST_NAME )) && LONGEST_NAME=$FILENAME_LENGTH
            }
            fi
            #echo "$(echo "$ONE_CHANGED_FILES_WITH_STATUS" | xargs -I {} echo "{}:1")"
          }
          done <<< "${CHANGED_FILES_WITH_STATUS_WITH_TAB_CHANGED_TO_PIPE}"
          #done <<< "${CHANGED_FILES_WITH_STATUS_WITH_TAB_CHANGED_TO_PIPE}"
          echo $LONGEST_NAME
        } #end get_longest_name_length
        # duplicated at commit
        function repeat_single_char_spacer() {
          # Sample usage:
          #               SPACER=$(repeat_single_char_spacer " " $CALCULATE_SPACER)
          #
          #
          # Complete Preparation:
          #
          #               LONGEST_NAME=$(get_longest_name_length "${LIST_OF_FILENAMES_OR_STRINGS}")
          #               FILENAME_LENGTH="${#FILENAME}"   # get string length
          #               CALCULATE_SPACER=$(( $LONGEST_NAME - $FILENAME_LENGTH ))
          #               SPACER=$(repeat_single_char_spacer " " $CALCULATE_SPACER)
          #               echo ${FILENAME}${SPACER}
          #
          local pad="${1}"
          local total=${2}
          [ ${total} -lt 1 ] && echo "${YELLOW} Warning ${FUNCNAME[*]}: ${CYAN} Expected number 'total' to be more than 0 and I got :${total}: value ${RESET}" && total=10
          [ -z "${pad}" ] && [ "${#pad}" -lt 1 ] && echo "${YELLOW} Warning ${FUNCNAME[*]}: ${CYAN} Expected padding 'pad' to be something and I got :${pad}: value ${RESET}" && pad=" "
          for ((x = 0; x < ${total}; x++)); do
            #echo "${1}"
            printf %s "${pad}"
          done
        } # end repeat_single_char_spacer

        function add_right_padding(){
          # Sample usage:
          #               add_right_padding "${ONE_VERSION}" ${LONGEST_NAME}  " "
          #
          local string="${1}"
          local longest=${2}
          local pad="${3}"
          local length="${#string}"   # get string length
          local calculate=$(( $longest - $length ))
          local padding=$(repeat_single_char_spacer "${pad}" ${calculate})
          echo "${string}${padding}"
        } # end add_right_padding

        function add_left_padding(){
          # Sample usage:
          #               add_left_padding " " ${LONGEST_NAME}   "${ONE_VERSION}"
          #
          local pad="${1}"
          local longest=${2}
          local string="${3}"
          local length="${#string}"   # get string length
          local calculate=$(( $longest - $length ))
          local padding=$(repeat_single_char_spacer ${pad} $calculate)
          echo "${padding}${string}"
        } # end add_left_padding

        function build_table_from_installed_components() {
            # Sample usage:
            #                build_table_from_installed_components "${USER_TO_INSTALL}"
            #                build_table_from_installed_components "${USER}"
            #
            local USER_TO_INSTALL="${1}"

            local README_TABLE="INSTALLED_MACHINE=\"
 Service/Software | Version                        | Executable
------------------|--------------------------------|-------------------------------------------"
            local local_commands="
=, Instanced on     , date       , date
=, OS               , lsb_release, lsb_release -sd
=, Timezone         ,            , cat /etc/timezone
=, Processor        , uname      , uname -p
=, CPUS             , getconf    , getconf _NPROCESSORS_ONLN
=, LOCALE LANG      , locale     , locale | grep 'LANG=' | cut -d= -f2
=, LOCALE LC_ALL    , locale     , locale | grep 'LC_ALL=' | cut -d= -f2
x, Nginx            , nginx      , nginx -v
x, localtunnel.me   , lt         ,
x, NodeJS           , node       ,
x, NPM              , npm        ,
x, NVM              , nvm        ,
x, PhantomJS        , phantomjs  ,
x, Ruby             , ruby       ,
x, RVM              , rvm        ,
x, Puma             , puma       ,
x, Python           , python     ,
x, PyENV            , pyenv      ,
x, Mongo            , mongo      ,
x, Redis            , redis-cli  ,
x, PostgresQL       , psql       ,
x, Mysql 5          , mysql      ,  echo \"\${\$(mysql --version 2>&1)#*Distrib}\"
x, PHP 7            , php7.0     ,
x, PHP 7 Xdebug     , php7.0     ,  php7.0 --version | grep Xdebug
x, PHP 7 FPM        , php-fpm7.0 ,
x, PHP 7 FPM Xdebug , php-fpm7.0 ,  php-fpm7.0 --version | grep Xdebug
x, PHP 5            , php5.6     ,
x, PHP 5 Xdebug     , php5.6     ,  php5.6 --version | grep Xdebug
x, PHP 5 FPM        , php-fpm5.6 ,
x, PHP 5 FPM Xdebug , php-fpm5.6 ,  php-fpm5.6 --version | grep Xdebug
x, WP CLI           , wp         ,
x, FRENO            , freno         ,
x, sent            , sentimineo         ,
"
            local IFS
            local FILTER_THIS
            local ONE_TITLE
            local ONE_COMMAND
            local ONE_TEST
            local ONE_VERSION
            local ONE_WHICH
            local MIDDLE__LONGEST=$(get_longest_name_length "$(date)")
            local VERSION_EXTRACT_COMMAND
            (( MIDDLE__LONGEST ++ ))
            (( MIDDLE__LONGEST ++ ))
            local TABLE_VERSION_LENGTH
            local GOODIES="
echo \" \"
echo -e \"


"
            while read -r one_line; do
            {
              if [ ! -z "${one_line}" ]; then
              {
                IFS=\, read FILTER_THIS ONE_TITLE ONE_COMMAND ONE_TEST<<EOF
${one_line}
EOF
    echo "sudo -u ${USER_TO_INSTALL} -i -- command -v ${ONE_COMMAND}"
                if ( is_installed ${ONE_COMMAND} ) ; then
                {
                    echo "yup"
                  [ -z "${ONE_TEST}" ] && ONE_TEST="command ${ONE_COMMAND} --version"
                  ONE_VERSION=""
                  [[ "${FILTER_THIS}" == "x" ]] && ONE_VERSION=$(sudo -u ${USER_TO_INSTALL}  -i -- eval """${ONE_TEST}""" 2>&1 | extract_version  |  remove_letters | head -1)
                  [[ "${FILTER_THIS}" == "=" ]] && ONE_VERSION=$(sudo -u ${USER_TO_INSTALL}  -i -- eval """${ONE_TEST}""" 2>&1 | head -1 )
                  ONE_WHICH=""
                  [[ "${FILTER_THIS}" != "=" ]] && ONE_WHICH="$(sudo -u ${USER_TO_INSTALL} -i -- which ${ONE_COMMAND} 2>&1 | head -1 )"
                  ONE_VERSION=$(add_right_padding  "${ONE_VERSION}" ${MIDDLE__LONGEST} " ")
                  README_TABLE="${README_TABLE}
${ONE_TITLE}| ${ONE_VERSION} | ${ONE_WHICH}"

                  [ ! -z "${ONE_WHICH}" ] && ONE_WHICH="${GREEN}\t\t:${GRAYEDOUT}${ONE_WHICH}"
                  VERSION_EXTRACT_COMMAND="${RED}${ONE_TITLE}${GREEN}:${CYAN}${ONE_VERSION}${ONE_WHICH}"
                  GOODIES="${GOODIES}
${VERSION_EXTRACT_COMMAND}"
                }
                else
                {
                    echo "nop"
                     sudo -u "${USER_TO_INSTALL}" -i -- echo "command was ${ONE_COMMAND}"

                }
                fi
              }
              fi
            }
            done <<< "${local_commands}"

            README_TABLE="${README_TABLE}
\""


            GOODIES="${GOODIES}
\"
echo \" \"
echo \" \"
${README_TABLE}

# bash completion for the wp command

_wp_complete() {
  local OLD_IFS=\"\$IFS\"
  local cur=\${COMP_WORDS[COMP_CWORD]}

  IFS=\$'\n';  # want to preserve spaces at the end
  local opts=\"\$(wp cli completions --line=\"\$COMP_LINE\" --point=\"\$COMP_POINT\")\"

  if [[ \"\$opts\" =~ \<file\>\s* ]]
  then
    COMPREPLY=( \$(compgen -f -- \$cur) )
  elif [[ \$opts = \"\" ]]
  then
    COMPREPLY=( \$(compgen -f -- \$cur) )
  else
    COMPREPLY=( \${opts[*]} )
  fi

  IFS=\"\$OLD_IFS\"
  return 0
}
complete -o nospace -F _wp_complete wp

"
            echo "${GOODIES}"
} # end build_table_from_installed_components

        function chown_it() {
            # Sample use
            #            chown_it "${USER_TO_INSTALL}" /usr/local/rvm
            #            chown_it "${USER_TO_INSTALL}" /usr/local/rvm /usr/local/.nvm
            local USER_TO_INSTALL="${1}"
            local paths=$(switch_spaces_to_newlines <<< "${@}")
            local actions="
                [ -e \"{#}\" ] && sudo chown -R \"${USER_TO_INSTALL}\":\"${USER_TO_INSTALL}\" \"{#}\"
            "
            .each  "${actions}"   "${paths}"

        } # end chown_it

        function .each() {
            # Sample use
            #           ITEMS=$(find . -maxdepth 0 -type d | egrep -v "\.git")
            #           ACTIONS="echo \"Showing list for {#}\"  ls -la {#} "
            #
            #                    Perform all actions in
            #                           LIST1
            #                             for each element in
            #                                              LIST2
            #           .each  "${ACTIONS}"   "${ITEMS}"
            local local_actions="${1}"
            local local_items="${2}"
            local one_item
            local one_action
            local action

            while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                      while read -r one_action; do
                      {
                            if [ ! -z "${one_action}" ] ; then  # if not empty
                            {
                                  # replace value inside string substitution expresion bash
                                  action="${one_action/\{\#\}/${one_item}}"
                                  action="${action/\{\#\}/${one_item}}"
                                  action="${action/\{\#\}/${one_item}}"
                                  eval """${action}"""
                            }
                            fi
                      }
                      done <<< "${local_actions}"
                }
                fi
            }
            done <<< "${local_items}"
        } # end .each

        # enter_last_only_removed() {
        # sed ':a;N;$!ba;s/\n$//g' # GNU sed
        function trim_end_newlines() {
            sed -e ':a' -e 'N' -e '$!ba' -e 's/\n$//g'  #  cross-platform compatible syntax which works with BSD sed
        } # end trim_end_newlines
        # }

        function enter_encode() {
          #sed ':a;N;$!ba;s/\n/0N33NT3R/g'  # GNU sed
          sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/0N33NT3R/g'  #  cross-platform compatible syntax which works with BSD sed
        } # end enter_encode

        function enter_decode() {
          sed 's/0N33NT3R/\n/g'
        } # end enter_decode

        function switch_spaces_to_newlines() {
            sed 's/ /\n/g'
        } # end switch_spaces_to_newlines

        function contains_newlines() {
            # Sample use
            #            test1="asdf xcvb qwe sdfs "
            #            test2="asdf\nasdf\nasdf"
            #            ( ! contains_newlines "${test1}" ) && echo "no newlines"
            #            ( contains_newlines "${test2}" ) && echo "newlines"
            #            if ! contains_newlines "${test1}" ; then
            #            if contains_newlines "${test2}" ; then
            echo "${@}" | enter_encode
            local trimmed_testing=$(echo "${@}" | enter_encode)
            # ' Here I changed \n to 0N33NT3R' why? - For a weird reasons when assigning a var " " it adds \n to the  end of it so t="a" is actually t="a\n"
            [[ "${trimmed_testing}" == *"0N33NT3R"* ]] && return 0 # true contains enters
            return 1 # false no newlines
        } # end contains_newlines

        function out_of_root_folder_and_soft_link_back() {
            # Sample use
            #           you have:       /root/.folder
            #           and you want:  to move from  __root__     to     /home/${USER_TO_INSTALL}
            #           and link it back
            #           and you want:   /root/.folder  --->  /home/${USER_TO_INSTALL}/.folder
            #
            #            sudo mkdir /root/.test
            #            sudo out_of_root_folder_and_soft_link_back zeus .test
            #            sudo out_of_root_folder_and_soft_link_back jesus .test
            #            sudo out_of_root_folder_and_soft_link_back docker .test
            #            sudo out_of_root_folder_and_soft_link_back vagrant .test
            #            sudo out_of_root_folder_and_soft_link_back "${USER_TO_INSTALL}" .bundle
            #            sudo out_of_root_folder_and_soft_link_back "${USER_TO_INSTALL}" .bundle .gem .gems
            local USER_TO_INSTALL="${1}"
            if ( contains_newlines "${@}" ); then
            {
                local targets="${@}"
            }
            else
            {
                local targets=$(echo "${@}" | switch_spaces_to_newlines)
            }
            fi
            echo "${targets}"
            local actions="
                [ -d \"/home/${USER_TO_INSTALL}/{#}/\" ] && sudo rm -rf \"/home/${USER_TO_INSTALL}/{#}/\"
                [ -d \"/root/{#}/\" ] && sudo mv \"/root/{#}\" \"/home/${USER_TO_INSTALL}/\"
                [ -d \"/home/${USER_TO_INSTALL}/{#}/\" ] && sudo ln -sf  \"/home/${USER_TO_INSTALL}/{#}\" \"/root/{#}\"
                [ -d \"/home/${USER_TO_INSTALL}/{#}/\" ] && sudo chown -R \"${USER_TO_INSTALL}\":\"${USER_TO_INSTALL}\" \"/home/${USER_TO_INSTALL}/{#}/\"
            "
            .each  "${actions}"   "${targets}"
        } # end out_of_root_folder_and_soft_link_back

        function out_of_root_file_and_soft_link_back() {
            # Sample use
            #            out_of_root_file_and_soft_link_back "${USER_TO_INSTALL}" .bundle
            #            out_of_root_file_and_soft_link_back "${USER_TO_INSTALL}" .bundle .gem .gems
            local USER_TO_INSTALL="${1}"
            if contains_newlines "${@}" ; then
            {
                local targets="${@}"
            }
            else
            {
                local targets=$(echo "${@}" | switch_spaces_to_newlines)
            }
            fi
            local actions="
                [ -f \"/home/${USER_TO_INSTALL}/{#}\" ] && sudo rm -rf \"/home/${USER_TO_INSTALL}/{#}\"
                [ -f \"/root/{#}\" ] && sudo mv \"/root/{#}\" \"/home/${USER_TO_INSTALL}\"
                [ -f \"/home/${USER_TO_INSTALL}/{#}\" ] && sudo ln -sf  \"/home/${USER_TO_INSTALL}/{#}\" \"/root/{#}\"
                [ -f \"/home/${USER_TO_INSTALL}/{#}\" ] && sudo chown -R \"${USER_TO_INSTALL}\":\"${USER_TO_INSTALL}\" \"/home/${USER_TO_INSTALL}/{#}\"
            "
            .each  "${actions}"   "${targets}"
        } # end out_of_root_file_and_soft_link_back

        function move_to_user_folder_and_soft_link_root_to_it() {
            # Sample use
            #            move_to_user_folder_and_soft_link_root_to_it "${USER_TO_INSTALL}" .bundle
            local USER_TO_INSTALL="${1}"
            local target="${2}"

            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] && sudo rm -rf "/home/${USER_TO_INSTALL}/${target}/"
            [ -d "/root/${target}/" ] && sudo mv "/root/${target}" "/home/${USER_TO_INSTALL}/"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] && sudo ln -sf  "/home/${USER_TO_INSTALL}/${target}" "/root/${target}"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] && sudo chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/home/${USER_TO_INSTALL}/${target}/"

            # ${target} root -- different procedure ??? WTF
            # [ -d "/root/${target}/" ] && ( sudo rm -rf  "/root/${target}" )
            # [ ! -d "/home/${USER_TO_INSTALL}/${target}/" ] && ( sudo mkdir -p "/home/${USER_TO_INSTALL}/${target}" )
            # [ ! -d "/root/${target}/" ] && ( sudo ln -sf "/home/${USER_TO_INSTALL}/${target}"  "/root/${target}" )
        } # end move_to_user_folder_and_soft_link_root_to_it

        function move_to_user_file_and_soft_link_root_to_it() {
            # Sample use
            #            move_to_user_file_and_soft_link_root_to_it "${USER_TO_INSTALL}" .bundle
            local USER_TO_INSTALL="${1}"
            local target="${2}"

            [ -f "/home/${USER_TO_INSTALL}/${target}" ] && sudo rm -rf "/home/${USER_TO_INSTALL}/${target}"
            [ -f "/root/${target}" ] && sudo mv "/root/${target}" "/home/${USER_TO_INSTALL}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] && sudo ln -sf  "/home/${USER_TO_INSTALL}/${target}" "/root/${target}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] && sudo chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/home/${USER_TO_INSTALL}/${target}"

            # ${target} root -- different procedure ??? WTF
            # [ -f "/root/${target}" ] && ( sudo rm -rf  "/root/${target}" )
            # [ ! -f "/home/${USER_TO_INSTALL}/${target}" ] && ( sudo mkdir -p "/home/${USER_TO_INSTALL}/${target}" )
            # [ ! -f "/root/${target}" ] && ( sudo ln -sf "/home/${USER_TO_INSTALL}/${target}"  "/root/${target}" )
        } # end move_to_user_file_and_soft_link_root_to_it

    #[ ! -z "$0" ] && [ -e "$0" ] && THISSCRIPTNAME=`basename "$0"`

    # TRAP
    #[ ! -z "$0" ] && [   -e "$0" ] &&  trap '{  \" `basename "$0"` KEYBOARD INTERRUPT.\"; exit 69; }' INT
    #[   -z "$0" ] && [ ! -e "$0" ] &&  trap '{  \" STRUCT TESTING KEYBOARD INTERRUPT.\"; exit 69; }' INT
    #[ ! -z "$0" ] && [ ! -e "$0" ] &&  trap '{  \" STRUCT TESTING KEYBOARD INTERRUPT.\"; exit 69; }' INT

        #
        # Template:
        #
        #  echo -e "${GREEN} Installing ${RED}PYENV${GREEN} and ${CYAN} {PYTHON_VERSION}  ${CERO}"
        #
        #  procedure "${PYTHON_VERSION}"  >/dev/null 2>&1 # suppress stdln and errln output
        #
        #  Testing Checking install
        #  FOLDER MUST EXIST  /home/vagrant/.pyenv
        #  LINK MUST EXIST /root/.pyenv
        #  Python Must be PYTHON VERSION
        #
        #  directory_exists "/home/vagrant/.pyenv"
        #  file_exists "/home/vagrant/.zshrc"
        #  softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
        #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
        #
        #  CURRENT_VERSION=$(cat /home/vagrant/.pyenv/version)
        #  check_equality "${CURRENT_VERSION}=${PYTHON_VERSION}"

        #  echo -e " END ${THISSCRIPTNAME} ${CERO}"
        #  echo -e "${RED}  END ${THISSCRIPTNAME} ${CERO}"
        #  echo -e " END ${THISSCRIPTNAME} ${CERO}"

#
# STRUCT TESTING - END
#

   ##                    ######## ##    ## ########
  ##                     ##       ###   ## ##     ##
 ##                      ##       ####  ## ##     ##
##    ####### #######    ######   ## ## ## ##     ##
 ##                      ##       ##  #### ##     ##
  ##                     ##       ##   ### ##     ##
   ##                    ######## ##    ## ########

 ######  ######## ########  ##     ##  ######  ########
##    ##    ##    ##     ## ##     ## ##    ##    ##
##          ##    ##     ## ##     ## ##          ##
 ######     ##    ########  ##     ## ##          ##
      ##    ##    ##   ##   ##     ## ##          ##
##    ##    ##    ##    ##  ##     ## ##    ##    ##
 ######     ##    ##     ##  #######   ######     ##

######## ########  ######  ######## #### ##    ##  ######
   ##    ##       ##    ##    ##     ##  ###   ## ##    ##
   ##    ##       ##          ##     ##  ####  ## ##
   ##    ######    ######     ##     ##  ## ## ## ##   ####
   ##    ##             ##    ##     ##  ##  #### ##    ##
   ##    ##       ##    ##    ##     ##  ##   ### ##    ##
   ##    ########  ######     ##    #### ##    ##  ######

