#!/usr/bin/env bash
#!/bin/bash
#
# @author Zeus Intuivo <zeus@intuivo.com>
#
#
# Helper For testing installations, check files, softlinks, etc......checklist style

# Sample use

function sample_use_verify_mongo() {


    MONGO_VERSION="3.0.11"
    if [[ -n "${1}" ]] ;  then
        MONGO_VERSION="${1}"
    fi

    echo -e "${GREEN} Verify mongo version"
    CURRENT_VERSION=$(mongo --version  | egrep "MongoDB shell version" | head -1  | cut -d' ' -f4 | cut -d'v' -f2)
    check_equality "${CURRENT_VERSION}=${MONGO_VERSION}"
    echo -e "${GREEN} Verify mongod version"
    MONGOD_VERSION=$(mongod --version | egrep "db version" | head -1 | cut -d'v' -f3)
    check_equality "${MONGOD_VERSION}=${MONGO_VERSION}"

    TESTING=" verify that MongoDB has started ${CYAN}successfully${LIGHTYELLOW}"
    if [[ -n "${MONGO_PID}" ]] && [[ -n "${MONGO_TASKID}" ]] && [[ "${MONGO_SERVICE_STATUS}" == *"mongod start/running"* ]] ; then
    {

        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}       Service Status: ${CYAN}${MONGO_SERVICE_STATUS} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}            Mongo PID: ${CYAN}${MONGO_PID} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}        Mongo Task ID: ${CYAN}${MONGO_TASKID} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}      Which Mongo cli: ${CYAN}${WHICH_MONGO} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}        Mongo version: ${CYAN}${CURRENT_VERSION} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}   Which Mongo Server: ${CYAN}${WHICH_MONGOD} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW} Mongo Server version: ${CYAN}${MONGOD_VERSION} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}     Log last 4 lines: ${CYAN}${MONGO_LOG} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}     hugepage/enabled: ${CYAN}${FILE_CONTENTS_ENABLED} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}      hugepage/defrag: ${CYAN}${FILE_CONTENTS_DEFRAG} "
        passed "${TESTING}"

    }
    else
    {
        failed "${TESTING}"
    }
    fi

    directory_exists "
    /data
    /data/db
    /var/log/mongodb
    "

    # Disabled
    #/_/version-manager                             # Patch mongoo-manager form nodejs
    #/home/vagrant/.mongodb
    #softlink_exists "/root/.mongodb>/home/vagrant/.mongodb"

    file_exists "/etc/mongod.conf
    /etc/init/mongod.conf
    /etc/sysfs.conf
    /etc/mongo_vm_settings.conf
    /sys/kernel/mm/transparent_hugepage/khugepaged/defrag
    /sys/kernel/mm/transparent_hugepage/defrag
    /sys/kernel/mm/transparent_hugepage/enabled
    "
    # Extra notes
    # /etc/init/mongod.conf                           # This is the mongo service start|stop|status
    # /etc/default/mongod                             # There is ref to this file inside the service /etc/init/mongod.conf

    # Disabled
    #/etc/systemd/system/mongodb-hugepage-fix.service # service systemd  16.04
    #/etc/systemd/system/mongodb.service              # service systemd  16.04
    #/_/version-manager/bin/m.js                      # Patch mongoo-manager form nodejs
    #/_/version-manager/package.json                  # Patch mongoo-manager form nodejs

    #  softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
    #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
    #

}
# end function sample_use_verify_mongo

function HOW_TO_LOAD_SEVERAL_FILES() {

    load_execute_commands_wget() {
        local URL=""
        local cached_directory="$HOME/_/clis/execute_command_intuivo_cli/"
        local EXECOMCLI=""
        local provider=""
        [   -d "${cached_directory}" ] &&  provider="${cached_directory}"
        [ ! -d "${cached_directory}" ] &&  provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/"
        local BASH_SCRIPTS="
    struct_testing
    execute_command
    "
    #execute_command
        while read -r ONE_SCRIPT; do
        {
            if [ -n "${ONE_SCRIPT}" ] ; then         # if not empty
            {
                URL="${provider}${ONE_SCRIPT}"
                [   -d "${cached_directory}" ] && source "$URL"
                [ ! -d "${cached_directory}" ] &&eval """$(wget --quiet --no-check-certificate $URL  -O -  2>/dev/null )"""   # suppress only wget download messages, but keep wget output for variable
                echo "$URL Loaded"
            }
            fi
        }
        done <<< "${BASH_SCRIPTS}"
        unset URL
        unset EXECOMCLI
        unset ONE_SCRIPT
        unset BASH_SCRIPTS
        unset provider
        ( ( ! command -v passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading ${ONE_SCRIPT} \n \n " && exit 69; )
    }
    # end load_execute_commands_wget
    load_execute_commands_wget

    load_execute_commands_curl() {
        local URL=""
        local EXECOMCLI=""
        local cached_directory="$HOME/_/clis/execute_command_intuivo_cli/"
        local provider=""
        [   -d "${cached_directory}" ] &&  provider="file://${cached_directory}"
        [ ! -d "${cached_directory}" ] &&  provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/"
        local BASH_SCRIPTS="
    struct_testing
    execute_command
    "
    #execute_command
        while read -r ONE_SCRIPT; do
        {
            if [[ -n "${ONE_SCRIPT}" ]] ; then         # if not empty
            {
                URL="${provider}${ONE_SCRIPT}"
                eval """$(curl $URL  2>/dev/null )"""  # suppress only curl download messages, but keep curl output for variable
                echo "$URL Loaded"
            }
            fi
        }
        done <<< "${BASH_SCRIPTS}"
        unset URL
        unset EXECOMCLI
        unset ONE_SCRIPT
        unset BASH_SCRIPTS
        unset provider
        ( ( ! command -v passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    }
    # end load_execute_commands_curl
    load_execute_commands_curl

}
# end function HOW_TO_LOAD_SEVERAL_FILES

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_EXECUTE_COMMAND() {

    #Sample short call for loading execute command
    load_execute_command_curl() {
        local provider="$HOME/_/clis/execute_command_intuivo_cli/execute_command"
        [   -e "${provider}"  ] && source "${provider}" && echo "Loading Execute Command locally"
        command -v anounce_command >/dev/null 2>&1 && echo "                              \.. loading succeeded " && return 0
        ( [ ! -e "${provider}"  ] || ( ! command -v anounce_command >/dev/null 2>&1 ) ) && echo "Loading Execute Command from the net " && eval """$(curl https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/execute_command -o -  2>/dev/null )"""   # suppress only curl download messages, but keep curl output for variable
        ( ( ! command -v anounce_command >/dev/null 2>&1 ) && echo -e "\n \n  ERROR! Loading execute_command \n \n " && return 1 )
        return 0
    }
    # end load_execute_command_curl
    load_execute_command_curl
}
# end HOW_TO_LOAD_JUST_ONE_SCRIPT_EXECUTE_COMMAND

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL() {

    # Sample short call for loading struct_testing
    load_struct_testing_curl() {
        local provider="$HOME/_/clis/execute_command_intuivo_cli/struct_testing"
        [   -e "${provider}"  ] && source "${provider}" && echo "Loading Struct Testing locally"
        command -v passed >/dev/null 2>&1 && echo "                              \.. loading succeeded " && return 0
        ( [ ! -e "${provider}"  ] || ( ! command -v passed >/dev/null 2>&1 ) ) && echo "Loading Struct Testing from the net " && eval """$(curl https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing -o -  2>/dev/null )"""   # suppress only curl download messages, but keep curl output for variable
        ( ( ! command -v passed >/dev/null 2>&1 ) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && return 1 )
        return 0
    }
    # end load_struct_testing_curl
    load_struct_testing_curl

}
# end HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_WGET() {

    #Sample short call for loading struct_testing
    load_struct_testing_wget() {
        local provider="$HOME/_/clis/execute_command_intuivo_cli/struct_testing"
        [   -e "${provider}"  ] && source "${provider}" && echo "Loading Struct Testing locally"
        command -v passed >/dev/null 2>&1 && echo "                              \.. loading succeeded " && return 0
        ( [ ! -e "${provider}"  ] || ( ! command -v passed >/dev/null 2>&1 ) ) && echo "Loading Struct Testing from the net " && eval """$(wget --quiet --no-check-certificate  https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing -O -  2>/dev/null )"""   # suppress only wget download messages, but keep wget output for variable
        ( ( ! command -v passed >/dev/null 2>&1 ) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && return 1 )
        return 0
    }
    # end load_struct_testing_wget
    load_struct_testing_wget

}
# end HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_WGET

function HOW_TO_LOAD_JUST_ONE_SCRIPT_ONLINE_ALWAYS_STRUCT_USING_WGET() {

    load_struct_testing_wget() {
        # HOW TO LOAD JUST ONE SCRIPT
        EXECOMCLI=$(wget --quiet --no-check-certificate https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing -O -  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    }
    # end load_struct_testing_wget
    load_struct_testing_wget

}
# end HOW_TO_LOAD_JUST_ONE_SCRIPT_ONLINE_ALWAYS_STRUCT_USING_WGET





 ######  ######## ########  ##     ##  ######  ########
##    ##    ##    ##     ## ##     ## ##    ##    ##
##          ##    ##     ## ##     ## ##          ##
 ######     ##    ########  ##     ## ##          ##
      ##    ##    ##   ##   ##     ## ##          ##
##    ##    ##    ##    ##  ##     ## ##    ##    ##
 ######     ##    ##     ##  #######   ######     ##

######## ########  ######  ######## #### ##    ##  ######
   ##    ##       ##    ##    ##     ##  ###   ## ##    ##
   ##    ##       ##          ##     ##  ####  ## ##
   ##    ######    ######     ##     ##  ## ## ## ##   ####
   ##    ##             ##    ##     ##  ##  #### ##    ##
   ##    ##       ##    ##    ##     ##  ##   ### ##    ##
   ##    ########  ######     ##    #### ##    ##  ######

 ######  ########    ###    ########  ########                    ##
##    ##    ##      ## ##   ##     ##    ##                        ##
##          ##     ##   ##  ##     ##    ##                         ##
 ######     ##    ##     ## ########     ##       ####### #######    ##
      ##    ##    ######### ##   ##      ##                         ##
##    ##    ##    ##     ## ##    ##     ##                        ##
 ######     ##    ##     ## ##     ##    ##                       ##


#
# STRUCT TESTING - START
#

RED="\033[01;31m"
DARKERRED="\033[38;5;1m"
#RED="\033[38;5;1m"
ORANGE="\033[38;5;202m"

WHITE="\033[38;5;15m"
WHITEBOLD="\033[01;37m"
YELLOW="\033[01;33m"
YELLOW226="\033[38;5;226m"


GRAY="\033[38;5;8m"
GRAY241="\033[38;5;241m"
GRAYEDOUT="\033[01;30m"

GREEN="\033[01;32m"
LIGHTGREEN="\033[38;5;83m"
LIGHTPINK="\033[1;204m"
LIGHTYELLOW="\033[38;5;227m"


CYAN="\033[01;36m"
PURPLE="\033[01;35m"
DARKBLUE="\033[01;34m"
PURPLE_BLUE="\033[38;5;93m"
BRIGHT_BLUE87="\033[38;5;87m"

YELLOW_OVER_DARKBLUE="\033[38;5;220m\033[48;5;20m"
YELLOW_OVER_GRAY241="\033[38;5;220m\033[48;5;241m"
YELLOW_OVER_DARKBLUE2="\033[38;5;11m\033[48;5;18m"
LIGHTPINK_OVER_DARKBLUE="\033[38;5;204m\033[48;5;21m"
DARK_BLUE_OVER_PEACH="\033[38;5;20m\033[48;5;208m"


RESET="\033[0m"
CERO="\033[01;0m"

        function passed() {
            typeset -a ARGS="${@}"
            if [[ -n "${ARGS-x}" ]] ; then # if its set and not empty
            {
                echo -e "${LIGHTGREEN} ✔ ${LIGHTYELLOW} ${ARGS}  ${RESET}"
            }
            fi
        }
        function kill_execution() {
            echo -e " ☠ ${LIGHTPINK} KILL EXECUTION SIGNAL SEND ${RESET}"
            exit 69;
        }

        function warning() {
            typeset -a ARGS="${@}"
            if [[ -n "${ARGS-x}" ]] ; then # if its set and not empty
            {
                # echo -e "${BRIGHT_BLUE87} ${BASH_SOURCE}:${BASH_LINENO[0]} ${FUNCNAME[0]}()"
                # echo -e "${BRIGHT_BLUE87} ${BASH_SOURCE}:${BASH_LINENO[-1]} ${FUNCNAME[-1]}()"
                local __caller=$(caller)
                local -i __caller_line=$(echo "${__caller}" | cut -d' ' -f1)
                local __caller_script_name=$(echo "${__caller}" | cut -d' ' -f2)

                local __bash_source=""
                local -i _error_count=${#BASH_LINENO[@]}
                (( _error_count-- ))
                local -i _counter=0
                local -i _counter_offset=0
                echo -e " ☠ ${LIGHTPINK} ERROR STACK TRACE: ${len}  ${RESET}"  >&2
                # echo -e "0000${BRIGHT_BLUE87} ${BASH_SOURCE[0]}:${BASH_LINENO[0]} \t\t  ${FUNCNAME[0]}() ${RESET}"  >&2
                echo -e "${BRIGHT_BLUE87} ${__caller_script_name}:${__caller_line} \t\t  ${FUNCNAME[1]}() ${RESET}"  >&2
                for (( _counter=1; _counter<${_error_count}; _counter++ )); do
                    (( _counter_offset=_counter + 1 ))
                    # echo -e "${BASHCOMMAND[$_counter_offset]}"
                    echo -e "${BRIGHT_BLUE87} ${BASH_SOURCE[$_counter_offset]}:${BASH_LINENO[$_counter]} \t\t ${FUNCNAME[$_counter_offset]}() ${RESET}"  >&2
                done
                echo -e "$0:${BASH_LINENO[1]} ${FUNCNAME[1]}()"
                echo -e "${RED} 𝞦 ${LIGHTYELLOW} ${ARGS} ${RESET}"
            }
            fi
        }
        alias Warning=warning

        function failed() {
            # echo -e "${BASH_SOURCE[0]}:${BASH_LINENO[0]} \t\t  ${FUNCNAME[0]}() ${RESET}"  >&1
            # echo -e "${BASH_SOURCE[1]}:${BASH_LINENO[1]} \t\t  ${FUNCNAME[1]}() ${RESET}"  >&1
            # echo -e "${BASH_SOURCE[2]}:${BASH_LINENO[2]} \t\t  ${FUNCNAME[2]}() ${RESET}"  >&1
            warning "${@}  ${RED} has failed! "
            kill_execution
        }

        function enforce_parameter_with_options(){
          # Sample use
          # enforce_parameter_with_options 2 PLATFORM "${PLATFORM}" "mac windows linux"
          # Tests for the function
          # DEBUG=1
          local TESTING="enforce_parameter_with_options function ${FUNCNAME[1]} param at position ${RESET}<${YELLOW_OVER_DARKBLUE}${1}${RESET}${LIGHTYELLOW}> alias for <${CYAN}${2}${LIGHTYELLOW}> to have one of these values ${RESET}<${YELLOW_OVER_DARKBLUE}${4}${RESET}>"
          (( DEBUG )) && echo -e "${FUNCNAME[0]}"
          (( DEBUG )) && echo ${@} -assume existing variable for this part
          (( DEBUG )) && ( typeset -p "${1}"  &>/dev/null  ) && echo "1 defined 1"
          (( DEBUG )) && ( typeset -p "${2}"  &>/dev/null  ) && echo "2 defined 2"
          (( DEBUG )) && [ -n "${3+x}" ]  && echo "3 defined 3"
          (( DEBUG )) && [ -n "${4+x}" ]  && echo "4 defined 4"
          (( DEBUG )) && ( typeset -p "${2}"  &>/dev/null ) &&  [ -n "${3+x}" ]  && echo "2 declared,defined and with value not empty 3"
          (( DEBUG )) && ( ( typeset -p "${2}"  &>/dev/null  ) || echo "2 not defined 2")
          (( DEBUG )) && ( ! typeset -p "${2}"  &>/dev/null  ) && echo "2 not defined 3"
          local -i _seemsempty_=0
          [[ "x${3}x" = "xx" ]] && _seemsempty_=1
          (( _seemsempty_ )) && echo -e "${RED} 𝞦 \\n${BASH_SOURCE}:${BASH_LINENO[1]} ${FUNCNAME[-0]}(...) \\n$0:${BASH_LINENO[0]} ${FUNCNAME[1]}(...) \\n ${LIGHTYELLOW} ${TESTING} has failed "
          (( _seemsempty_ )) && failed "${TESTING}"
          (( _seemsempty_ )) && exit 1
          if ( typeset -p "${2}"  &>/dev/null ) &&  [ -n "${3+x}" ] ; then
          {
            local one=""
            local -i found=0
            while read -r one ; do
            {
              (( DEBUG )) && echo "checking value ${FUNCNAME[1]} ${3}  ${one} "
              if [[ -n "${one}" ]]  ; then
              {
                (( DEBUG )) && echo "one is "
                if [[ "${3}" == "${one}" ]] ; then
                {
                  found=1
                  break;
                }
                fi
              }
              fi
            }
            done <<< $(switch_spaces_to_newlines <<< "${@}")
            # done <<< "${4}"
            (( DEBUG )) && echo -e "${LIGHTGREEN} ✔ ${LIGHTYELLOW} ${TESTING} has passed "
            #(( found )) &&
            return 0
          }
          else
          {
            echo -e "${RED} 𝞦 \\n${BASH_SOURCE}:${BASH_LINENO[1]} ${FUNCNAME[-0]}(...) \\n$0:${BASH_LINENO[0]} ${FUNCNAME[1]}(...) \\n ${LIGHTYELLOW} ${TESTING} has failed "
            failed "${TESTING}"
            exit 1
          }
          fi

        } # end enforce_parameter_with_options

        function parameter_with_value() {
          # Sample use
          # if parameter_with_value 1 URL "${URL}" "https://www.website.com/product/" ; then
          # if ( parameter_with_value 3 PATTERN "${PATTERN}" "BCompareOSX*.*.*.*.zip" ) ; then
          # Tests for the function
          local TESTING="parameter_with_value function ${FUNCNAME[1]} expects value at position <"${1}"> expect value <"${2}"> to look like or can be are <"${4}">"
          (( DEBUG )) && echo -e "${FUNCNAME[0]}"
          (( DEBUG )) && echo ${@} -assume existing variable for this part
          (( DEBUG )) && ( typeset -p "${1}"  &>/dev/null  ) && echo "1 defined 1"
          (( DEBUG )) && ( typeset -p "${2}"  &>/dev/null  ) && echo "2 defined 2"
          (( DEBUG )) && [ -n "${3+x}" ]  && echo "3 defined 3"
          (( DEBUG )) && [ -n "${4+x}" ]  && echo "4 defined 4"
          (( DEBUG )) && ( typeset -p "${2}"  &>/dev/null ) &&  [ -n "${3+x}" ]  && echo "2 declared,defined and with value not empty 3"
          (( DEBUG )) && ( ( typeset -p "${2}"  &>/dev/null  ) || echo "2 not defined 2")
          (( DEBUG )) && ( ! typeset -p "${2}"  &>/dev/null  ) && echo "2 not defined 3"
          (( DEBUG )) && ( env | grep "${1}"  &>/dev/null  ) && echo "5 1 not in env "
          (( DEBUG )) && [ -n "${2+x}" ]  && echo "2 failed empty 8"
          (( DEBUG )) && [ -n "${2-x}" ]  && echo "2 failed empty 7"
          (( DEBUG )) && [ -z "${2+x}" ]  && echo "2 failed empty 9"
          (( DEBUG )) && [ -z "${2-x}" ]  && echo "2 failed empty 10"
          local -i _seemsempty_=0
          [[ "x${3}x" = "xx" ]] && _seemsempty_=1
          (( _seemsempty_ )) && echo -e "${RED} 𝞦 \\n${BASH_SOURCE}:${BASH_LINENO[1]} ${FUNCNAME[-0]}(...) \\n$0:${BASH_LINENO[0]} ${FUNCNAME[1]}(...) \\n ${LIGHTYELLOW} ${TESTING} has failed "
          (( _seemsempty_ )) && failed "${TESTING}"
          (( _seemsempty_ )) && exit 1
          if ( typeset -p "${2}"  &>/dev/null ) &&  [ -n "${3+x}" ] ; then
          {
              (( DEBUG )) && echo -e "${LIGHTGREEN} ✔ ${LIGHTYELLOW} ${TESTING} has passed "
              return 0
          }
          else
          {
            echo -e "${RED} 𝞦 \\n${BASH_SOURCE}:${BASH_LINENO[1]} ${FUNCNAME[-0]}(...) \\n$0:${BASH_LINENO[0]} ${FUNCNAME[1]}(...) \\n ${LIGHTYELLOW} ${TESTING} has failed "
            failed "${TESTING}"
            return 1
          }
          fi
          return 0
        } # end parameter_with_value

        function enforce_parameter_with_value() {
          # Sample use
          # enforce_parameter_with_value 1 URL "${URL}" "https://www.website.com/product/"
          # enforce_parameter_with_value 3 PATTERN "${PATTERN}" "BCompareOSX*.*.*.*.zip"
          # Tests for the function
          local TESTING="enforce_parameter_with_value function ${FUNCNAME[1]} expects value at position <"${1}"> expect value <"${2}"> to look like or can be are <"${4}">"
          if ( parameter_with_value "${1}" "${2}"  "${3}" "${4}"  ) ; then
          {
            return 0
          }
          else
          {
            echo -e "${RED} 𝞦 \\n${BASH_SOURCE}:${BASH_LINENO[1]} ${FUNCNAME[-0]}(...) \\n$0:${BASH_LINENO[0]} ${FUNCNAME[1]}(...) \\n ${LIGHTYELLOW} ${TESTING} has failed "
            failed "${TESTING}"
            exit 1
          }
          fi
          return 0
        } # end enforce_parameter_with_value

        function enforce_variable_with_value(){
          # Sample use
          # DEBUG=1
          # enforce_variable_with_value HOME $HOME
          # enforce_variable_with_value USER_HOME $USER_HOME
          # enforce_variable_with_value SUDO_USER $SUDO_USER
          # enforce_variable_with_value HOME $HOME && echo "HOME ensure_is_defined_and_not_empty 1"
          # Tests for the function
          # declare -rg USER_HOME=$(getent passwd $SUDO_USER | cut -d: -f6)
          #  ( typeset -p "HOME"  &>/dev/null )    @ Is HOME declared listed in declarations ?
          #  ( declare -p "HOME"  &>/dev/null )    @ Is HOME declared listed in declarations ?
          #  [ -n "${HOME+x}" ] && echo "HOME 1"   @ Is HOME declared and not empty?
          #  [ -z "${HOME+x}" ] && echo "HOME 1"   @ Is HOME declared and empty?
          # [ -n "${HOME+x}" ] && echo "HOME 1"
          # [ -n "${HOME+x}" ] && echo "HOME 12"
          # [ -n "${CAN_I_RUN_SUDO2+x}" ] && echo "CAN_I_RUN_SUDO2 null"
          # [ -n "${CAN_I_RUN_SUDO+x}" ] && echo "CAN_I_RUN_SUDO 12"
          # [ -n "${SUDO_USER+x}" ] && echo "SUDO_USER 111"
          # ( declare -p "HOME" ) && echo "HOME 2"
          local _err_arriving=$?
#          typeset -r TESTING="that variable is listed and: ${CYAN}${1}${LIGHTYELLOW} and has value: ${RESET}<${YELLOW_OVER_DARKBLUE}${2}${RESET}>"
          if [ ${_err_arriving} -gt 0 ] ; then
          {
             warning _err_arriving:${_err_arriving}
             warning failed $0 $*
             failed "${TESTING}" ${RED} Stopped executing becuase it arrived with \$_ERR not Zero
          }
          fi
          local -i _seemsempty_=0
          if (( DEBUG )) ; then
            echo -e "${FUNCNAME[0]}"
            echo "x${1}x" -assume existing variable for this part
            echo "x${2}x" -assume existing variable for this part
          fi
          [[ "x${2}x" = "xx" ]] && _seemsempty_=1
          if (( DEBUG )) ; then
            if [[ "x${2}x" = "xx" ]] ; then
              echo seems empty
            fi
            ( typeset -p "${1}"  &>/dev/null  ) && echo "1 defined 1"
            [ -n "${2+x}" ]  && echo "1 defined 2"
            ( typeset -p "${1}"  &>/dev/null ) &&  [ -n "${2+x}" ]  && echo "1 declared,defined and with value not empty 3"
            ( ( typeset -p "${1}"  &>/dev/null  ) || echo "1 not defined 1")
            ( ! typeset -p "${1}"  &>/dev/null  ) && echo "1 not defined 2"
            ( env | grep "${1}"  &>/dev/null  ) && echo "2 not in env "
            [ -n "${2+x}" ]  && echo "2 failed empty 8"
            [ -n "${2-x}" ]  && echo "2 failed empty 7"
            [ -z "${2+x}" ]  && echo "2 failed empty 9"
            [ -z "${2-x}" ]  && echo "2 failed empty 10"
            # echo QWER - assume non existant variable for this part
            # ( typeset -p "QWER"  &>/dev/null  ) && echo "QWER defined 1"
            # [ -n "${QWER+x}" ]  && echo "QWER defined 2"
            # ( typeset -p "QWER"  &>/dev/null ) &&  [ -n "${QWER+x}" ]  && echo "QWER defined 3"
            # ( typeset -p "QWER"  &>/dev/null  ) || echo "QWER not defined 1"
            # ( ! typeset -p "QWER"  &>/dev/null  ) && echo "QWER not defined 2"
            # echo bye
            # exit 0
          fi
          (( _seemsempty_ )) && echo -e "${RED} 𝞦 enforce_variable_with_value \\n${BASH_SOURCE[1]}:${BASH_LINENO[1]} ${FUNCNAME[-0]}(...) \\n${BASH_SOURCE[1]}:${BASH_LINENO[0]} ${FUNCNAME[1]}(...) \\n ${LIGHTYELLOW} ${TESTING} has failed "
          (( _seemsempty_ )) && failed "${TESTING}"
          (( _seemsempty_ )) && exit 1
          if (( typeset -p "${1}"  &>/dev/null ) &&  [ -n "${2+x}" ]) ; then
          {
              if (( DEBUG )) ; then
                echo -e "${LIGHTGREEN} ✔ ${LIGHTYELLOW} ${TESTING} has passed "
              fi
              return 0
          }
          fi
          echo -e "${RED} 𝞦 enforce_variable_with_value \\n${BASH_SOURCE[1]}:${BASH_LINENO[1]} ${FUNCNAME[-0]}(...) \\n${BASH_SOURCE[1]}:${BASH_LINENO[0]} ${FUNCNAME[1]}(...) \\n ${LIGHTYELLOW} ${TESTING} has failed "
          failed "${TESTING}"
          exit 1
        } # end enforce_variable_with_value

        function _contains() {
          # Sample use
          #   _contains ".tar.xz' $VAR
          #   _contains "nano-' $VAR
          local _what="${1}"
          local _which="${2}"
          if [[ "${_which}" == *"${_what}"* ]] ; then
          {
            return 0
          }
          fi
          return 1
        } # end _contains

        function enforce_contains() {
          # Sample use
          #   enforce_contains ".tar.xz' $VAR
          #   enfore_contains "nano-' $VAR
          local _what="${1}"
          local _which="${2}"
          local _test="expected to contain <${_what}> inside <${_which}>"
          if _contains "${_what}"  "${_which}"  ; then
          {
            return 0
          }
          fi
          failed "${_test}"
        } # end enforce_contains

        function assert() {
            # Sample usage
            #
            #     assert not empty "${SUBLIMEDEVLASTESTBUILD}"
            #     assert not empty "${SUBLIMEDEVLASTESTBUILD}"
            #     /home/vagrant/.pyenv"
            #
            #    0     1    2    3
            # assert not empty $VALUE
            if [  -z "${1+x}" ] || [ -z "${2+x}" ] || [ -z "${3+x}" ] ; then # check if all parameters are set and not empty
            {
                failed ${FUNCNAME[1]} requires to have 3 parameters :: ${FUNCNAME[1]} not empty \$VALUE ::
            }
            fi
            local not="${1}"
            local empty="${2}"
            local value="${3}"
            TESTING="${FUNCNAME[0]} that value ${CYAN}${value}${LIGHTYELLOW} is not empty"
            if [  -n "${value}" ] ; then
            {
                passed "${TESTING}"
            }
            fi
            failed "${TESTING}"
        }
        # end assert

        testself_assert() {
            assert not empty "hola"
        }
        #testself_assert  >/dev/null 2>&1 # suppress stdln and errln output

        function enhance_message() {
            local msg=""
            [[ -n "${1+x}"  ]] && msg="${1}"  ;  # check if a variable is set and not empty and reassign value
            msg=$(echo "${msg}" | sed  -e 's/ancel /anceling /g')
            msg=$(echo "${msg}" | sed  -e 's/uit /uiting /g')
            msg=$(echo "${msg}" | sed  -e 's/xit /xiting /g')
            echo "${msg}"
            [[ "${msg}" == *"anceling "* ]] && exit 69
            [[ "${msg}" == *"uiting "* ]] && exit 69
            [[ "${msg}" == *"xiting "* ]] && exit 69
        } # end enhance_message

        function ensure() {
            # Sample usage:
            # assuming mongo bin is in your path
            #            ensure mongo or " Cancel export"
            #            ensure mongoexport or " Cancel export"
            #            ensure bsondump or " Cancel export"
            #
            TESTING="that command ${CYAN}${1}${LIGHTYELLOW} exists in the path or can be reached from command line."
            if ! command -v "${1}" >/dev/null 2>&1;  then # Command Does not-exist
            {
              failed "${TESTING}"
              [[ -n "${3+x}"  ]] && enhance_message "${3}"
              return 1
            }
            fi
            passed "${TESTING}"
            return 0
        } # end ensure

        function Installing() {
            echo -e "${GREEN} Installing ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Installing
        alias installing=Installing

        function Downloading() {
            echo -e "${GREEN} Downloading ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Downloading
        alias downloading=Downloading

        function Loading() {
            echo -e "${CYAN} Loading ${GREEN}${1}${GRAY241}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Loading
        alias loading=Loading

        function Creating() {
            echo -e "${DARK_BLUE_OVER_PEACH} Creating ${YELLOW_OVER_DARKBLUE}${1}${GREEN}, ${LIGHTPINK_OVER_DARKBLUE}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Loading
        alias creating=Creating

        function Skipping() {
            echo -e "${DARK_BLUE_OVER_PEACH} Skipping ${YELLOW_OVER_DARKBLUE}${1}${GREEN}, ${LIGHTPINK_OVER_DARKBLUE}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Loading
        alias skipping=Skipping

        function Updating() {
            echo -e "${ORANGE} Updating ${BRIGHT_BLUE87}${1}${GREEN}, ${YELLOW226}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Loading
        alias updating=Updating

        function Testing() {
            echo -e "${CYAN} Testing ${PURPLE}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Testing
        alias testing=Testing

        function Configuring() {
            echo -e "${GREEN} Configuring ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Configuring
        alias configuring=Configuring

        function Setting() {
            echo -e "${GREEN} Setting ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Setting
        alias setting=Setting

        function Checking() {
            echo -e "${GREEN} Checking ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Checking
        alias checking=Checking

        function Final() {
            echo -e "${GREEN} Setting ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Final

        function Showing() {
            echo -e "${ORANGE} ø  ${PURPLE}${1}${ORANGE} ${CYAN}${2} ${DARKBLUE}${3} ${PURPLE_BLUE}${4} ${BRIGHT_BLUE87}${5} ${GREEN}${6} ${RED}${*:7} ${GREEN}.${RESET}"
            "${@}"
        } # end Showing
        alias showing=Showing


        function cüt() {
            # DUPLICATED IN script cüt

            # if value is not set  -- exit silent it
            if [[ -z "$1"  ]] ; then
                exit 0
            fi

            # Escape chars / !
            function escape_slashes {
                sed 's/\//\\\//g'
            }
            function escape_quotes {
                sed 's/\"/\\\"/g'
            }
            function escape_bangs {
                sed 's/\!/\\\!/g'
            }
            function escape_dots {
                sed 's/\./\\\./g'
            }
            function escape_braket_open {
                # sed "s/\[/5QU4R3D8R4CK3T0P3N/g"
                sed "s/\[/\\\[/g"
            }
# squared_braket_open_decode() {
    # sed "s/5QU4R3D8R4CK3T0P3N/\[/g"
    # sed "s/5QU4R3D8R4CK3T0P3N/\[/g"
# }

            SEEKING=$(echo """$*"""  | escape_dots | escape_slashes | escape_quotes | escape_bangs | escape_braket_open )



            # if everything else --

            # check operation systems
            (
              if [[ "$(uname)" == "Darwin" ]] ; then
                # Do something under Mac OS X platform
                sed 's/'"""${SEEKING}"""'//g' ;
              elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]] ; then
                # Do something under GNU/Linux platform
                sed 's/'"""${SEEKING}"""'//g'  ;

              elif [[ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" ]] ; then
                # Do something under Windows NT platform
                sed 's/'"""${SEEKING}"""'//g' ;
                # nothing here
              fi
            )
        }

        function Message() {
            trap 'exit 1' ERR
            local msg1="$1"
            local msg2=$(echo -e "${*}" | cüt "${1}"  ;)
            # local msg2=$(echo "${*}" | sed 's/'"""${msg1}"""'//g'  ;)
            echo  -e "${PURPLE}${PURPLE}+---${LIGHTYELLOW} ${LIGHTYELLOW} ${msg1} ${CYAN} ${msg2} ${RESET}"
        }
        alias message=Message

        function Comment() {
            trap 'exit 1' ERR
            local msg1="$1"
            local msg2=$(echo -e "${*}" | cüt "${1}"  ;)
            # local msg2=$(echo "${*}" | sed 's/'"""${msg1}"""'//g'  ;)
            echo  -e "${PURPLE}${CYAN}+---${DARKBLUE} ${LIGHTYELLOW} ${msg1} ${CYAN} ${msg2} ${RESET}"
        }
        alias comment=Comment

        function not() {
            local order="empty"  # Tasjgjgggg
            if [[ -n "${1+x}"  ]] ; then  # check if a variable is set and not empty
                NODE_VERSION="${1}"
            fi
        } # end not

        function directory_exists() {
            # Sample usage
            #
            #     directory_exists "/home/vagrant/.pyenv"
            #     directory_exists "/root/.pyenv
            #     /home/vagrant/.pyenv"
            #
            local _TESTING _ONE_DIR _DIRS="${@}"
            if [ ! -z "${DIRS-x}" ] ; then # if its set and not empty
            {
                _DIRS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r _ONE_DIR; do
                # if not empty
                if [ ! -z "${_ONE_DIR}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # _ONE_DIR="/Users/administrator/.pyenv"
                    _TESTING="that directory ${CYAN}${_ONE_DIR}${LIGHTYELLOW} exists"
                    if [[ -d "${_ONE_DIR}" && ! -L "${_ONE_DIR}" ]] ; then
                    {
                        passed "${_TESTING}"
                    }
                    else
                    {
                        failed "${_TESTING}"
                    }
                    fi
                fi
                done <<< "${_DIRS}"
            }
            fi
        } # end directory_exists


        function does_not_exist() {
            # Sample usage
            #
            #     does_not_exist "/home/vagrant/.pyenv"
            #     does_not_exist "/root/.pyenv
            #     /home/vagrant/.pyenv"
            #
            local _TESTING _ONE_DIR  _DIRS="${@}"
            if [ ! -z "${_DIRS-x}" ] ; then # if its set and not empty
            {
                _DIRS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r _ONE_DIR; do
                # if not empty
                if [ ! -z "${_ONE_DIR}" ] ; then
                {
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # _ONE_DIR="/Users/administrator/.pyenv"
                    _TESTING="that ${CYAN}${_ONE_DIR}${LIGHTYELLOW} does not exist"
                    if [[ ! -e "${_ONE_DIR}" ]] ; then
                    {
                        passed "${_TESTING}"
                    }
                    else
                    {
                        failed "${_TESTING}"
                    }
                    fi
                }
                fi
                done <<< "${_DIRS}"
            }
            fi
        } # end does_not_exist

        function does_not_exist_with_spaces() {
            # Sample usage
            #
            #     does_not_exist_with_spaces "/Applications/Google\ Chrome.app/"
            #     does_not_exist_with_spaces "/Applications/Google Chrome.app/"
            #
            local _TESTING _ONE_DIR="${*}"
            if [ -n "${_ONE_DIR-x}" ] ; then # if its set and not empty
            {
                # if not empty
                if [ ! -z "${_ONE_DIR}" ] ; then
                {
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # _ONE_DIR="/Users/administrator/.pyenv"
                    _TESTING="that ${CYAN}${_ONE_DIR}${LIGHTYELLOW} does not exist"
                    if [[ ! -e "${_ONE_DIR}" ]] ; then
                    {
                        passed "${_TESTING}"
                        return 0
                    }
                    else
                    {
                        failed "${_TESTING}"
                    }
                    fi
                }
                fi
            }
            fi
        } # end does_not_exist_with_spaces

        function directory_does_not_exist() {
            does_not_exist "$@"
        } # end directory_does_not_exist

        function directory_does_not_exist_with_spaces() {
            does_not_exist_with_spaces "${*}"
        } # end directory_does_not_exist_with_spaces

        function file_does_not_exists() {
            does_not_exist "$@"
        } # end file_does_not_exists

        function file_does_not_exist() {
            does_not_exist "$@"
        } # end file_does_not_exist

        function file_does_not_exist_with_spaces() {
            does_not_exist_with_spaces "${*}"
        } # end file_does_not_exist_with_spaces

        function it_does_not_exist(){
            return ! it_exists $@
        } # end it_does_not_exist

        function it_exists() {
            # Sample usage
            #
            #          if  ! it_exists "/home/vagrant/.zshrc" ; then    is like is NOT installed
            #          if  it_exists "/root/.zshrc ; then      it makes more sense to make it this way
            #
            local ONE_FILE FILES="${@}"
            if [ -n "${FILES-x}" ] ; then # if its set and not empty
            {
                FILES=$(switch_spaces_to_newlines <<< "${@}")
                # echo testing $FILES
                while read -r ONE_FILE; do
                {
                    # if not empty
                    # echo testing $ONE_FILE
                    # echo $ONE_FILE | hexdump -c
                    ONE_FILE=$(trim_end_newlines <<< "$ONE_FILE")
                    # echo $ONE_FILE | hexdump -c
                    if [ -n "${ONE_FILE}" ] ; then
                    {
                        # AS a NOTE ~/  <-- will fail always
                        # SO ~/.zshrc <-- will fail always
                        # But /home/user/.zshrc  <-- will pass
                        # OR Users/administrator/.zshrc  in mac <-- will pass
                        # ONE_FILE="/Users/administrator/.zshrc"
                        if [[ -s "${ONE_FILE}" && ! -L "${ONE_FILE}" ]] ; then
                        {
                            unset FILES
                            unset ONE_FILE
                            return 0 # it exists
                        }
                        fi
                    }
                    fi
                }
                done <<< "${FILES}"
                unset FILES
                unset ONE_FILE
                return 1 # it does not exists
            }
            fi
            unset FILES
            unset ONE_FILE
            return 0
        } # end it_exists

        function it_exists_with_spaces() {
            # Sample usage
            #
            #          if  ! it_exists_with_spaces "/home/vagrant/.zshrc" ; then    is like is NOT installed
            #          if  it_exists_with_spaces "/root/.zshrc ; then      it makes more sense to make it this way
            #
            local ONE_FILE
            local FILES="${*}"
            if [ -n "${FILES-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FILE; do
                # if not empty
                # DEBUG echo -e "${BASH_SOURCE[0]} ->\n  .. ${FUNCNAME[0]}():${ONE_FILE}"
                if [ -n "${ONE_FILE}" ] ; then
                {
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.zshrc <-- will fail always
                    # But /home/user/.zshrc  <-- will pass
                    # OR Users/administrator/.zshrc  in mac <-- will pass
                    # ONE_FILE="/Users/administrator/.zshrc"
                    if [[ -e "${ONE_FILE}" ]] ; then
                    {
                        return 0 # it exists
                    }
                    fi
                }
                fi
                done <<< "${FILES}"
            }
            fi
            return 1 # it does not exists
        } # end it_exists_with_spaces
        function it_does_not_exist_with_spaces() {
            # Sample usage
            #
            #          if  ! it_exists_with_spaces "/home/vagrant/.zshrc" ; then    is like is NOT installed
            #          if  it_exists_with_spaces "/root/.zshrc ; then      it makes more sense to make it this way
            #
            local ONE_FILE
            local FILES="${*}"
            if [ -n "${FILES-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FILE; do
                # if not empty
                # DEBUG echo -e "${BASH_SOURCE[0]} ->\n  .. ${FUNCNAME[0]}():${ONE_FILE}"
                if [ -n "${ONE_FILE}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.zshrc <-- will fail always
                    # But /home/user/.zshrc  <-- will pass
                    # OR Users/administrator/.zshrc  in mac <-- will pass
                    # ONE_FILE="/Users/administrator/.zshrc"
                    if [[ -e "${ONE_FILE}" ]] ; then
                    {
                        return 1 # it does not exists
                    }
                    fi
                fi
                done <<< "${FILES}"
            }
            fi
            return 0 # it exists
        } # end it_exists_with_spaces
        function file_exists() {
            # Sample usage
            #
            #     file_exists "/home/vagrant/.zshrc"
            #     file_exists "/root/.zshrc
            #     /home/vagrant/.pyenzshrcv"
            #
            local TESTING=""
            local ONE_FILE=""
            local -a FILES="${@}"
            if [ -n "${FILES-x}" ] ; then # if its set and not empty
            {
                FILES=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_FILE; do
                if [ -n "${ONE_FILE}" ] ; then # if not empty
                    TESTING="that file ${CYAN}${ONE_FILE}${LIGHTYELLOW} exists"
            # echo -e $TESTING
                    if it_exists "${ONE_FILE}" ; then
                    {
                        passed "${TESTING}"
                        return 0
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${FILES}"
            }
            fi
            unset ONE_FILE
            unset FILES
            unset TESTING
            return 1
        } # end file_exists
        function directory_exists_with_spaces() {
            # Sample usage
            #
            #     directory_exists_with_spaces "/Applications/Google Chrome.app/"
            #     directory_exists_with_spaces "$HOME/Downloads/"
            #     directory_exists_with_spaces "/Applications/Google\ Chrome.app/"
            #
            local _TESTING _ONE_DIR="${*}"
            if [ -n "${_ONE_DIR-x}" ] ; then # if its set and not empty
            {
                # if not empty
                if [[  -n "${_ONE_DIR}" ]] ; then
                {
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # _ONE_DIR="/Users/administrator/.pyenv"
                    _TESTING="that directory ${CYAN}${_ONE_DIR}${LIGHTYELLOW} exists"
                    if [[ -d "${_ONE_DIR}" && ! -L "${_ONE_DIR}" ]] ; then
                    # if it_exists_with_spaces "${_ONE_DIR}" ; then
                    {
                        passed "${_TESTING}"
                    }
                    else
                    {
                        failed "${_TESTING}"
                    }
                    fi
                }
                fi

            }
            fi
        } # end directory_exists_with_spaces
        # directory_exists_with_spaces "$HOME/Downloads/"
        function file_exists_with_spaces() {
            # Sample usage
            #
            #     file_exists_with_spaces "/home/vagrant/.zshrc"
            #     file_exists_with_spaces "/root/.zshrc
            #     /home/vagrant/.pyenzshrcv"
            #
            local ONE_FILE=""
            local TESTING=""
            local FILES="${*}"
            # DEBUG echo -e "${BASH_SOURCE[0]} ->\n  .. ${FUNCNAME[0]}():$FILES"
            if [ -n "${FILES-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FILE; do
                if [ -n "${ONE_FILE}" ] ; then # if not empty
                    TESTING="that file „${CYAN}${ONE_FILE}${LIGHTYELLOW}” exists"
                    # DEBUG echo -e "${BASH_SOURCE[0]} ->\n  .. ${FUNCNAME[0]}():$ONE_FILE"
                    if it_exists_with_spaces "${ONE_FILE}" ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${FILES}"
            }
            fi
        } # end file_exists_with_spaces

        function softlink_exists() {
            # Sample usage
            #
            #     softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
            #     softlink_exists "/Users/administrator/.nix-profile
            #     /Users/administrator/.nix-profile>/nix/var/nix/profiles/default"
            #     softlink_exists "/root/.pyenv"
            #     softlink_exists "/root/.pyenv
            #     /root/.pyenv>/home/vagrant/.pyenv"
            #
            local FOUND_LINK_TARGET=""
            local ONE_LINK_ORDER=""
            local -a _LINKS="${@}"
            if [ -n "${_LINKS-x}" ] ; then # if its set and not empty
            {
                _LINKS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_LINK_ORDER; do
                    # if not empty
                    if [ -n "${ONE_LINK_ORDER}" ] ; then
                    {
                        local CHECK_TARGET_TOO="NO"
                        local ONE_LINK_LOCATION="${ONE_LINK_ORDER}"
                        local ONE_LINK_TARGET=""

                        [[ "${ONE_LINK_ORDER}" == *">"* ]] && CHECK_TARGET_TOO="YES"
                        if [[ "${CHECK_TARGET_TOO}" == "YES" ]] ; then
                        {
                            ONE_LINK_LOCATION=$(cut -d'>' -f1 <<< "${ONE_LINK_ORDER}")
                            ONE_LINK_TARGET=$(cut -d'>' -f2 <<< "${ONE_LINK_ORDER}")
                        }
                        fi
                        # AS a NOTE ~/  <-- will fail always
                        # SO ~/.pyenv <-- will fail always
                        # But /home/user/.pyenv  <-- will pass
                        # OR Users/administrator/.pyenv  in mac <-- will pass
                        # ONE_LINK_LOCATION="/Users/administrator/.nix-profile"
                        local TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} exists"
                        if [[ -L "${ONE_LINK_LOCATION}" ]] ; then
                        {
                            # is a softlink
                            passed "${TESTING}"

                            # Test pointing
                            if [[ "${CHECK_TARGET_TOO}" == "YES" && ! -z "${ONE_LINK_TARGET}" ]] ; then
                            {
                                TESTING="${PURPLE} +-- and that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} points to ${CYAN}${ONE_LINK_TARGET}${GREEN} location \n"
                                FOUND_LINK_TARGET=$(ls -l ${ONE_LINK_LOCATION} | awk '{print $11}') # Find target symlink
                                if [[ "${FOUND_LINK_TARGET}" == "${ONE_LINK_TARGET}" ]] ; then
                                {
                                    # points to right location
                                    passed "${TESTING}"

                                    TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} is not broken"
                                    local empty_means_not_broken=""
                                    empty_means_not_broken="$(find "${ONE_LINK_LOCATION}" -type l ! -exec test -e {} \; -print  2>&1 | xargs -I {} ls -la "{}")"
                                    if [[ -z "${empty_means_not_broken}" ]] ; then
                                    {
                                        # points to right location
                                        TESTING=""
                                        passed "${TESTING}"
                                        return 0
                                    }
                                    elif  [[ "${empty_means_not_broken}" == *"No such file or directory"* ]] ; then
                                    {
                                        TESTING="but softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} is was not created"
                                        failed "${TESTING}"
                                        return 1
                                    }
                                    elif  [[ "${empty_means_not_broken}" == *"Permission denied"* ]] ; then
                                    {
                                        TESTING="but softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW}. Permission denied. Check Target -> ${ONE_LINK_TARGET} is accesible."
                                        failed "${TESTING}"
                                        return 1
                                    } else {
                                        failed "${TESTING}"
                                        return 1
                                    }
                                    fi
                                }
                                else
                                {
                                    TESTING+="${GREEN}     +++ expected${LIGHTYELLOW}:${CYAN}${ONE_LINK_TARGET}${LIGHTYELLOW}:${RED} --- actual${LIGHTYELLOW}:${RED}${FOUND_LINK_TARGET}${LIGHTYELLOW}:"
                                    failed "${TESTING}"
                                    return 1
                                }
                                fi
                            }
                            fi # TACHECK_TARGET_TOO is correct

                        }
                        else
                        {
                            failed "${TESTING}"
                            return 1
                        }
                        fi # ONE_LINK_LOCATION Exists
                    }
                    fi # not empty one link
                done <<< "${_LINKS}"
            }
            fi # not empty links
            return 1
        } # end softlink_exists

        function ensure_unlink() {
            if [ -s """${*}""" ] ; then
             unlink """${*}"""
            fi
        } # end ensure_unlink

        function ensure_rmdir() {
            if [ -d """${*}""" ] ; then
                rm -rf """${*}"""
            fi
        } # end ensure_rmdir

        function softlink_exists_with_spaces() {
            # Sample usage
            #
            #     softlink_exists_with_spaces "/Applications/Google\ Chrome.app/Contents/Profile/NativeMessagingHosts"
            #     softlink_exists_with_spaces "~/Library/Application\ Support/Google/Chrome/NativeMessagingHosts"
            #
            local FOUND_LINK_TARGET
            local ONE_LINK_ORDER
            local _LINKS="${*}"
            if [ -n "${_LINKS-x}" ] ; then # if its set and not empty
            {
                ONE_LINK_ORDER="${_LINKS}"
                    # if not empty
                    if [ -n "${ONE_LINK_ORDER}" ] ; then
                    {
                        local CHECK_TARGET_TOO="NO"
                        local ONE_LINK_LOCATION="${ONE_LINK_ORDER}"
                        local ONE_LINK_TARGET=""

                        [[ "${ONE_LINK_ORDER}" == *">"* ]] && CHECK_TARGET_TOO="YES"
                        if [[ "${CHECK_TARGET_TOO}" == "YES" ]] ; then
                        {
                            ONE_LINK_LOCATION=$(cut -d'>' -f1 <<< "${ONE_LINK_ORDER}")
                            ONE_LINK_TARGET=$(cut -d'>' -f2 <<< "${ONE_LINK_ORDER}")
                        }
                        fi
                        passed "${ONE_LINK_ORDER}"
                        # AS a NOTE ~/  <-- will fail always
                        # SO ~/.pyenv <-- will fail always
                        # But /home/user/.pyenv  <-- will pass
                        # OR Users/administrator/.pyenv  in mac <-- will pass
                        # ONE_LINK_LOCATION="/Users/administrator/.nix-profile"
                        local TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} exists"
                        if [[ -L "${ONE_LINK_LOCATION}" ]] ; then
                        {
                            # is a softlink
                            passed "${TESTING}"

                            # Test pointing
                            if [[ "${CHECK_TARGET_TOO}" == "YES" && ! -z "${ONE_LINK_TARGET}" ]] ; then
                            {
                                TESTING="${PURPLE} +-- and that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} points to ${CYAN}${ONE_LINK_TARGET}${GREEN} location \n"
                                FOUND_LINK_TARGET=$(ls -l ${ONE_LINK_LOCATION} | cut -d'>' -f2 | trim) # Find target symlink
                                if [[ "${FOUND_LINK_TARGET}" == "${ONE_LINK_TARGET}" ]] ; then
                                {
                                    # points to right location
                                    passed "${TESTING}"

                                    TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} is not broken"
                                    local empty_means_not_broken=$(find ${ONE_LINK_LOCATION} -type l ! -exec test -e {} \; -print  2>&1 | xargs -I {} ls -la "{}")
                                    if [[ -z "${empty_means_not_broken}" ]] ; then
                                    {
                                        # points to right location
                                        TESTING=""
                                        passed "${TESTING}"
                                        return 0
                                    }
                                    elif  [[ "${empty_means_not_broken}" == *"No such file or directory"* ]] ; then
                                    {
                                        TESTING="but softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} is was not created"
                                        failed "${TESTING}"
                                        return 1
                                    }
                                    elif  [[ "${empty_means_not_broken}" == *"Permission denied"* ]] ; then
                                    {
                                        TESTING="but softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW}. Permission denied. Check Target -> ${ONE_LINK_TARGET} is accesible."
                                        failed "${TESTING}"
                                        return 1
                                    } else {
                                        failed "${TESTING}"
                                        return 1
                                    }
                                    fi
                                }
                                else
                                {
                                    TESTING+="${GREEN}     +++ expected${LIGHTYELLOW}:${CYAN}${ONE_LINK_TARGET}${LIGHTYELLOW}:${RED}${RESET} --- actual:${FOUND_LINK_TARGET}:"
                                    failed "${TESTING}"
                                    return 1
                                }
                                fi
                            }
                            fi # TACHECK_TARGET_TOO is correct

                        }
                        else
                        {
                            failed "${TESTING}"
                            return 1
                        }
                        fi # ONE_LINK_LOCATION Exists
                    }
                    fi # not empty one link

            }
            fi # not empty links
            return 1
        } # end softlink_exists_with_spaces

        function check_equality() {
            # Sample usage
            #
            #     check_equality "1=1"
            #     check_equality "$(cat /home/vagrant/.pyenv/version)=${PYTHON_VERSION}
            #                     $(cat /home/vagrant/.pyenv/version)=2.7.11"
            #
            #     check_equality $(cat ~/.pyenv/version)="2.7.11"
            #
            (( DEBUG )) && echo "FUNCNAME[0]: <${FUNCNAME[0]}>"
            local -a ARGS="${@}"
            local LEFT_VALUE=""
            local RIGHT_VALUE=""
            local ONE_EQUALITY_ORDER=""
            if [ -n "${ARGS-x}" ] ; then # if its set and not empty
            {
                #ARGS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_EQUALITY_ORDER; do
                    # if not empty
                    if [ -n "${ONE_EQUALITY_ORDER}" ] ; then
                    {
                        LEFT_VALUE=$(echo """${ONE_EQUALITY_ORDER}""" | cut -d'=' -f1 | trim)
                        (( DEBUG )) && echo "-left: <$LEFT_VALUE>"
                        RIGHT_VALUE=$(echo """${ONE_EQUALITY_ORDER}""" | cut -d'=' -f2 | trim)
                        (( DEBUG )) && echo "right: <$RIGHT_VALUE>"

                        local TESTING="that value left value: ${CYAN}${LEFT_VALUE}${LIGHTYELLOW} exists"
                        if [[ -z "${LEFT_VALUE-x}" ]] ; then
                        {
                            failed "${TESTING}"
                            return 1
                        }
                        fi

                        TESTING="that value right value: ${CYAN}${RIGHT_VALUE}${LIGHTYELLOW} exists"
                        if [[ -z "${RIGHT_VALUE-x}" ]] ; then
                        {
                            failed "${TESTING}"
                            return 1
                        }
                        fi

                        TESTING="that expected:${YELLOW_OVER_DARKBLUE}${RIGHT_VALUE}${RESET}${LIGHTYELLOW}: is equal to actual:${YELLOW_OVER_DARKBLUE}${LEFT_VALUE}${RESET}:"
                        if [[ "${LEFT_VALUE}" ==  "${RIGHT_VALUE}" ]] ; then
                        {
                            passed "${TESTING}"
                            return 0
                        }
                        else
                        {
                            failed "${TESTING}"
                            return 1
                        }
                        fi
                    }
                    fi # not empty
                done <<< "${ARGS}"
            }
            fi
            return 1
        } # end function check_equality

        alias verify_equality=check_equality
        alias ensure_equality=check_equality


        function is_defined_and_not_empty(){
            # Sample use
            # is_defined_and_not_empty HOME $HOME
            # is_defined_and_not_empty USER_HOME $USER_HOME
            # is_defined_and_not_empty SUDO_USER $SUDO_USER
            # is_defined_and_not_empty HOME $HOME && echo "HOME is_defined_and_not_empty 1"
            # Tests for the function
            # declare -rg USER_HOME=$(getent passwd $SUDO_USER | cut -d: -f6)
            #  ( typeset -p "HOME"  &>/dev/null )    @ Is HOME declared listed in declarations ?
            #  ( declare -p "HOME"  &>/dev/null )    @ Is HOME declared listed in declarations ?
            #  [ -n "${HOME+x}" ] && echo "HOME 1"   @ Is HOME declared and not empty?
            #  [ -z "${HOME+x}" ] && echo "HOME 1"   @ Is HOME declared and empty?
            # [ -n "${HOME+x}" ] && echo "HOME 1"
            # [ -n "${HOME+x}" ] && echo "HOME 12"
            # [ -n "${CAN_I_RUN_SUDO2+x}" ] && echo "CAN_I_RUN_SUDO2 null"
            # [ -n "${CAN_I_RUN_SUDO+x}" ] && echo "CAN_I_RUN_SUDO 12"
            # [ -n "${SUDO_USER+x}" ] && echo "SUDO_USER 111"
            # ( declare -p "HOME" ) && echo "HOME 2"
            if ( typeset -p "${1}"  &>/dev/null ) &&  [ -n "${2+x}" ] ; then
            {
                return 0
            }
            fi
            return 1   # implied else
        } # end is_defined_and_not_empty


        function ensure_is_defined_and_not_empty(){
            # Sample use
            # ensure_is_defined_and_not_empty HOME $HOME
            # ensure_is_defined_and_not_empty USER_HOME $USER_HOME
            # ensure_is_defined_and_not_empty SUDO_USER $SUDO_USER
            # ensure_is_defined_and_not_empty HOME $HOME && echo "HOME ensure_is_defined_and_not_empty 1"
            local TESTING="that variable is defined and: ${CYAN}${1}${LIGHTYELLOW} not empty: ${YELLOW_OVER_DARKBLUE}${2}${RESET}"
            if is_defined_and_not_empty "${1}" "${2}" ; then
            {
                passed "${TESTING}"
                return 0
            }
            fi
            failed "${TESTING}"
            return 1
        } # end ensure_is_defined_and_not_empty

        function is_defined_and_empty(){
            # Sample use
            # is_defined_and_empty HOME $HOME
            # is_defined_and_empty USER_HOME $USER_HOME
            # is_defined_and_empty SUDO_USER $SUDO_USER
            if ( typeset -p "${1}"  &>/dev/null ) &&  [ -z "${2+x}" ] ; then
            {
                return 0
            }
            fi
            return 1
        } # end is_defined_and_empty

        function ensure_is_defined_and_empty(){
            # Sample use
            # ensure_is_defined_and_empty HOME $HOME
            # ensure_is_defined_and_empty USER_HOME $USER_HOME
            # ensure_is_defined_and_empty SUDO_USER $SUDO_USER
            local TESTING="that variable is defined and: ${CYAN}${1}${LIGHTYELLOW} is YES empty: ${YELLOW_OVER_DARKBLUE}${2}${RESET}"
            if is_defined_and_empty "${1}" "${2}" ; then
            {
                passed "${TESTING}"
                return 0
            }
            fi
            failed "${TESTING}"
            return 1
        } # end ensure_is_defined_and_empty

function _run_command(){
  # Sample usage:
  #
  #    if is_not_installed nest ; then
  #    {
  #        _run_command "npm i -g @nestjs/cli"
  #    }
  #    fi
  #    verify_is_installed "
  #    nest
  #    "
  #   verify_installed_version "node --version"  "cat .nvmrc"
  #   verify_installed_version "node --version"  "14.12"
  #
  # Pending Considering use of local trap:
  #    function __run_command_on_exit() {
  #      echo "${BASH_COMMAND}"
  #      echo "${BASH_SOURCE[0]}:${BASH_LINENO[1]} ${FUNCNAME[1]} EXIT"
  #      exec 1>&3  #    How to redirect output  REF: https://stackoverflow.com/questions/314675/how-to-redirect-output-of-an-entire-shell-script-within-the-script-itself
  #      cat "logs/__run_command.log"
  #    }
  #    trap __run_command_on_exit INT ERR EXIT
  #    local changelogfile="logs/__run_command.log"
  #    echo "$(date +%Y%m%d%H%M)">"${changelogfile}"
  #     exec 3>&1 1>>${changelogfile} 2>&1  # How to write output to both console and file REF: https://stackoverflow.com/questions/18460186/writing-outputs-to-log-file-and-console

  local _node_run_command=''
  echo -e "${PURPLE} ❓ ${CYAN}${*}"
  # shellcheck disable=SC2031
  if ( is_defined_and_not_empty SUDO_USER "${SUDO_USER}" && is_defined_and_not_empty SUDO_UID "${SUDO_UID}"  ) ; then
  {
    _node_run_command="$(su - "${SUDO_USER}" -c 'cd '"${CALLERPWD}"' ; '"${*}"'' 2>&1)"  # stout and stderr both get
    _err=$?
  }
  else
  {
    _node_run_command="$(cd "${CALLERPWD}" || true ; "${*}" 2>&1)"  # stout and stderr both get
    _err=$?
  }
  fi
  (( DEBUG )) && echo "__run_command: ${_node_run_command} --- _err: ${_err}"
  if [ $_err -ne 0 ] ;  then
  {
    >&2 echo -e "${RED} ✘ ${YELLOW_OVER_DARKBLUE}${*}${RESET} Err:$_err Output: $_node_run_command"
  }
  fi
  _err=$?
  enforce_variable_with_value _node_run_command ${_node_run_command}
  [ $_err -eq 0 ] && passed "${_node_run_command}"
  [ $_err -ne 0 ] && >&2 echo -e "${RED} ✘ ${RESET}${_node_run_command} __run_command returns"
  return $_err
} # end __run_command


        # REPEATED in execute_command

        trim_start_space() {
            sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g'
        }
        trim_end_space() {
            sed -e 's/[[:space:]]*$//' | sed 's/\ $//g' | sed 's/\t$//g'
        }
        trim() {
            trim_start_space | trim_end_space
        }
        convert_null() {
            if [ -z "${*}" ] ; then
            {
                echo "n8u8l"
            }
            else
            {
                echo """${@}"""
            }
            fi
        }
        convert_expects_internals() {
            if [[ "${*}" == '=' ]] ||  [[ "${*}" == '!' ]] ; then
            {
                echo "n8u8l"
            }
            else
            {
                echo """${@}"""
            }
            fi
        }
        function expect() {
            # Sample usage
            #
            #     expect $(echo "hola") to be equal to "hola"
            #     expect $(echo "hola") to be equal "hola"
            #     expect $(echo "hola") to equal to "hola"
            #     expect $(echo "hola") to equal "hola"
            #     expect $(echo "hola") be equal to "hola"
            #     expect $(echo "hola") be equal "hola"
            #     expect $(echo "hola") to be "hola"
            #     expect $(echo "hola") be "hola"
            #     expect $(echo "hola") = "hola"
            #      0        1           2  3   4
            #
            #     expect $(echo "hola") not to be equal to "hello"
            #     expect $(echo "hola") to not be equal to "hello"
            #     expect $(echo "hola") to be not equal to "hello"
            #     expect $(echo "hola") to be equal not to "hello"
            #     expect $(echo "hola") not to be equal "hello"
            #     expect $(echo "hola") to not be equal "hello"
            #     expect $(echo "hola") to be not equal "hello"
            #     expect $(echo "hola") not to equal "hello"
            #     expect $(echo "hola") to not equal "hello"
            #     expect $(echo "hola") to equal not "hello"
            #     expect $(echo "hola") to be "hello"
            #     expect $(echo "hola") not to be "hello"
            #     expect $(echo "hola") to not be "hello"
            #     expect $(echo "hola") to be not "hello"
            #     expect $(echo "hola") not be "hello"
            #     expect $(echo "hola") be not "hello"
            #     expect $(echo "hola") not "hello"
            #     expect $(echo "hola") ≠ "hello"
            #       0       1            2  3   4     5
            local statement=""
            statement="""${@}"""
                #| sed 's/'"="'/3QU4L51GN/g' \
                #| sed 's/'"!"'/3XCL4M4T10N/g' \
            (( DEBUG )) && echo -e "0.${RED}${FUNCNAME[1]} that value ${RED},,${CYAN}${statement}${RED}''${RESET}"
            # exit 0
            local inputo=""
            inputo=$(echo """${statement}""" \
                | sed 's/'"="'//g' \
                | sed 's/'"!"'//g' \
                | sed 's/'"~"'//g' \
                | sed 's/'" to not be the same as "'/!/g' \
                | sed 's/'" to not be the same as "'/!/g' \
                | sed 's/'" not same as "'/!/g' \
                | sed 's/'" not to be equal to "'/!/g' \
                | sed 's/'" to not be equal to "'/!/g' \
                | sed 's/'" to be not equal to "'/!/g' \
                | sed 's/'" to be equal not to "'/!/g' \
                | sed 's/'" not to be equal "'/!/g' \
                | sed 's/'" to not be equal "'/!/g' \
                | sed 's/'" to be not equal "'/!/g' \
                | sed 's/'" not to equal "'/!/g' \
                | sed 's/'" to not equal "'/!/g' \
                | sed 's/'" to equal not "'/!/g' \
                | sed 's/'" not to be "'/!/g' \
                | sed 's/'" to not be "'/!/g' \
                | sed 's/'" to be not "'/!/g' \
                | sed 's/'" not be "'/!/g' \
                | sed 's/'" be not "'/!/g' \
                | sed 's/'" not "'/!/g' \
                | sed 's/'" ≠ "'/!/g' \
                | sed 's/'"≠"'/!/g' \
                | sed 's/'" !! "'/!/g' \
                | sed 's/'"!!"'/!/g' \
                | sed 's/'"!!"'/!/g' \
                | sed 's/'" to be the same as "'/=/g' \
                | sed 's/'" same as "'/=/g' \
                | sed 's/'" to be equal to "'/=/g' \
                | sed 's/'" to be equal "'/=/g' \
                | sed 's/'" to equal to "'/=/g' \
                | sed 's/'" to equal "'/=/g' \
                | sed 's/'" be equal to "'/=/g' \
                | sed 's/'" be equal "'/=/g' \
                | sed 's/'" to be "'/=/g' \
                | sed 's/'" be "'/=/g' \
                | sed 's/'" == "'/=/g' \
                | sed 's/'" == "'/=/g' \
                | sed 's/'"=="'/=/g' \
                | sed 's/'" include "'/~/g' \
                | sed 's/'" includes "'/~/g' \
                | sed 's/'" to include "'/~/g' \
                | sed 's/'" to have included "'/~/g' \
                | sed 's/'" to have contained "'/~/g' \
                | sed 's/'" to contains "'/~/g' \
                | sed 's/'" to contain "'/~/g' \
                | sed 's/'" contains "'/~/g' \
                | sed 's/'" contain "'/~/g' \
                | sed 's/'" ~~ "'/~/g' \
                | sed 's/'" ~~ "'/~/g' \
                | sed 's/'"~~"'/~/g' \
            )
            (( DEBUG )) && echo -e "0.${RED}${FUNCNAME[1]} inputo ${RED},,${GREEN}${inputo}${RED}''${RESET}"
            # echo $inputo
            # return 0
            #    0     1    2   3
            # expect $value = $VALUE
            if [  -z "${1+x}" ] || [ -z "${2+x}" ] || [ -z "${3+x}" ] ; then # check if all parameters are set and not empty
            {
                >&2 echo -e "${RED} ✘ failed ${LIGHTYELLOW}${FUNCNAME[1]} requires to have 3 parameters :: ${FUNCNAME[1]} [not] to be equal to \$VALUE ::"
                return 1
            }
            fi
            local value_one=""
            local value_two=""
            local TESTING=""

            if [[ "${inputo}" == *"="* ]] ; then
            {
                if [[ "${inputo}" == "=" ]] ; then
                {
                    >&2 echo -e "${RED} ✘ failed ${LIGHTYELLOW}${TESTING}${YELLOW_OVER_GRAY241}"
                    return 1
                }
                fi
                value_one="${inputo%=*}"  # retain the part before the =
                (( DEBUG )) && echo -e "=value_one:${RED},,${YELLOW_OVER_DARKBLUE}$value_one${RED}''${RESET}"
                value_two="${inputo##*=}"  # retain the part after the =
                (( DEBUG )) && echo -e "=value_two:${RED},,${YELLOW_OVER_GRAY241}$value_two${RED}''${RESET}"
                # value_one=$(echo -n "${inputo}" | cut -d'=' -f1 | trim)
                # (( DEBUG )) && echo -e "=value_one:${RED},,${YELLOW_OVER_DARKBLUE}$value_one${RED}''${RESET}"
                # value_two=$(echo -n "${inputo}" | cut -d'=' -f2- | trim)
                # (( DEBUG )) && echo -e "=value_two:${RED},,${YELLOW_OVER_GRAY241}$value_two${RED}''${RESET}"
                value_one=$(convert_null "${value_one}")
                (( DEBUG )) && echo -e "=value_one:${RED},,${YELLOW_OVER_DARKBLUE}$value_one${RED}''${RESET}"
                value_two=$(convert_null "${value_two}")
                (( DEBUG )) && echo -e "=value_two:${RED},,${YELLOW_OVER_GRAY241}$value_two${RED}''${RESET}"
                TESTING="${RESET}${FUNCNAME[0]} that value ${YELLOW_OVER_DARKBLUE}${value_one}${RESET}${CYAN} same as ${YELLOW_OVER_GRAY241}${value_two}${RESET}"
                if [[ "${value_one}" == "${value_two}" ]] ; then
                {
                    local F="${FUNCNAME[1]/test_/}" # replace one occurence from test_ to
                    passed "${F//_/ }s" # replace all occurences from _ to
                    # passed "${FUNCNAME[1]/_/ }"
                    # passed "${TESTING}"
                    return 0
                }
                else
                {
                    >&2 echo -e "${RED} ✘ failed ${LIGHTYELLOW}${TESTING}${CYAN}"
                    return 1
                }
                fi
            }
            elif [[ "${inputo}" == *"!"* ]] ; then
            {
                if [[ "${inputo}" == "!" ]] ; then
                {
                    >&2 echo -e "${RED} ✘ failed ${LIGHTYELLOW}${TESTING}${CYAN}"
                    return 1
                }
                fi
                value_one="${inputo%!*}"  # retain the part before the !
                (( DEBUG )) && echo -e "!value_one:${RED},,${YELLOW_OVER_DARKBLUE}$value_one${RED}''${RESET}"
                value_two="${inputo##*!}"  # retain the part after the !
                (( DEBUG )) && echo -e "!value_two:${RED},,${YELLOW_OVER_GRAY241}$value_two${RED}''${RESET}"

                value_one=$(convert_null "${value_one}")
                (( DEBUG )) && echo -e "!value_one:${RED},,${YELLOW_OVER_DARKBLUE}$value_one${RED}''${RESET}"
                value_two=$(convert_null "${value_two}")
                (( DEBUG )) && echo -e "!value_two:${RED},,${YELLOW_OVER_GRAY241}$value_two${RED}''${RESET}"
                TESTING="${FUNCNAME[0]} that value ${YELLOW_OVER_DARKBLUE}${value_one}${RESET}${CYAN} not equal ${YELLOW_OVER_GRAY241}${value_two}${RESET}"
                if [[ "${value_one}" != "${value_two}" ]] ; then
                {
                    local F="${FUNCNAME[1]/test_/}" # replace one occurence from test_ to
                    passed "${F//_/ }s" # replace all occurences from _ to
                    # passed "${FUNCNAME[1]/_/ }"
                    # passed "${FUNCNAME[1]}"
                    # passed "${TESTING}"
                    return 0
                }
                else
                {
                    >&2 echo -e "${RED} ✘ failed ${LIGHTYELLOW}${TESTING}${CYAN}"
                    return 1
                }
                fi
            }
            elif [[ "${inputo}" == *"~"* ]] ; then
            {
                if [[ "${inputo}" == "~" ]] ; then
                {
                    >&2 echo -e "${RED} ✘ failed ${LIGHTYELLOW}${TESTING}${CYAN}"
                    return 1
                }
                fi
                value_one="${inputo%~*}"  # retain the part before the ~
                (( DEBUG )) && echo -e "~value_one:${RED},,${YELLOW_OVER_DARKBLUE}$value_one${RED}''${RESET}"
                value_two="${inputo##*~}"  # retain the part after the ~
                (( DEBUG )) && echo -e "~value_two:${RED},,${YELLOW_OVER_GRAY241}$value_two${RED}''${RESET}"

                value_one=$(convert_null "${value_one}")
                (( DEBUG )) && echo -e "~value_one:${RED},,${YELLOW_OVER_DARKBLUE}$value_one${RED}''${RESET}"
                value_two=$(convert_null "${value_two}")
                (( DEBUG )) && echo -e "~value_two:${RED},,${YELLOW_OVER_GRAY241}$value_two${RED}''${RESET}"

                TESTING="${FUNCNAME[1]} that value ${YELLOW_OVER_DARKBLUE}${value_one}${RESET}${CYAN} to contain ${YELLOW_OVER_GRAY241}${value_two}${RESET}"
                if [[ "${value_one}" == *"${value_two}"* ]] ; then
                {
                    # (( DEBUG )) &&
                    # echo -e "~caller:${RED},,${YELLOW_OVER_DARKBLUE}$(caller)${RED}''${RESET}"
                    # passed "${FUNCNAME[1]}"
                    local C="${THISSCRIPTNAME}:${BASH_LINENO[0]}"
                    local F="${FUNCNAME[1]/test_/}" # replace one occurence from test_ to
                    F="${F//_/ }s" # replace all occurences from _ to
                    passed "${C} ${F}" # replace all occurences from _ to
                    # passed "${TESTING}"
                    return 0
                }
                else
                {
                    >&2 echo -e "${RED} ✘ failed ${LIGHTYELLOW}${TESTING}${CYAN}"
                    return 1
                }
                fi
            }
            else
            {
                >&2 echo -e "${RED} ✘ failed. Case 1. Do not know how to do: ${LIGHTYELLOW}${TESTING}${CYAN}"
                return 1
            }
            fi
            >&2 echo -e "${RED} ✘ failed. Case 2. Do not know how to do: ${LIGHTYELLOW}${TESTING}${CYAN}"
            return 1
        } # end expect

        function enforce(){
            # Sample use
            #     if enforce 14.2.0 to be 12.18.3  ; then
            #     if enforce $__node_required to be $_node_version ; then
            local _msg=""
            _msg="$(expect "${@}" 2>&1)"
            local -i _err=$?
            if [ $_err -ne 0 ] ;  then
            {
                >&2 failed "$_msg"
                return $_err
            }
            fi
            >&1 passed "$_msg"
            return 0  # implied else
         } # end enforce

        function version_not_the_same(){
            # Sample use
            #     if version_not_the_same 14.2.0 to be 12.18.3  ; then
            #     if version_not_the_same $__node_required to be $_node_version ; then
            local _msg="$(expect "${@}" 2>&1)"
            local -i _err=$?
            if [ $_err -ne 0 ] ;  then
            {
                # >&2 echo -e "$_msg"
                return $_err
            }
            fi
            return 0  # implied else
         } # end version_not_the_same
#expect "hola" = "hello"
#expect "hola" = "hola"

        testself_expect() {
            local -a caso
            local -a exito
            local -i COUNTER
            COUNTER=0
            local res
            local nada=""
            caso[0]="hola"
            exito[0]="hola"
            caso[0]="hola el mundo"
            exito[0]="hola el mundo"
            for caso in "${caso[@]}"; do
            {
                test_case="Error: Self test failed: ${FUNCNAME[0]} ... expected <${caso}> to be equal to <${exito[$COUNTER]}>"
                pass_case="Passed: Self test: ${FUNCNAME[0]} ... expected <${caso}> to be equal to <${exito[$COUNTER]}>"
                # DEPRECATED if/pass/fail idea if ( expect "a{caso}" "not to be equal to" "${exito[$COUNTER]}" ) ; then passed "$pass_case"; else failed  "$test_case"; exit 69; fi

                expect "${nada}" "not to be equal to" "${exito[$COUNTER]}"
                expect "a{caso}" "not to be equal to" "${exito[$COUNTER]}"
                expect "a{caso}" not to be equal to "${exito[$COUNTER]}"
                expect "${nada}" "to be equal to" "${nada}"
                expect "${caso}" "to be equal to" "${exito[$COUNTER]}"
                expect "${caso}" "not to be equal to" "${nada}"
                expect "${nada}" "not to be equal to" "${exito[$COUNTER]}"
                expect "${caso}" to be equal to "${exito[$COUNTER]}"

                expect $(echo "${caso}") to be equal "${exito[$COUNTER]}"
                expect $(echo "${caso}") to equal to "${exito[$COUNTER]}"
                expect $(echo "${caso}") to equal "${exito[$COUNTER]}"
                expect $(echo "${caso}") be equal to "${exito[$COUNTER]}"
                expect $(echo "${caso}") be equal "${exito[$COUNTER]}"
                expect $(echo "${caso}") to be "${exito[$COUNTER]}"
                expect $(echo "${caso}") be "${exito[$COUNTER]}"
                expect $(echo "${caso}") = "${exito[$COUNTER]}"

                expect $(echo "${caso}") not to be equal to "hello"
                expect $(echo "${caso}") to not be equal to "hello"
                expect $(echo "${caso}") to be not equal to "hello"
                expect $(echo "${caso}") to be equal not to "hello"
                expect $(echo "${caso}") not to be equal "hello"
                expect $(echo "${caso}") to not be equal "hello"
                expect $(echo "${caso}") to be not equal "hello"
                expect $(echo "${caso}") not to equal "hello"
                expect $(echo "${caso}") to not equal "hello"
                expect $(echo "${caso}") to equal not "hello"
                expect $(echo "${caso}") not to be "hello"
                expect $(echo "${caso}") to not be "hello"
                expect $(echo "${caso}") to be not "hello"
                expect $(echo "${caso}") not be "hello"
                expect $(echo "${caso}") be not "hello"
                expect $(echo "${caso}") not "hello"
                expect $(echo "${caso}") ≠ "hello"
                (( COUNTER++ )) # if (( $COUNTER > 37 )) ; then
            }
            done
            exit 0
        }
        #testself_expect #&> /dev/null # stdln to hide command output in bash
        # testself_expect 2>&1 >/dev/null #  capture onlly sterr error output

        function check_to_be_installed() {
            # Sample usage
            #
            # ...  you want to APT-GET install  ... sysfsutils
            # ...  and you want to say          ... fix for transparent_hugepage
            #
            #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
            #
            local package="$1"
            local message="$2"
            local CHECK_INSTALLED=""
            if ( ( command -v apt >/dev/null 2>&1; ) && ( command -v dpkg >/dev/null 2>&1; ) ) ; then
            {
              CHECK_INSTALLED=$(dpkg -s "${package}")
              if [[ "${CHECK_INSTALLED}" == *"Package: ${package}"* ]] ; then
              {
                echo -e "${GREEN} PACKAGE: ${message}  ${package} is there  ${CERO}"
              }
              else
              {
                echo -e "${YELLOW} Installing ${message}   ${CERO}"
                sudo apt install "${package}" -y
              }
              fi
            }
            elif ( ( command -v rpm >/dev/null 2>&1; ) && ( command -v dnf >/dev/null 2>&1; ) ) ; then
            {
              CHECK_INSTALLED=$(rpm -qa|grep -i "${package}")
              if [[ "${CHECK_INSTALLED}" == *"Package: ${package}"* ]] ; then
              {
                echo -e "${GREEN} PACKAGE: ${message}  ${package} is there  ${CERO}"
              }
              else
              {
                echo -e "${YELLOW} Installing ${message}   ${CERO}"
                sudo dnf install "${package}" -y
              }
              fi

            }
            fi
        } # end check_to_be_installed

        function is_service_response_not_this_fail() {
            #Sample use
            # ( command -v nginx >/dev/null 2>&1; ) && sudo service nginx start
            #
            # is_service_response_not_this_fail "nginx" "$(sudo service nginx status)" "not running"
            # is_service_response_not_this_fail "puma" "$(sudo /etc/init.d/pumacontrol.sh status)" "not running"
            #
            local SERVICE_NAME SERVICE_STATUS SERVICE_FAIL_RESPONSE
            SERVICE_NAME="${1}"
            SERVICE_STATUS="${2}"
            SERVICE_FAIL_RESPONSE="${3}"
            TESTING="that service ${CYAN}${SERVICE_NAME}${LIGHTYELLOW} is running"
            if [[ "${SERVICE_STATUS}" == *"${SERVICE_FAIL_RESPONSE}"* ]] ; then
            {
                echo "${SERVICE_STATUS}"
                failed "${TESTING}"
                return 0
            }
            fi
            passed "${TESTING}"
            return 1
        } # end is_service_response_not_this_fail

        function is_service_running() {
            #Sample use
            # ( command -v nginx >/dev/null 2>&1; ) && sudo service nginx start
            #
            # is_service_running "nginx" "$(sudo service nginx status)" "is running"
            # is_service_running "puma" "$(sudo /etc/init.d/pumacontrol.sh status)" "is running"
            #
            local SERVICE_NAME="${1}"
            local SERVICE_STATUS="${2}"
            local EXPECTED_RESPONSE="${3}"
            echo SERVICE_NAME="${1}"
            echo SERVICE_STATUS="${2}"
            echo EXPECTED_RESPONSE="${3}"
            TESTING="that service ${CYAN}${SERVICE_NAME}${LIGHTYELLOW} ${EXPECTED_RESPONSE}"
            if [[ "${SERVICE_STATUS}" == *"${EXPECTED_RESPONSE}"* ]] ; then
            {
                passed "${TESTING}"
                return 0
            }
            fi
            echo "${SERVICE_STATUS}"
            failed "${TESTING}"
            return 1
        } # end is_service_running

        function type_function_exists() {
          # local DEBUG=1
          if ( is_defined_and_not_empty SUDO_USER "${SUDO_USER}" && is_defined_and_not_empty SUDO_UID "${SUDO_UID}"  ) ; then
          {
              (( DEBUG )) && echo "type_function_exists:SUDO DEFINED"
              if [[ "$( ( type "${*}" > /dev/null 2>&1 ) && echo "hola" )" == *"hola"* ]] ; then
              #if [[ "$(( ( su - $SUDO_USER -c 'type '"${*}"' >/dev/null 2>&1' ) ) && echo "hola" )" == *"hola"* ]] ; then
              #if ( su - $SUDO_USER -c 'type '"${*}"' >/dev/null 2>&1' ) ; then
              {
                (( DEBUG )) && echo "type_function_exists:TYPE is installed ${*} "
                return 0
              }
              fi
              (( DEBUG )) && echo "type_function_exists:TYPE is not installed ${*} "
              (( DEBUG )) && echo "type_function_exists:trying with command ${*} "
              if [[ "$( ( ( su - $SUDO_USER -c 'command -v '"${*}"' >/dev/null 2>&1' ) ) && echo "hola" )" == *"hola"* ]] ; then
              {
                (( DEBUG )) && echo "type_function_exists:COMMAND is installed ${*} "
                return 0
              }
              fi
              (( DEBUG )) && echo "type_function_exists:TYPE abd COMMAND fail to find installed or available ${*} "
              return 1
          }
          fi
          (( DEBUG )) && echo "type_function_exists:SUDO NOT DEFINED"
          # if [[ "$(( type wget > /dev/null 2>&1 ) && echo "hola" )" == *"hola"* ]] ; then  echo "has" ; else  echo "has not" ; fi
          # [[ "$(( type wgot > /dev/null 2>&1 ) && echo "hola" )" == *"hola"* ]] && echo "has"
          if [[ $( ( type "${*}" > /dev/null 2>&1 ) && echo "hola" ) == *"hola"* ]] ; then
          # if ( type "${*}" > /dev/null 2>&1 ) ; then
          {
            (( DEBUG )) && echo "type_function_exists:TYPE is installed ${*} "
            return 0
          }
          fi
          (( DEBUG )) && echo "type_function_exists:TYPE is not installed ${*} "
          (( DEBUG )) && echo "( type nvm > /dev/null 2>&1 )"
          return 1
        } # type_function_exists


        function is_installed() {
            # Sample use
            #
            #          if  ! is_installed wget ; then    is like is NOT installed
            #          if  is_installed wget ; then      it makes more sense to make it this way
            #
            local SERVICE_NAME="${*}"
            if type_function_exists "${SERVICE_NAME}"; then
            {
                #failed "${TESTING}"
                return 0
            }
            fi
            #passed "${TESTING}"  # assumed else
            return 1
        } # end is_installed

export is_not_installed
#function is_not_installed (){
#  if ( command -v $1 >/dev/null 2>&1; ) ; then
#    return 1
#  else
#    return 0
#  fi
#} # end is_not_installed

        function is_not_installed() {
            # Sample use
            #
            #          if  ! is_not_installed wget ; then # you can, but not recommended, because it is confusing to read
            #          if  is_not_installed wget ; then
            #
            local SERVICE_NAME="${*}"
            if ! type_function_exists "${SERVICE_NAME}"; then
            {
                #passed "${TESTING}"
                return 0
            }
            fi
            #failed "${TESTING}"  # assumed else
            return 1
        } # end is_not_installed

        function verify_is_installed() {
            # Sample use
            #
            #            verify_is_installed wget
            #
            local SERVICE_NAME
            local SERVICE_NAMES
            local TESTING
            if contains_newlines "${@}" ; then
            {
                SERVICE_NAMES="$(grep -vE '^\s+#|^#'<<<"${@}")"
                while read -r SERVICE_NAME; do
                {
                    if [[ -n "$SERVICE_NAME" ]] ; then  # is not empty
                    {
                        TESTING="that: ${CYAN}${SERVICE_NAME}${GREEN} is installed and executable from command line"
                        if !  is_installed "${SERVICE_NAME}"; then
                        {
                            failed "${TESTING}" # assumed else
                            return 1
                        }
                        fi
                        passed "${TESTING}"
                    }
                    fi
                }
                done <<< "${SERVICE_NAMES}"
                return 0
            }
            else
            {
                SERVICE_NAME="${1}"
                TESTING="that: ${CYAN}${SERVICE_NAME}${GREEN} is installed"
                if is_installed "${SERVICE_NAME}"; then
                {
                    passed "${TESTING}"
                    return 0
                }
                fi
                failed "${TESTING}" # assumed else
                return 1
            }
            fi
            failed "${TESTING}" # assumed else
            return 1
        } # end verify_is_installed

        function version_installed_is() {
            # Sample use
            #
            #          if  ! version_installed_is "node --version"  "${node_version}" ;           then    is like     version installed is  12.3.4.1 ?
            #          if  version_installed_is   "phantomjs --version"  "${phantomjs_version}" ; then    it like     NOT version is installed version 12.31.23 ?
            #
            local give_me_something=$(eval """${1}""" 2>&1 | extract_version | head -1)
            local expected="${2}"
            local TESTING="that installed version for ${give_me_something} is ${CYAN}${expected}${GREEN}"
            # passed "${give_me_something}" passed "${expected}" failed  "${TESTING}"
            # ( declare -p "${give_me_something}"  &>/dev/null ) &&  failed "${left value empty}" && return 0
            # ( declare -p "${expected}"  &>/dev/null ) &&  failed "${right value empty}" && return 0
            if [[ "${give_me_something}" == *"${expected}"* ]] || [[ "${give_me_something}" == "${expected}" ]]; then
            {
                return 0  #failed  "${TESTING}"
            }
            else
            {
                return 1  #passed  "${TESTING}"
            }
            fi
        } # end version_installed_is

        alias is_version_installed=version_installed_is
        alias is_installed_version=version_installed_is
        alias is_version=version_installed_is
        alias version_is=version_installed_is
function major_minor_version() {
  echo "${1%%.*}.$(x="${1#*.}"; echo "${x%%.*}")"
}

function version_gt() {
  [[ "${1%.*}" -gt "${2%.*}" ]] || [[ "${1%.*}" -eq "${2%.*}" && "${1#*.}" -gt "${2#*.}" ]]
}
function version_ge() {
  [[ "${1%.*}" -gt "${2%.*}" ]] || [[ "${1%.*}" -eq "${2%.*}" && "${1#*.}" -ge "${2#*.}" ]]
}
function version_lt() {
    # Sample use
    #
    #  macos_version="$(major_minor_version "$(/usr/bin/sw_vers -productVersion)")"
    #  if version_lt "$macos_version" "10.7"; then
    #  {
    #     failed "$(cat <<#EOABORT
    # Your Mac OS X version is too old. See:
    #   ${tty_underline}https://github.com/mistydemeo/tigerbrew${tty_reset}
    #EOABORT
    # )"
    #

    #
  [[ "${1%.*}" -lt "${2%.*}" ]] || [[ "${1%.*}" -eq "${2%.*}" && "${1#*.}" -lt "${2#*.}" ]]
}

        function verify_installed_version() {
            # Sample use
            #
            #            verify_installed_version "node --version"  "${node_version}"
            #            verify_installed_version "phantomjs --version"  "${phantomjs_version}"
            #            verify_installed_version "casperjs --version"  "${casper_version}"
            #
            ( declare -p "${1}"  &>/dev/null ) &&  failed "verify_installed_version -- left value empty" && exit 1
            ( declare -p "${2}"  &>/dev/null ) &&  failed "verify_installed_version -- right value empty" && exit 1
            local -i _err=0
            local evaled=""
            local COMMAND_TO_EVAL=""
            if ${1} &>/dev/null ; then
            {
              COMMAND_TO_EVAL=$(echo -n $(eval ${1}))
              _err=$?
              # echo "1 $_err  ${COMMAND_TO_EVAL}"
              evaled=$(echo -n "${COMMAND_TO_EVAL}" | extract_version | head -1)
              # echo "1 $_err  ${COMMAND_TO_EVAL}"
              # evaled<<<$($COMMAND_TO_EVAL)
              # evaled=$(${COMMAND_TO_EVAL})
            }
            else
            {
              _err=$?
              # echo "4 $_err ${COMMAND_TO_EVAL}"
              if [ $_err -eq 127 ] ; then
              {
                # echo "5 $_err  ${COMMAND_TO_EVAL}"
                # failed "1 verify_installed_version 1st argument needs to be an executable command. Command not found: <"""${2}""">"
                COMMAND_TO_EVAL="""${1}"""
                evaled="$COMMAND_TO_EVAL"
              }
              else
              {
                # echo "6 $_err  ${COMMAND_TO_EVAL}"
                # echo "1"
                COMMAND_TO_EVAL=$(echo -n $(eval ${1}))
                _err=$?
                # echo "1 $_err  ${COMMAND_TO_EVAL}"
                evaled=$(echo -n "${COMMAND_TO_EVAL}" | extract_version | head -1)
                # echo "1 $_err  ${COMMAND_TO_EVAL}"
                # evaled<<<$($COMMAND_TO_EVAL)
                # evaled=$(${COMMAND_TO_EVAL})
              }
              fi
            }
            fi
            # echo "test:${evaled}"
            _err=0
            local expected=""
            local VERSION_EXPECTED=""
            if ${2} &>/dev/null; then
            {
              # echo "2 $_err ${2}"
              VERSION_EXPECTED=$(eval ${2})
              _err=$?
              expected=$(echo -n "${VERSION_EXPECTED}" | extract_version | head -1)
              # expected<<<$($VERSION_EXPECTED)
              # expected=$(${VERSION_EXPECTED})
            }
            else
            {
              _err=$?
              # echo "7 $_err ${2}"
              if [ $_err -eq 127 ] ; then
              {
                # failed "1 verify_installed_version 2nd argument needs to be an executable command. Command not found: <"""${2}""">"
                VERSION_EXPECTED="""${2}"""
                expected="$VERSION_EXPECTED"
              }
              else
              {
                # echo "2 $_err ${2}"
                VERSION_EXPECTED=$(eval ${2})
                expected=$(echo -n "${VERSION_EXPECTED}" | extract_version | head -1)
                # expected<<<$($VERSION_EXPECTED)
                # expected=$(${VERSION_EXPECTED})
              }
              fi
            }
            fi
            # echo "expected:${expected}"
            # passed "${COMMAND_TO_EVAL}" passed "${VERSION_EXPECTED}"
            local TESTING="that installed ${GREEN}${1}${LIGHTYELLOW}: ${RED}<${CYAN}${evaled}${RED}>${LIGHTYELLOW} must equal ${GREEN}${2}${LIGHTYELLOW}: ${RED}<${CYAN}${expected}${RED}>${GREEN} "
            if [[ "${evaled}"  == *"${expected}"* ]] || [[ "${evaled}" == "${expected}" ]] ; then
            {
                passed "${TESTING}"
                return 0
            }
            fi
            # echo $(${COMMAND_TO_EVAL})
            failed "${TESTING}"
            exit 1
        } # end verify_installed_version

        function verify_installed_version_old() {
            # Sample use
            #
            #            verify_installed_version "node --version"  "${node_version}"
            #            verify_installed_version "phantomjs --version"  "${phantomjs_version}"
            #            verify_installed_version "casperjs --version"  "${casper_version}"
            #
            local EVAL_GET_VERSION_STRING=$(eval """${1}""" 2>&1 | head -1)
            local VERSION_EXPECTED="${2}"

            local TESTING="that installed version for ${1} is ${CYAN}${VERSION_EXPECTED}${GREEN}"
            if [[ "${EVAL_GET_VERSION_STRING}" == *"${VERSION_EXPECTED}"* ]] || [[ "${EVAL_GET_VERSION_STRING}" == "${VERSION_EXPECTED}" ]]; then
            {
                passed "${TESTING}"
            }
            else
            {
                echo -e "${RED} 𝞦 I got response: ${YELLOW_OVER_DARKBLUE}${EVAL_GET_VERSION_STRING}"
                failed "${TESTING}"
            }
            fi
        } # end verify_installed_version_old

function _ensure_touch_dir_and_file() {
    # Sample use
    #
    #  _ensure_touch_dir_and_file "${cronallowdir}" "${cronallowfile}"
    #  _ensure_touch_dir_and_file "${USER_HOME}/_/clis" "${USER_HOME}/_/clis/updateall.bash"
    #
    #
  local launchdir_default="${1}"
  local launchfile_default="${2}"

  enforce_variable_with_value launchdir_default "${launchdir_default}"
  enforce_variable_with_value launchfile_default "${launchfile_default}"
  enforce_variable_with_value SUDO_USER "${SUDO_USER}"
  enforce_variable_with_value USER_HOME "${USER_HOME}"

  if it_does_not_exist_with_spaces "${launchfile_default}" ; then
  {
    mkdir -p "${launchdir_default}"
    directory_exists_with_spaces "${launchdir_default}"
    touch "${launchfile_default}"
    chown -R "${SUDO_USER}" "${launchdir_default}"
  }
  fi
  file_exists_with_spaces "${launchfile_default}"
} # end _ensure_touch_dir_and_file

        function _if_not_is_installed(){
            local -i ret
            local msg
            ret=0
            if ( ( command -v apt >/dev/null 2>&1; ) && ( command -v dpkg >/dev/null 2>&1; ) ) ; then
            {
                msg="$(apt info $1  >/dev/null 2>&1)"
            }
            elif ( ( command -v rpm >/dev/null 2>&1; ) && ( command -v dnf >/dev/null 2>&1; ) ) ; then
            {
                msg="$(dnf info $1  >/dev/null 2>&1)"
            }
            elif ( command -v brew >/dev/null 2>&1; ) ; then
            {
                msg="$(su - "${SUDO_USER}" -c "/opt/homebrew/bin/brew info $1  >/dev/null 2>&1")"
            }
            fi
            ret=$?
            [ $ret -gt 0 ] && return 1
            [[ "$msg" == *"No such"* ]] && return 1
            [[ "$msg" == *"nicht gefunden"* ]] && return 1
            [[ "$msg" == *"Error"*   ]] && return 1
            return 0
        } # end _if_not_is_installed


        function _if_not_contains(){
            # Sample use:
            #       _if_not_contains  || run_this
            #       (_if_not_contains  "${cronallowfile}" "root") || echo 'root' >> "${cronallowfile}"
            #       (_if_not_contains  "${cronallowfile}" "${SUDO_USER}") ||  echo "${SUDO_USER}" >> "${cronallowfile}"
            #
            # discouraged use ---confusing using && and
            #    _if_not_contains  && run_this
            #
            # or
            #
            # echo "${policies}" > temp.xml
            # if ! _if_not_contains temp.xml "{1,}" ; then
            # {
            #   run this
            # } else {
            #    passed "passwords policy already set to {1,}"
            # }
            # fi
                    local -i ret
                    local msg
                    ret=0
                    if (( DEBUG )) ; then
                    {
                      echo "1if"
                    }
                    fi
                    if [ ! -e "$1" ] ; then
                    {
                     return 1
                    }
                    fi
                    if (( DEBUG )) ; then
                    {
                      (cat -n "$1" )
                    }
                    fi
                    msg=$(cat "$1" 2>&1)
                    ret=$?
                    if (( DEBUG )) ; then
                    {
                      echo "2if"
                      echo "${msg}"
                    }
                    fi
                    if [ $ret -gt 0 ] ; then
                    {
                      return 1
                    }
                    fi
                    if (( DEBUG )) ; then
                    {
                      echo "3if"
                    }
                    fi
                    [[ "$msg" == *"No such"* ]] && return 1
                    if (( DEBUG )) ; then
                    {
                      echo "4if"
                    }
                    fi
                    [[ "$msg" == *"nicht gefunden"* ]] && return 1
                    if (( DEBUG )) ; then
                    {
                      echo "5if"
                    }
                    fi
                    [[ "$msg" == *"Permission denied"* ]] && return 1
                    if (( DEBUG )) ; then
                    {
                      echo "6if"
                    }
                    fi
                    ret=0
                    if (( DEBUG )) ; then
                    {
                      echo 'echo "$msg" | grep "$2"'
                      echo 'echo "$msg" | grep "$2"'
                      ([[ -n "$msg" ]] ||  echo "6.5if file is empty")
                    }
                    fi
                    [[ -n "$msg" ]] || return 1    # Not found
                    msg=$(echo "$msg" | grep "$2" 2>&1)
                    ret=$?
                                        # TEST if [[ "$( echo "holahello" | 2>&1 grep "hllo" )" == *"hello"* ]] ; then {  ret=1; echo "ret"$ret; echo "found"; } else { echo "didnot work"; } fi;
                     #                   if [[ "$( echo "$msg" | 2>&1 grep "$2" )" == *"$2"* ]] ; then
                     #                   {
                                            # msg=$(echo "$msg" | grep "$2" 2>&1)
                                            # ret=$?  # expectef to get 1 for not found from grep
                     #                       ret=1
                     #                   }
                     #                   fi
                    if (( DEBUG )) ; then
                    {
                      echo "7if $ret"
                    }
                    fi
                    [ $ret -eq 0 ] && return 0     # Found
                    [ $ret -gt 0 ] && return 1    # Not Found
                    if (( DEBUG )) ; then
                    {
                      echo "8if"
                    }
                    fi
                    [[ "$msg" == *"No such"* ]] && return 1
                    if (( DEBUG )) ; then
                    {
                      echo "9 if"
                    }
                    fi
                    [[ "$msg" == *"nicht gefunden"* ]] && return 1
                    [[ "$msg" == *"Permission denied"* ]] && return 1
                    return 0  # Found
        } # end _if_not_contains

        function _if_contains(){
             # Sample use
             #
             # _if_contains && run_this
             #
             # or
             #
             # echo "${policies}" > temp.xml
             # if _if_contains temp.xml "{1,}" ; then
             # {
             #   passed "passwords policy already set to {1,}"
             # }
             # else
             # {
             #   echo "set ${policies}" > temp.xml
             # }
             # fi
             if _if_not_contains  "$1" "$2" ; then
             {
               return 0
             }
             fi
             return 1
        } # end _if_contains


# Checking selftest _if_contains
if it_exists_with_spaces "${USER_HOME}/.bashrc" ; then
{
  if _if_contains  "${USER_HOME}/.bashrc" "PETERPIZZA" ; then
  {
    failed "self test bad .bashrc should not have PETERPIZZA word"
  }
  fi
  if ! _if_contains  "${USER_HOME}/.bashrc" "then" ; then
  {
    failed ".bashrc should have the then word"
  }
  fi
  # echo hola
  # exit 0
}
fi


        function if_user_exists() {
            # Sample use
            #
            #            ( ! if_user_exists "postgres"  ) && failed "${TESTING}"
            #            ( if_user_exists "postgres"  ) && passed "${TESTING}"
            #
            local TARGET_USER="${1}"
            local TESTING="that user ${TARGET_USER} is ${CYAN}exists${GREEN}"
            local LIST_ALL_USERS=$(cut -d: -f1 /etc/passwd) # REF: http://askubuntu.com/questions/410244/a-command-to-list-all-users-and-how-to-add-delete-modify-users
            local USERID=$(id -u ${TARGET_USER})
            # Alternative to check getent passwd $user  > /dev/null
            # Alternative to check getent passwd mongodb  > /dev/null
            [ -z "${USERID}" ] &&  return 1 #failed
            return 0 #found
        } # end if_user_exists

        function check_if_user_exists() {
            # Sample use
            #
            #            check_if_user_exists "postgres"
            #
            local TARGET_USER="${1}"
            local TESTING="checking that user ${TARGET_USER} is ${CYAN}exists${GREEN}"
            ( ! if_user_exists "${TARGET_USER}"  ) && failed "${TESTING}"
            passed "${TESTING}"
        } # end check_if_user_exists

        function has_error_keyword() {
            # Sample use
            #
            #            has_error_keyword "${bulk}"
            #
            local bulk="${*}"
            if    [[ "${bulk}" == *"Could not resolve"*    ]] || \
                  [[ "${bulk}" == *"Repository not found"* ]] || \
                  [[ "${bulk}" == *"Could not read from"*  ]] || \
                  [[ "${bulk}" == *"Could not"*            ]] || \
                  [[ "${bulk}" == *"could not"*            ]] || \
                  [[ "${bulk}" == *"unmatched"*            ]] || \
                  [[ "${bulk}" == *"Fatal"*                ]] || \
                  [[ "${bulk}" == *"FATAL"*                ]] || \
                  [[ "${bulk}" == *"fatal"*                ]] || \
                  [[ "${bulk}" == *"FAILED"*               ]] || \
                  [[ "${bulk}" == *"failed"*               ]] || \
                  [[ "${bulk}" == *"Failed"*               ]] || \
                  [[ "${bulk}" == *"error"*                ]] || \
                  [[ "${bulk}" == *"ERROR"*                ]] || \
                  [[ "${bulk}" == *"Error"*                ]] || \
                  [[ "${bulk}" == *"Denied"*               ]] || \
                  [[ "${bulk}" == *"denied"*               ]] ; then
            {
                #passed "${TESTING}"
                return 0
            }
            else
            {
                #failed "${TESTING}"
                return 1
            }
            fi

        } # end has_error_keyword

        function handle_error() {
            # Sample use
            #
            #            local install_result=$(sudo apt-get install ${missing} -yfq   2>&1)  # capture all input and output
            #            [[ ! -z "${install_result}" ]] && handle_error "${install_result}"
            #
            local err_buff=$?
            # [ $err_buff -eq 0 ] && [ $1 -gt 0 ] && err_buff=$1
            local bulk="${*}"
            local error_happened=""
            [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff != 0 ] && error_happened="1"
            [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff != 0 )) && error_happened="1"
            if [ "${error_happened}" ]  ||  ( has_error_keyword "${bulk}" ) ; then
            {
              echo -e "${PURPLE_BLUE} action ${RED}failed ${YELLOW226}!!!  ${RESET}"
              [[ "${bulk}" == *"Could not resolve"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO INTERNET CONNECTION \o_0/ ${RESET}"
              [[ "${bulk}" == *"Repository not found"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO ACCESS TO THIS FOR YOU ${RED} ${GIT_USER_NAME} ${RESET}"
              [[ "${bulk}" == *"Could not read from"* ]] && echo -e "${BRIGHT_BLUE87} It appears it exists but you are ${RED}NOT ${YELLOW226} ALLOWED ${RED} ${GIT_USER_NAME} ${YELLOW226}!!! ${RESET}"
              failed "${RESET}${bulk}  "
            }
            fi

        } # end handle_error

        function extract_version() {
            # Bash extract version from a string REF:  https://superuser.com/questions/363865/how-to-extract-a-version-number-using-sed
            # sample usage
            # BASH_VERSION=$(extract_version  <<< $(/usr/bin/env bash --version) | head -1)
            # echo "bash version", $BASH_VERSION
            sed -nre 's/^[^0-9]*(([0-9]+\.)*[0-9]+).*/\1/p'
        } # end extract_version

        function vercomp() {
            # REF: https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
            if [[ $1 == $2 ]]
            then
                return 0
            fi
            local IFS=.
            local i ver1=($1) ver2=($2)
            # fill empty fields in ver1 with zeros
            for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
            do
                ver1[i]=0
            done
            for ((i=0; i<${#ver1[@]}; i++))
            do
                if [[ -z ${ver2[i]} ]]
                then
                    # fill empty fields in ver2 with zeros
                    ver2[i]=0
                fi
                if ((10#${ver1[i]} > 10#${ver2[i]}))
                then
                    return 1
                fi
                if ((10#${ver1[i]} < 10#${ver2[i]}))
                then
                    return 2
                fi
            done
            return 0
        } # end vercomp

        function testvercomp() {
            vercomp $1 $2
            case $? in
                0) op='=';;
                1) op='>';;
                2) op='<';;
            esac
            if [[ $op != $3 ]]
            then
                (( DEBUG )) && echo "struct_testing.testvercomp() FAIL: Expected '$3', Actual '$op', Arg1 '$1', Arg2 '$2'"
                return 1
            else
                (( DEBUG )) && echo "struct_testing.testvercomp() Pass: '$1 $op $2'"
                return 0
            fi
            # Tests
            # # Run tests
            # # argument table format:
            # # testarg1   testarg2     expected_relationship
            # echo "The following tests should pass"
            # while read -r test
            # do
            #     testvercomp $test
            # done << EOF
            # 1            1            =
            # 2.1          2.2          <
            # 3.0.4.10     3.0.4.2      >
            # 4.08         4.08.01      <
            # 3.2.1.9.8144 3.2          >
            # 3.2          3.2.1.9.8144 <
            # 1.2          2.1          <
            # 2.1          1.2          >
            # 5.6.7        5.6.7        =
            # 1.01.1       1.1.1        =
            # 1.1.1        1.01.1       =
            # 1            1.0          =
            # 1.0          1            =
            # 1.0.2.0      1.0.2        =
            # 1..0         1.0          =
            # 1.0          1..0         =
            # EOF

            # echo "The following test should fail (test the tester)"
            # testvercomp 1 1 '>'
        } # end testvercomp

        function to_lowercase() {
            local _words="${*}"
            (( DEBUG )) && echo "${*}"
            enforce_parameter_with_value 1** _words "${_words}" "HERE IS SOME TEXT"
            # local env_bash_version=$(extract_version  <<< $(/usr/bin/env bash --version) | head -1)
            local env_bash_version=$(extract_version  <<< $(echo $BASH_VERSION) | head -1)
            [ -z "${BASH_VERSION}" ] && env_bash_version=$(extract_version  <<< $(/usr/bin/env bash --version) | head -1)
            (( DEBUG )) && echo "bash version", $env_bash_version
            [ -z "${1}" ] && return 1  # no argument passed
            if ( testvercomp $env_bash_version 4 ">" ) ; then
            {
                # greater than version 3
                echo -n "${1,,}"         # bash Convert string to lowercase Bash 4 REF: https://stackoverflow.com/questions/2264428/converting-string-to-lower-case-in-bash-shell-scripting
            }
            else
            {
                # less than version 3
                echo -n "${1}" | sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'         # bash Convert string to lowercase Bash 4 REF: https://stackoverflow.com/questions/2264428/converting-string-to-lower-case-in-bash-shell-scripting
            }
            fi
        } # end to_lowercase
        alias downcase=to_lowercase

        function is_included() {
            # Sample use
            #            ( is_included imagemagick "imagemagick imagemagick-common" ) && echo "is included"
            #            packages=$(dpkg -l | egrep "tree" | cut -d' ' -f3 2>&1)
            #            ( is_included "tree" "${packages}" ) && echo "is included"
            #
            #    vagrant@:/var/www$ pacaga=$(dpkg -l | egrep imagemagick | cut -d' ' -f3  2>&1)
            #    vagrant@:/var/www$ [ $? == 0 ] && ( is_included "imagemagick" "${pacaga}" ) && echo "is included"
            #    vagrant@:$ = --->  is included

            #    vagrant@:/var/www$ pacaga=$(dpkg -l | egrep imagemagick | cut -d' ' -f3  2>&1)
            #    vagrant@:/var/www$ [ $? == 0 ] && ( is_included "imick" "${pacaga}" ) && echo "is included"
            #    vagrant@:$ = --->  (nil)

            #    local packages=$(dpkg -l | egrep "$one_required" | cut -d' ' -f3 2>&1)
            #    if [ $? == 0 ] && ( is_included "$one_required" "${packages}" ) ; then
            #    {
            #        passed " ${GREEN} $one_required ${YELLOW} INSTALLED${RESET} ."
            #    }
            #    else
            #    {
            #        echo -e " ${RED}  NEED TO INSTALL ${YELLOW} $one_required${RESET} ."
            #        missing="${missing} ${one_required}"
            #    }
            #    fi
            # echo "all:", $*
            # echo "1:", $1
            # echo "2:", $2
            [ -z "${*}" ] && return 1  # Nothing was passed
            # echo "hola"
            local all=$(switch_spaces_to_newlines <<< "${*}")
            # echo "all:", "$all"
            # local seoking="" # $(trim <<< "${1}")
            local seeking="" # $(to_lowercase "${seoking}")
            # echo $seoking
            # echo $seeking
            local one_item one_hay
            local COUNTER=0
            while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                    (( COUNTER++ ))
                    # echo "--circle", $one_item, $COUNTER
                    if (( $COUNTER == 1 )) ; then
                    {
                        # echo "in"
                        # seoking=$(trim <<< "${one_item}")
                        # seeking=$(to_lowercase <<< "${seoking}")
                        # echo $seoking
                        # echo $seeking
                        seeking="${one_item}"
                    }
                    else
                    {
                        # echo "else"
                        # one_hay=$(trim <<< "${one_item}")
                        # one_hay=$(to_lowercase "${one_hay}")
                        one_hay="${one_item}"
                        if [[ "${one_hay}" == "${seeking}" ]] ; then
                        {
                            # echo "found return 0"
                            return 0  # yes it is included
                        }
                        fi
                    }
                    fi
                }
                fi
            }
            done <<< "${all}"
            return 1  # No is not included
        } # end is_included

        function is_not_included() {
            # Sample use
            #
            #    if is_not_included fedora "imagemagick imagemagick-common" ; then
            #
            if ! is_included "${*}"; then
            {
                #passed "${TESTING}"
                return 0
            }
            else
            {
                #failed "${TESTING}"
                return 1
            }
            fi
        } # end is_not_included

        function install_requirements() {
            # Sample use
            #               local OS="${1}"
            #
            #               install_requirements "darwin" "
            #               node
            #               # instead of nvm
            #               nodenv
            #               rbenv
            #               ag@the_silver_searcher
            #               ack
            #               "
            #               install_requirements "${OS}" "
            #                        build-essential
            #                        # Ubuntu only
            #                        ag@silversearcher-ag
            #                        libreadline-dev
            #                        zlib1g-dev
            #                        flex
            #                        bison
            #                        libxml2-dev
            #                        libxslt-dev
            #                        libssl-dev
            #
            #                        libreadline6-dev
            #                        libossp-uuid-dev
            #                        uuid"
            #
            #

            # room for detecting Linux and OS systems
            local OS="${1}"
            local missing=""
            local one_required=""
            local install_this=""
            local required=$(grep -vE '^#'<<<$(grep -vE '^\s+#'<<<"${2}"))
            local packages=""
            local query=""
            local install_result=""
            local err_buff=0
            # local DEBUG=1s
            if ( ( command -v rpm >/dev/null 2>&1; ) && ( command -v dnf >/dev/null 2>&1; ) ); then
            {
                if (( DEBUG )) ; then
                  echo "rpm read packages"
                fi
                packages=$(rpm -qa)
                # (( DEBUG )) && echo "\n rpm \n \n $packages \n \n rpm"

            }
            elif ( ( command -v apt >/dev/null 2>&1; ) && ( command -v dpkg >/dev/null 2>&1; ) ) ; then
            {
                packages=$(dpkg -l | egrep "$one_required" | cut -d' ' -f3 2>&1)
            }
            elif ( command -v brew >/dev/null 2>&1; ) ; then
            {
                if (( DEBUG )) ; then
                  Comment struct_testing:$LINENO $FUNCNAME[0] "BREW list formulas"
                fi                # query=$(/opt/homebrew/bin/brew list --formula 2>&1)
                query=$(su - "${SUDO_USER}" -c "/opt/homebrew/bin/brew list --formula" 2>&1)
                if (( DEBUG )) ; then
                  Comment struct_testing:$LINENO $FUNCNAME[0] "$query"
                fi
                # query=$(_run_command "/opt/homebrew/bin/brew list --formula"  2>&1)
            }
            fi
            for one_required in ${required}; do
            {
              if [[ -z "${one_required}" ]] ; then
              {
                continue
              }
              fi
              if ( echo "${one_required}" | grep -q "^[[:space:]]*#" ) ; then
              {
                continue
              }
              fi
              if ( echo "${one_required}" | grep -q "@" ) ; then
              {
                install_this="$( echo "${one_required}" | cut -d@ -f2- )"
                one_required="$( echo "${one_required}" | cut -d@ -f1 )"
              } 
              else
              {
                install_this="${one_required}"
              }
              fi

              if [[ -z "${one_required}" ]] ; then
              {
                continue
              } 
              else
              {
                one_required=$(echo -n ${one_required} | sed -e 's/^[[:space:]]*//' ) # trim_start_space
              }
              fi
              if [[ -z "${install_this}" ]] ; then
              {
                install_this=$(echo -n ${one_required} | sed -e 's/^[[:space:]]*//' ) # trim_spaces
              } 
              else
              {
                install_this=$(echo -n ${install_this} | sed -e 's/^[[:space:]]*//' ) # trim_spaces
              }
              fi
              if ( ( command -v apt >/dev/null 2>&1; ) && ( command -v dpkg >/dev/null 2>&1; ) ) ; then
              {
                if (( DEBUG )) ; then
                  Comment struct_testing:$LINENO $FUNCNAME[0] "apt search using dpkg"
                fi
                # REF: https://www.cyberciti.biz/faq/find-out-if-package-is-installed-in-linux/
                if query=$(dpkg-query -W -f='${Status} ${Version}\n' "$one_required"  2>&1) ; then
                {
                    echo -e " ${CYAN}  CHECKING ${YELLOW} $one_required${RESET}"
                }
                fi
                #if [[ "${query}" == "install ok"* ]] && ( is_included "$one_required" "${packages}" ); then
                if [[ "${query}" == "install ok"* ]] ; then
                {
                    passed " ${GREEN} $one_required ${YELLOW} INSTALLED${RESET} ."
                }
                else
                {
                    echo -e " ${RED}  NEED TO INSTALL ${YELLOW} $one_required${RESET} ${RED}...${query}"
                    missing="${missing} ${install_this}"
                    if (( DEBUG )) ; then
                      Comment struct_testing:$LINENO $FUNCNAME[0]  "${install_this}"
                    fi
                }
                fi
              }
              elif ( ( command -v rpm >/dev/null 2>&1; ) && ( command -v dnf >/dev/null 2>&1; ) ) ; then
              {
                if (( DEBUG )) ; then
                  Comment struct_testing:$LINENO $FUNCNAME[0] "rpm search loaded packages $one_required"
                  echo "rpm --------1"
                  echo "${packages}" | grep "$one_required"
                  echo "rpm --------2"
                  echo "${packages}" | grep "$one_required"| grep "^$one_required"
                  echo "rpm --------3"
                  echo "${packages}" | egrep "$one_required"| grep "^$one_required" | cut -d'-' -f1
                  echo "rpm --------4"
                  echo "rpm RETURNED:$?"
                fi
                if     ( echo "${packages}" | grep "$one_required" >/dev/null 2>&1; ) \
                    && ( echo "${packages}" | grep "$one_required"| grep "^$one_required" >/dev/null 2>&1; ) \
                    && ( echo "${packages}" | egrep "$one_required"| grep "^$one_required" | cut -d'-' -f1  >/dev/null 2>&1; ) ; then
                {
                    if (( DEBUG )) ; then
                      echo "rpm passed"
                    fi
                    passed " ${GREEN} $one_required ${YELLOW} INSTALLED${RESET} ."
                }
                else
                {
                    if (( DEBUG )) ; then
                      echo "rpm failed"
                    fi
                    echo -e " ${RED}  NEED TO INSTALL ${YELLOW} $one_required${RESET} ${RED}...${query}"
                    missing="${missing} ${install_this}"
                    if (( DEBUG )) ; then
                      echo  "${install_this}"
                    fi
                }
                fi
              }
              elif ( command -v /opt/homebrew/bin/brew >/dev/null 2>&1; ) ; then
              {
                if (( DEBUG )) ; then
                  Comment struct_testing:$LINENO $FUNCNAME[0] "/opt/homebrew/bin/brew"
                fi
                # CHECK_INSTALLED=$(brew ls --versions "${one_required}")
                # CHECK_INSTALLED=$(/opt/homebrew/bin/brew ls --versions "${one_required}")
                # query=$(brew list --formula 2>&1)
                # one_required="nano"
                # query=$(su - "${SUDO_USER}" -c "brew list --formula" 2>&1)
                # query=$(_run_command "brew list --formula"  2>&1)
                # ( echo "${query}" | grep -q  "^zsh$" )  && echo "installed"
                # [[ "$( echo "${query}" | grep   "^unar$" )" == "unar" ]] && echo "installed"
                # ( echo "${query}" | grep -q  "^${one_required}$" ) && echo "installed"
                if  ( echo "${query}" >/dev/null 2>&1 | grep -q  "^${one_required}$" >/dev/null 2>&1; ) ; then
                {
                    passed " ${GREEN} $one_required ${YELLOW} INSTALLED${RESET} ."
                }
                else
                {
                    echo -e " ${RED}  NEED TO INSTALL ${YELLOW} $one_required${RESET} ${RED}..."
                    # echo -e "${YELLOW} Installing ${one_required}  ${CERO}"
                    missing="${missing} ${install_this}"
                    # su - "${SUDO_USER}" -c "brew install \"${install_this}\" "
                    # _run_command "brew install \"${install_this}\" "
                }
                fi
              }
              fi
            }
            done


            # Check Requirements OS Ubuntu 14.04 REF: https://wiki.postgresql.org/wiki/Compile_and_Install_from_source_code#Ubuntu
            if [[ -n "${missing}" ]] ; then
            {
              if (( DEBUG )) ; then
                Comment struct_testing:$LINENO $FUNCNAME[0] "There are missing"
              fi
              missing=$(echo -n ${missing} | sed -e 's/^[[:space:]]*//' ) # trim_start_space
              echo -e " ${CYAN} Installing missing packages: ${YELLOW} ${missing} ${RESET} ."
              if ( ( command -v apt >/dev/null 2>&1; )  && ( command -v dpkg >/dev/null 2>&1; ) ); then
              {
                if (( DEBUG )) ; then
                  echo "apt install"
                fi
                install_result=$(sudo apt install ${missing} -yfq   2>&1) # capture all input and output
                err_buff=$?
              }
              elif ( ( command -v rpm >/dev/null 2>&1; ) && ( command -v dnf >/dev/null 2>&1; ) ) ; then
              {
                if (( DEBUG )) ; then
                  echo "dnf install ${missing}"
                fi
                install_result=$(sudo dnf install ${missing} -y  2>&1) # capture all input and output
                if (( DEBUG )) ; then
                  echo "dnf install_result"
                fi
                err_buff=$?
              }
              elif ( command -v brew >/dev/null 2>&1; ) ; then
              {
                # _run_command brew install ${missing}
                if (( DEBUG )) ; then
                  Comment struct_testing:$LINENO $FUNCNAME[0] "/opt/homebrew/bin/brew install"
                  echo "brew install "
                fi
                if [[ -e /opt/homebrew/bin/brew ]] ; then
                {
                    install_result=$(su - "${SUDO_USER}" -c "/opt/homebrew/bin/brew install ${missing} " 2>&1) # capture all input and output
                    err_buff=$?
                }
                else
                {
                    install_result=$(su - "${SUDO_USER}" -c "brew install ${missing} " 2>&1) # capture all input and output
                    err_buff=$?
                }
                fi
                if (( DEBUG )) ; then
                  Comment struct_testing:$LINENO $FUNCNAME[0] install_result="${install_result}"
                  Comment struct_testing:$LINENO $FUNCNAME[0] err_buff="${err_buff}"
                fi
              }
              fi
            }
            fi
            if [[ "${install_result}" == *"is already installed"* ]] ; then
             echo -e "${BRIGHT_BLUE87}  ${install_result}  \o_0/ ${RESET} ... ignoring "
            fi
            # echo $install_result;
            if [[ -n "${install_result}" ]] ; then #  && handle_error "${install_result}"
            {
                if (( DEBUG )) ; then
                  Comment struct_testing:$LINENO $FUNCNAME[0] "errors install"
                fi
                local error_happened=""
                [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff != 0 ] && error_happened="1"
                [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff != 0 )) && error_happened="1"
                 if (( DEBUG )) ; then
                  Comment struct_testing:$LINENO $FUNCNAME[0] error_happened="${error_happened}"
                fi
                if [ "${error_happened}" ]  ||  ( has_error_keyword "${install_result}" ) ; then
                {
                  echo -e "${PURPLE_BLUE} action ${RED}failed ${YELLOW226}!!!  ${RESET}"
                  local REPLACERED="\\\\033[01;31m"
                  local REPLACECYAN="\\\\033[01;36m"
                  local display_install_result=$(echo -e "${install_result}" | sed "s/\(FAILED\|failed\|additional\ disk\|Failed\|ERROR\|Error\|error\|cannot\|continue\|logged\|inspection\|not\|exit\|more\|details\)/${REPLACERED}\1${REPLACECYAN}/g")

                  if (( DEBUG )) ; then
                    Comment "struct_testing:$LINENO $FUNCNAME[0] ${RED} ABOUT TO THROW failed${CYAN}() ${RESET}"
                  fi                  
                  failed "${RESET} \n .... \n ... ${display_install_result} \n ... \n ..."
                  [[ "${install_result}" == *"Could not resolve"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO INTERNET CONNECTION \o_0/ ${RESET}"
                  [[ "${install_result}" == *"Repository not found"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO ACCESS TO THIS FOR YOU ${RED} ${GIT_USER_NAME} ${RESET}"
                  [[ "${install_result}" == *"Could not read from"* ]] && echo -e "${BRIGHT_BLUE87} It appears it exists but you are ${RED}NOT ${YELLOW226} ALLOWED ${RED} ${GIT_USER_NAME} ${YELLOW226}!!! ${RESET}"
                  [[ "${install_result}" == *"additional disk"* ]] && echo -e "${BRIGHT_BLUE87} It appears .. ${RED}There is no space  ${YELLOW226}!!! !!!  ${RED}\\${BRIGHT_BLUE87}o${RED}_${BRIGHT_BLUE87}0${RED}/ ${RESET}"
                }
                fi

            }
            fi
            if (( DEBUG )) ; then
              Comment "struct_testing:$LINENO $FUNCNAME[0] ${GREEN} return ${CYAN}0 ${RESET}"
            fi  
            return 0
        }
        # end install_requirements

        function install_apt_get_requirements() {
            # Sample use
            #               local OS="${1}"
            #               install_apt_get_requirements "${OS}" "
            #                        build-essential
            #                        libreadline-dev
            #                        zlib1g-dev
            #                        flex
            #                        bison
            #                        libxml2-dev
            #                        libxslt-dev
            #                        libssl-dev
            #
            #                        libreadline6-dev
            #                        libossp-uuid-dev
            #                        uuid"
            #
            #

            # room for detecting Linux and OS systems
            local OS="${1}"
            local missing=""
            local one_required=""
            local required=$(grep -vE '^#'<<<$(grep -vE '^\s+#'<<<"${2}"))
            local packages=""
            local query=""
            for one_required in ${required}; do
            {
                # REF: https://www.cyberciti.biz/faq/find-out-if-package-is-installed-in-linux/
                packages=$(dpkg -l | egrep "$one_required" | cut -d' ' -f3 2>&1)
                query=$(dpkg-query -W -f='${Status} ${Version}\n' "$one_required"  2>&1)
                #if [[ "${query}" == "install ok"* ]] && ( is_included "$one_required" "${packages}" ); then
                if [[ "${query}" == "install ok"* ]] ; then
                {
                    passed " ${GREEN} $one_required ${YELLOW} INSTALLED${RESET} ."
                }
                else
                {
                    echo -e " ${RED}  NEED TO INSTALL ${YELLOW} $one_required${RESET} ${RED}...${query}"
                    missing="${missing} ${one_required}"
                }
                fi
            }
            done
            missing=$(echo ${missing} | sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g' ) # trim_start_space

            # Check Requirements OS Ubuntu 14.04 REF: https://wiki.postgresql.org/wiki/Compile_and_Install_from_source_code#Ubuntu
            [[ ! -z "${missing}" ]] && echo -e " ${CYAN} Installing missing packages: ${YELLOW} ${missing} ${RESET} ."
            local err_buff=0

            if [[ ! -z "${missing}" ]] ; then
            {
                local install_result=$(sudo apt-get install ${missing} -yfq   2>&1) # capture all input and output
                err_buff=$?
            }
            fi
            # echo $install_result;
            if [[ ! -z "${install_result}" ]] ; then #  && handle_error "${install_result}"
            {
                local error_happened=""
                [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff != 0 ] && error_happened="1"
                [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff != 0 )) && error_happened="1"
                if [ "${error_happened}" ]  ||  ( has_error_keyword "${install_result}" ) ; then
                {
                  echo -e "${PURPLE_BLUE} action ${RED}failed ${YELLOW226}!!!  ${RESET}"
                  [[ "${install_result}" == *"Could not resolve"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO INTERNET CONNECTION \o_0/ ${RESET}"
                  [[ "${install_result}" == *"Repository not found"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO ACCESS TO THIS FOR YOU ${RED} ${GIT_USER_NAME} ${RESET}"
                  [[ "${install_result}" == *"Could not read from"* ]] && echo -e "${BRIGHT_BLUE87} It appears it exists but you are ${RED}NOT ${YELLOW226} ALLOWED ${RED} ${GIT_USER_NAME} ${YELLOW226}!!! ${RESET}"
                  RED="\\033[01;31m"
                  CYAN="\\033[01;36m"
                  local display_install_result=$(echo "${install_result}" | sed "s/\(FAILED\|failed\|Failed\|ERROR\|Error\|error\|cannot\|continue\|logged\|inspection\|not\|exit\|more\|details\)/${RED}\1${CYAN}/g")
                  failed "${RESET} \n .... \n ... ${display_install_result} \n ... \n ..."
                }
                fi

            }
            fi
        }
        # end install_apt_get_requirements

        function install_apt_get_should_not_be_installed() {
            # Sample use
            #               local OS="${1}"
            #               install_apt_get_should_not_be_installed "${OS}" "
            #                        build-essential
            #                        libreadline-dev
            #                        zlib1g-dev
            #                        flex
            #                        bison
            #                        libxml2-dev
            #                        libxslt-dev
            #                        libssl-dev
            #
            #                        libreadline6-dev
            #                        libossp-uuid-dev
            #                        uuid"
            #
            #

            # room for detecting Linux and OS systems
            local OS="${1}"
            local removing=""
            local one_required=""
            local required=$(grep -vE '^#'<<<$(grep -vE '^\s+#'<<<"${2}"))
            for one_required in ${required}; do
            {
              if ( ( command -v apt >/dev/null 2>&1; ) && ( command -v dpkg >/dev/null 2>&1; ) ) ; then
              {
                dpkg -l | egrep "$one_required" &>/dev/null
                if [ $? == 0 ]; then
                {
                    echo -e " ${RED}  NEED TO REMOVE ${YELLOW} $one_required${RESET} ."
                    removing="${removing} ${one_required}"
                }
                else
                {
                    passed " ${GREEN} $one_required ${YELLOW} NOT PRESENT${RESET} ."
                }
                fi
              }
              elif ( ( command -v rpm >/dev/null 2>&1; ) && ( command -v dnf >/dev/null 2>&1; ) ) ; then
              {
                rpm -qa | egrep "$one_required" &>/dev/null
                if [ $? == 0 ]; then
                {
                    echo -e " ${RED}  NEED TO REMOVE ${YELLOW} $one_required${RESET} ."
                    removing="${removing} ${one_required}"
                }
                else
                {
                    passed " ${GREEN} $one_required ${YELLOW} NOT PRESENT${RESET} ."
                }
                fi

              }
              fi
            }
            done

            removing=$(echo ${removing} | sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g' ) # trim_start_space

            if ( ( command -v apt >/dev/null 2>&1; ) && ( command -v dpkg >/dev/null 2>&1; ) ) ; then
            {
              [[ -n "${removing}" ]] && echo -e " ${CYAN} Apt-get removing packages: ${YELLOW} ${removing} ${RESET} ."
              [[ -n "${removing}" ]] && local remove_result=$(sudo apt-get remove ${removing} -yfq   2>&1 && sudo apt-get purge ${removing} -yfq   2>&1 && sudo apt-get autoremove -yfq   2>&1) # capture all input and output
              local err_buff=$?
              [[ -n "${remove_result}" ]] && handle_error "${err_buff}" "${remove_result}"
            }
            elif ( ( command -v rpm >/dev/null 2>&1; ) && ( command -v dnf >/dev/null 2>&1; ) ) ; then
            {
              [[ -n "${removing}" ]] && echo -e " ${CYAN} Dnf removing packages: ${YELLOW} ${removing} ${RESET} ."
              [[ -n "${removing}" ]] && local remove_result=$(sudo dnf uninstall ${removing} -y   2>&1 && sudo dnf purge ${removing} -y  2>&1 && sudo dnf autoremove -y   2>&1) # capture all input and output
              local err_buff=$?
              [[ -n "${remove_result}" ]] && handle_error "${err_buff}" "${remove_result}"
            }
            fi
        }
        # end install_apt_get_should_not_be_installed
        #
        # C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --Start
        #
        function test_positives() {
            # Sample use
            #
            #
            #    local message_response=$(ls asdasdfas1234  2>&1 )  # Perform an action with error ,capture all output, error will return 1 to $?
            #    local err_buff=$?
            #    local ERROR_HAPPENED=""
            #    [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff != 0 ] && ERROR_HAPPENED="1"
            #    [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff != 0 )) && ERROR_HAPPENED="1"
            #    if [ "${ERROR_HAPPENED}" ] || \
            #        [[ "${message_response}" == *"error"* ]] || \
            #        [[ "${message_response}" == *"ERROR"* ]] || \
            #        [[ "${message_response}" == *"denied"* ]] \
            #    ; then
            #    {
            #        failed "There was an error- do something- show something ${message_response}"
            #    }
            #    fi
            #
            #    # Alternative:
            #    local err_buff=$?
            #    local ERROR_HAPPENED=""
            #    (  ( [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff != 0 ]  )  ||  (  [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff != 0 ))  )   )  && ERROR_HAPPENED="1"
            #    if [ "${ERROR_HAPPENED}" ] || \
            #        [[ "${message_response}" == *"error"* ]] || \
            #        [[ "${message_response}" == *"ERROR"* ]] || \
            #        [[ "${message_response}" == *"denied"* ]] \
            #    ; then
            #    {
            #        failed "There was an error- do something- show something ${message_response}"
            #    }
            #    fi

            KIND=""
            if ls werwerwerwerwerwerwerwerwerwerwerr >/dev/null 2>&1; then
              if (( $? == 0 )) ;  then  # Intel processor
                KIND="INTEL"
              fi
              if [ $? == 0 ]; then   # Mac Intel processor
                KIND="${KIND}MAC"
              fi
            else
              if (( $? == 0 )) ;  then  # Intel processor
                KIND="INTEL"
              fi
              if [ $? == 0 ]; then   # Mac Intel processor
                KIND="${KIND}MAC"
              fi
            fi
            # echo "clear_error_output" >/dev/null 2>&1;
            echo "${KIND}"
        }
        PROCESSOR_ERROR=$(test_positives)
        # DEBUG test_positives echo "${PROCESSOR_ERROR}"
        # DEBUG test_positives exit 1
        #
        # C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --End
        #

        function escape_spaces() {
            sed "s/ /\\\ /g"
        }
        function escape_single_quotes() {
            sed "s/'/\\\'/g"
        }
        function escape_double_quotes() {
            sed 's/\"/\\\"/g'
        }
        function escape_more_than() {
            sed s/""">"""/\\\>/g
        }
        function escape_less_than() {
            sed s/"""<"""/\\\</g
        }
        function escape_slashes() {
            sed 's/\//\\\//g'
        }
        function escape_bangs() {
            sed 's/\!/\\\!/g'
        }
        function escape_dots() {
            sed 's/\./\\\./g'
        }
        function escape_for_sed_sequence() {
            escape_double_quotes | \
            escape_less_than | escape_more_than | \
            escape_slashes  | escape_single_quotes | \
            escape_bangs | escape_dots
        }
        function remove_letters() {
          sed 's/[a-z-]\|[A-Z-]\|[ -]\|[(-)-]\|[, -]\|86_64//g'
        }
        function trim_start_space() {
            sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g'
        }
        function trim_end_space() {
            sed -e 's/[[:space:]]*$//' | sed 's/\ $//g' | sed 's/\t$//g'
        }
        function trim() {
            trim_start_space | trim_end_space
        }
        # duplicated at commit
        function get_longest_name_length() {
          # Sample usage:
          #               LONGEST_NAME=$(get_longest_name_length "${LIST_OF_FILENAMES_OR_STRINGS}")
          local ONE_CHANGED_FILES_WITH_STATUS
          local CHANGED_FILES_WITH_STATUS_WITH_TAB_CHANGED_TO_PIPE="${1}"
          local FILENAME_LENGTH=0
          local LONGEST_NAME=0

          #while read -r ONE_CHANGED_FILES_WITH_STATUS; do                                                  # Get longest file name
          while read -r ONE_CHANGED_FILES_WITH_STATUS; do
          {
            # if not empty
            if [[ -n "${ONE_CHANGED_FILES_WITH_STATUS}" ]] ; then
            {
              FILENAME_LENGTH="${#ONE_CHANGED_FILES_WITH_STATUS}"   # get string length
              (( FILENAME_LENGTH > LONGEST_NAME )) && LONGEST_NAME=$FILENAME_LENGTH
            }
            fi
            #echo "$(echo "$ONE_CHANGED_FILES_WITH_STATUS" | xargs -I {} echo "{}:1")"
          }
          done <<< "${CHANGED_FILES_WITH_STATUS_WITH_TAB_CHANGED_TO_PIPE}"
          #done <<< "${CHANGED_FILES_WITH_STATUS_WITH_TAB_CHANGED_TO_PIPE}"
          echo $LONGEST_NAME
        }
        # end get_longest_name_length
        # duplicated at commit
        function repeat_single_char_spacer() {
          # Sample usage:
          #               SPACER=$(repeat_single_char_spacer " " $CALCULATE_SPACER)
          #
          #
          # Complete Preparation:
          #
          #               LONGEST_NAME=$(get_longest_name_length "${LIST_OF_FILENAMES_OR_STRINGS}")
          #               FILENAME_LENGTH="${#FILENAME}"   # get string length
          #               CALCULATE_SPACER=$(( $LONGEST_NAME - $FILENAME_LENGTH ))
          #               SPACER=$(repeat_single_char_spacer " " $CALCULATE_SPACER)
          #               echo ${FILENAME}${SPACER}
          #
          local pad="${1}"
          local total=${2}
          [ ${total} -lt 1 ] && echo "${YELLOW} Warning ${FUNCNAME[*]}: ${CYAN} Expected number 'total' to be more than 0 and I got :${total}: value ${RESET}" && total=10
          [ -z "${pad}" ] && [ "${#pad}" -lt 1 ] && echo "${YELLOW} Warning ${FUNCNAME[*]}: ${CYAN} Expected padding 'pad' to be something and I got :${pad}: value ${RESET}" && pad=" "
          for ((x = 0; x < ${total}; x++)); do
            #echo "${1}"
            printf %s "${pad}"
          done
        }
        # end repeat_single_char_spacer

        function add_right_padding() {
          # Sample usage:
          #               add_right_padding "${ONE_VERSION}" ${LONGEST_NAME}  " "
          #
          local string="${1}"
          local longest=${2}
          local pad="${3}"
          local length="${#string}"   # get string length
          local calculate=$(( $longest - $length ))
          local padding=$(repeat_single_char_spacer "${pad}" ${calculate})
          echo "${string}${padding}"
        }
        # end add_right_padding

        function add_left_padding() {
          # Sample usage:
          #               add_left_padding " " ${LONGEST_NAME}   "${ONE_VERSION}"
          #
          local pad="${1}"
          local longest=${2}
          local string="${3}"
          local length="${#string}"   # get string length
          local calculate=$(( $longest - $length ))
          local padding=$(repeat_single_char_spacer ${pad} $calculate)
          echo "${padding}${string}"
        }
        # end add_left_padding

        function build_table_from_installed_components() {
            # Sample usage:
            #                build_table_from_installed_components "${USER_TO_INSTALL}"
            #                build_table_from_installed_components "${USER}"
            #
            local USER_TO_INSTALL="${1}"
            if [[ -z "${USER_TO_INSTALL}" ]] ; then
        {
              failed to provide USER. Call with build_table_from_installed_components \$USER or build_table_from_installed_components john or some username
        }
        fi
            local README_TABLE="INSTALLED_MACHINE=\"
 Service/Software | Version                        | Executable
------------------|--------------------------------|-------------------------------------------"
            local local_commands="
=, Instanced on     , date       , date
=, OS               , lsb_release, lsb_release -sd
=, Timezone         ,            , cat /etc/timezone
=, Processor        , uname      , uname -p
=, CPUS             , getconf    , getconf _NPROCESSORS_ONLN
=, LOCALE LANG      , locale     , locale | grep 'LANG=' | cut -d= -f2
=, LOCALE LC_ALL    , locale     , locale | grep 'LC_ALL=' | cut -d= -f2
x, Nginx            , nginx      , nginx -v
x, localtunnel.me   , lt         ,
x, NodeJS           , node       ,
x, NPM              , npm        ,
x, NVM              , nvm        ,
x, PhantomJS        , phantomjs  ,
x, Ruby             , ruby       ,
x, RVM              , rvm        ,
x, Puma             , puma       ,
x, Python           , python     ,
x, PyENV            , pyenv      ,
x, Mongo            , mongo      ,
x, Redis            , redis-cli  ,
x, PostgresQL       , psql       ,
x, Mysql 5          , mysql      ,  echo \"\${\$(mysql --version 2>&1)#*Distrib}\"
x, PHP 7            , php7.0     ,
x, PHP 7 Xdebug     , php7.0     ,  php7.0 --version | grep Xdebug
x, PHP 7 FPM        , php-fpm7.0 ,
x, PHP 7 FPM Xdebug , php-fpm7.0 ,  php-fpm7.0 --version | grep Xdebug
x, PHP 5            , php5.6     ,
x, PHP 5 Xdebug     , php5.6     ,  php5.6 --version | grep Xdebug
x, PHP 5 FPM        , php-fpm5.6 ,
x, PHP 5 FPM Xdebug , php-fpm5.6 ,  php-fpm5.6 --version | grep Xdebug
x, WP CLI           , wp         ,
x, FRENO            , freno      ,
x, sent             , sentimineo ,
"
            local IFS
            local FILTER_THIS
            local ONE_TITLE
            local ONE_COMMAND
            local ONE_TEST
            local ONE_VERSION
            local ONE_WHICH
            local MIDDLE__LONGEST=$(get_longest_name_length "$(date)")
            local VERSION_EXTRACT_COMMAND
            (( MIDDLE__LONGEST ++ ))
            (( MIDDLE__LONGEST ++ ))
            local TABLE_VERSION_LENGTH
            local GOODIES="
echo \" \"
echo -e \"


"
            while read -r one_line; do
            {
              if [[ -n "${one_line}" ]] ; then
              {
                IFS=\, read FILTER_THIS ONE_TITLE ONE_COMMAND ONE_TEST<<EOF
${one_line}
EOF
    echo "sudo -u ${USER_TO_INSTALL} -i -- command -v ${ONE_COMMAND}"
                if ( is_installed ${ONE_COMMAND} ) ; then
                {
                    echo "yup"
                  [ -z "${ONE_TEST}" ] && ONE_TEST="command ${ONE_COMMAND} --version"
                  ONE_VERSION=""
                  [[ "${FILTER_THIS}" == "x" ]] && ONE_VERSION=$(sudo -u ${USER_TO_INSTALL}  -i -- eval """${ONE_TEST}""" 2>&1 | extract_version  |  remove_letters | head -1)
                  [[ "${FILTER_THIS}" == "=" ]] && ONE_VERSION=$(sudo -u ${USER_TO_INSTALL}  -i -- eval """${ONE_TEST}""" 2>&1 | head -1 )
                  ONE_WHICH=""
                  [[ "${FILTER_THIS}" != "=" ]] && ONE_WHICH="$(sudo -u ${USER_TO_INSTALL} -i -- which ${ONE_COMMAND} 2>&1 | head -1 )"
                  ONE_VERSION=$(add_right_padding  "${ONE_VERSION}" ${MIDDLE__LONGEST} " ")
                  README_TABLE="${README_TABLE}
${ONE_TITLE}| ${ONE_VERSION} | ${ONE_WHICH}"

                  [[ -n "${ONE_WHICH}" ]] && ONE_WHICH="${GREEN}\t\t:${GRAYEDOUT}${ONE_WHICH}"
                  VERSION_EXTRACT_COMMAND="${RED}${ONE_TITLE}${GREEN}:${CYAN}${ONE_VERSION}${ONE_WHICH}"
                  GOODIES="${GOODIES}
${VERSION_EXTRACT_COMMAND}"
                }
                else
                {
                    echo "nop"
                     sudo -u "${USER_TO_INSTALL}" -i -- echo "command was ${ONE_COMMAND}"

                }
                fi
              }
              fi
            }
            done <<< "${local_commands}"

            README_TABLE="${README_TABLE}
\""


            GOODIES="${GOODIES}
\"
echo \" \"
echo \" \"
${README_TABLE}

# bash completion for the wp command

_wp_complete() {
  local OLD_IFS=\"\$IFS\"
  local cur=\${COMP_WORDS[COMP_CWORD]}

  IFS=\$'\n';  # want to preserve spaces at the end
  local opts=\"\$(wp cli completions --line=\"\$COMP_LINE\" --point=\"\$COMP_POINT\")\"

  if [[ \"\$opts\" =~ \<file\>\s* ]]
  then
    COMPREPLY=( \$(compgen -f -- \$cur) )
  elif [[ \$opts = \"\" ]]
  then
    COMPREPLY=( \$(compgen -f -- \$cur) )
  else
    COMPREPLY=( \${opts[*]} )
  fi

  IFS=\"\$OLD_IFS\"
  return 0
}
complete -o nospace -F _wp_complete wp

"
            echo "${GOODIES}"
}
# end build_table_from_installed_components

        function switch_spaces_to_newlines() {
            sed 's/ /\n/g'
        } # end switch_spaces_to_newlines
        function switch_spaces_to_underscores() {
            sed 's/ /_/g'
        } # end switch_spaces_to_underscores
        function make_itarable() {
            sed 's/ /\n/g' | trim | enter_encode | sed 's/0N33NT3R/ \r\n/g'
        }
        # end make_itarable

        function chown_it() {
            # Sample use
            #            chown_it "${USER_TO_INSTALL}" /usr/local/rvm
            #            chown_it "${USER_TO_INSTALL}" /usr/local/rvm /usr/local/.nvm /usr/local/.nvm  /usr/local/rvm  /root/.temp
            local USER_TO_INSTALL="${1}"
            local paths=$(switch_spaces_to_newlines <<< "${2}")
            local actions="
                [ -e \"{#}\" ] && chown -R \"${USER_TO_INSTALL}\":\"${USER_TO_INSTALL}\" \"{#}\"
            "
             while read -r one_item; do
            {
                if [[ -n "${one_item}" ]] ; then  # if not empty
                {
                    if [ ! -e "${one_item}" ] ; then
                    {
                        echo -e "${RED}WARNING: chown_it() ${YELLOW}FILE DOES NOT Exist: ${one_item}"
                    }
                    else
                    {
                        chown -R "${USER_TO_INSTALL}" "${one_item}"
                        if [ $? -gt 0 ] ; then
                        {
                            echo "${RED}ERROR: chown_it() ${YELLOW}Error executing: chown -R \"${USER_TO_INSTALL}\" \"${one_item}\""
                        }
                        fi
                    }
                    fi

                }
                fi
            }
            done <<< "${paths}"
        }
        # end chown_it

        function chmod_it() {
            # Sample use
            #            chmod_it 644 /usr/local/rvm
            #            chmod_it "${chmodmod}" /usr/local/rvm /usr/local/.nvm /usr/local/.nvm  /usr/local/rvm  /root/.temp
            local chmodmod="${1}"
            local paths=$(switch_spaces_to_newlines <<< "${2}")
            local actions="
                [ -e \"{#}\" ] && chmod \"${chmodmod}\" \"{#}\"
            "
            while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                    if [ ! -e "${one_item}" ] ; then
                    {
                        echo -e "${RED}WARNING: chmod_it() ${YELLOW}FILE DOES NOT Exist: ${one_item}"
                    }
                    else
                    {
                        chmod "${chmodmod}" "${one_item}"
                        if [ $? -gt 0 ] ; then
                        {
                            echo "${RED}ERROR: chmod_it() ${YELLOW}Error executing: chmod \"${chmodmod}\" \"${one_item}\""
                        }
                        fi
                    }
                    fi

                }
                fi
            }
            done <<< "${paths}"

        } # end chmod_it

        function link_it() {
            # Sample use
            #            link_it "${USER_TO_INSTALL}" /usr/local/bin/python  /home/${USER_TO_INSTALL}/.pyenv/shims/python
            local USER_TO_INSTALL="${1}"
            local from="${2}"
            local to="${3}"
            [ ! -e "${to}" ] && failed "Trying to link_it ln -sf \"${to}\"      \"${from}\" but target :${to}: does not exist"
            ln -sf "${to}"    "${from}"
            #[ -e "${to}" ] && chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "${to}"
            [ -e "${to}" ] && chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "${to}"
        } # end link_it

        function remove_it() {
            # Sample use
            #            remove_it  /usr/local/rvm
            #            remove_it  /usr/local/rvm /usr/local/.nvm  /usr/local/rvm  /root/.temp
            local paths=$(switch_spaces_to_newlines <<< "${@}")
            local actions="
                [ -e \"{#}\" ] && rm -rf \"{#}\"
                [ -L \"{#}\" ] && unlink \"{#}\"
            "
            .each  "${actions}"   "${paths}"
        } # end remove_it

        function _term() {
            # Sample usage
            # REF: http://man7.org/linux/man-pages/man7/signal.7.html
            # REF: https://unix.stackexchange.com/questions/146756/forward-sigterm-to-child-in-bash
            #        trap _term SIGTERM

            #         echo "Doing some initial work...";
            #         /bin/start/main/server --nodaemon &

            #         child=$!
            #         wait "$child"
            echo "Caught SIGTERM signal!"
            kill -TERM "$child" 2>/dev/null
        } # end _term

        function .each() {
            # Sample use
            #           Prepare .each
            #           ITEMS=$(find . -maxdepth 0 -type d | egrep -v "\.git")
            #           Each ITEM will be executed in {#} \/ ----------\/
            #           ACTIONS="echo \"Showing list for {#}\"  ls -la {#} "
            #
            #                    Perform all actions in
            #                           ACTIONS
            #                             for each ITEM in       as {#}
            #                                              ITEMS
            #           Note ESCape all !, ", $ with \ like \!, \", \$
            #           Call .each
            #           .each  "${ACTIONS}"   "${ITEMS}"
            local local_actions="${1}"
            local local_items="${2}"
            local one_item
            local one_action
            local action
            local child
            local ret
            while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                      while read -r one_action; do
                      {
                            if [ ! -z "${one_action}" ] ; then  # if not empty
                            {
                                  # replace value inside string substitution expresion bash
                                  trap _term SIGTERM
                                  action="${one_action/\{\#\}/${one_item}}"
                                  action="${action/\{\#\}/${one_item}}"
                                  action="${action/\{\#\}/${one_item}}"
                                  eval """${action}"""
                                  ret=$?
                                  if [ $ret -gt 0 ] ; then
                                  {
                                    child=$!
                                    wait $child
                                    warning "${YELLOW}Error SIGNAL_RETURN(${RED}${ret}${YELLOW}) executing: \n${action}"
                                  }
                                  fi
                            }
                            fi
                      }
                      done <<< "${local_actions}"
                }
                fi
            }
            done <<< "${local_items}"
        } # end .each

        function .mix_with() {
            # Sample use
            #           ITEMS="1
            #                  2
            #                  3
            #                  4
            #                  5
            #                  "
            #           Each ITEM will be executed in {#} \/ ----------\/
            #           LIST2="echo \"Showing list for {#}\"  ls -la {#} "
            #
            #          Mixes as items in
            #                           ITEMS
            #                             for each element in
            #                                              ELEMENTS
            #           Note ESCape all ", $ with \ like \", \$
            #           Call .mix_with
            #           .mix_with "\\n"  "${ELEMENTS}"   "${ITEMS}"
            local glue="${1}"
            local local_actions="${2}"
            local local_items="${3}"
            local one_item
            local one_action
            local action

            while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                      while read -r one_action; do
                      {
                            if [ ! -z "${one_action}" ] ; then  # if not empty
                            {
                                  echo """${one_action}${glue}${one_item}"""
                            }
                            fi
                      }
                      done <<< "${local_actions}"
                }
                fi
            }
            done <<< "${local_items}"
        } # end .mix_with
enter_last_only_removed() {
  #sed ':a;N;$!ba;s/\n$//g' # GNU sed
  sed -e ':a' -e 'N' -e '$!ba' -e 's/\n$//g'  #  cross-platform compatible syntax which works with BSD sed
}

        # enter_last_only_removed() {
        #  sed ':a;N;$!ba;s/\n$//g' # GNU sed
        function trim_end_newlines() {
            sed -e ':a' -e 'N' -e '$!ba' -e 's/\n$//g'  #  cross-platform compatible syntax which works with BSD sed
        }
        # end trim_end_newlines
        # }

          #sed ':a;N;$!ba;s/\n/0N33NT3R/g'  # GNU sed
        function enter_encode() {
          sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/0N33NT3R/g'  #  cross-platform compatible syntax which works with BSD sed
        }
        # end enter_encode

        function enter_decode() {
          sed 's/0N33NT3R/\n/g'
        }
        # end enter_decode

            # Sample use
            #            test1="asdf xcvb qwe sdfs "
            #            test2="asdf\nasdf\nasdf"
            #            ( ! contains_newlines "${test1}" ) && echo "no newlines"
            #            ( contains_newlines "${test2}" ) && echo "newlines"
            #            if ! contains_newlines "${test1}" ; then
            #            if contains_newlines "${test2}" ; then
            # ' Here I changed \n to 0N33NT3R' why? - For a weird reasons when assigning a var " " it adds \n to the  end of it so t="a" is actually t="a\n"
        function contains_newlines() {
            # echo "${@}" | enter_encode
            local trimmed_testing=$(echo "${@}" | enter_encode)
            if [[ "${trimmed_testing}" == *"0N33NT3R"* ]] ; then
            {
              return 0 # true contains enters
            }
            fi
            return 1 # false no newlines
        }
        # end contains_newlines
        alias has_newlines=contains_newlines

            # Sample use
            #           you have:       /root/.folder
            #           and you want:  to move from  __root__     to     /home/${USER_TO_INSTALL}
            #           and link it back
            #           and you want:   /root/.folder  --->  /home/${USER_TO_INSTALL}/.folder
            #
            #            sudo mkdir /root/.test
            #            sudo out_of_root_folder_and_soft_link_back docker .test
            #            sudo out_of_root_folder_and_soft_link_back vagrant .test
            #            sudo out_of_root_folder_and_soft_link_back "${USER_TO_INSTALL}" .bundle
            #            sudo out_of_root_folder_and_soft_link_back "${USER_TO_INSTALL}" .bundle .gem .gems
        function out_of_root_folder_and_soft_link_back() {
            local USER_TO_INSTALL="${1}"
            if ( contains_newlines "${@}" ); then
            {
                local targets="${@}"
            }
            else
            {
                local targets=$(echo "${@}" | switch_spaces_to_newlines)
            }
            fi
            echo "${targets}"
            local actions="
                [ -d \"/home/${USER_TO_INSTALL}/{#}/\" ] &&  rm -rf \"/home/${USER_TO_INSTALL}/{#}/\"
                [ -d \"/root/{#}/\" ] &&  mv \"/root/{#}\" \"/home/${USER_TO_INSTALL}/\"
                [ -d \"/home/${USER_TO_INSTALL}/{#}/\" ] &&  ln -sf  \"/home/${USER_TO_INSTALL}/{#}\" \"/root/{#}\"
                [ -d \"/home/${USER_TO_INSTALL}/{#}/\" ] &&  chown -R \"${USER_TO_INSTALL}\":\"${USER_TO_INSTALL}\" \"/home/${USER_TO_INSTALL}/{#}/\"
            "
            .each  "${actions}"   "${targets}"
        }
        # end out_of_root_folder_and_soft_link_back

            # Sample use
            #            out_of_root_file_and_soft_link_back "${USER_TO_INSTALL}" .bundle
            #            out_of_root_file_and_soft_link_back "${USER_TO_INSTALL}" .bundle .gem .gems
        function out_of_root_file_and_soft_link_back() {
            local USER_TO_INSTALL="${1}"
            if contains_newlines "${@}" ; then
            {
                local targets="${@}"
            }
            else
            {
                local targets=$(echo "${@}" | switch_spaces_to_newlines)
            }
            fi
            local actions="
                [ -f \"/home/${USER_TO_INSTALL}/{#}\" ] &&  rm -rf \"/home/${USER_TO_INSTALL}/{#}\"
                [ -f \"/root/{#}\" ] &&  mv \"/root/{#}\" \"/home/${USER_TO_INSTALL}\"
                [ -f \"/home/${USER_TO_INSTALL}/{#}\" ] &&  ln -sf  \"/home/${USER_TO_INSTALL}/{#}\" \"/root/{#}\"
                [ -f \"/home/${USER_TO_INSTALL}/{#}\" ] &&  chown -R \"${USER_TO_INSTALL}\":\"${USER_TO_INSTALL}\" \"/home/${USER_TO_INSTALL}/{#}\"
            "
            .each  "${actions}"   "${targets}"
        }
        # end out_of_root_file_and_soft_link_back

        function move_to_user_folder_and_soft_link_root_to_it() {
            local USER_TO_INSTALL="${1}"
            local target="${2}"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] &&  rm -rf "/home/${USER_TO_INSTALL}/${target}/"
            [ -d "/root/${target}/" ] &&  mv "/root/${target}" "/home/${USER_TO_INSTALL}/"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] &&  ln -sf  "/home/${USER_TO_INSTALL}/${target}" "/root/${target}"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] &&  chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/home/${USER_TO_INSTALL}/${target}/"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] &&  chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/root/${target}"
        }
        alias move_folder_out_root_to_user_and_link_it_back=move_to_user_folder_and_soft_link_root_to_it

        function move_to_user_file_and_soft_link_root_to_it() {
            local USER_TO_INSTALL="${1}"
            local target="${2}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] &&  rm -rf "/home/${USER_TO_INSTALL}/${target}"
            [ -f "/root/${target}" ] &&  mv "/root/${target}" "/home/${USER_TO_INSTALL}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] &&  ln -sf  "/home/${USER_TO_INSTALL}/${target}" "/root/${target}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] &&  chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/home/${USER_TO_INSTALL}/${target}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] &&  chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/root/${target}"
        }
        alias move_file_out_root_to_user_and_link_it_back=move_to_user_file_and_soft_link_root_to_it

##############           ##############             ####      ####           ##############               ############             ##############             ####      ####
##############           ##############             ####      ####           ##############               ############             ##############             ####      ####
    ######               ####        ####             ####  ####             ####        ####           ####        ####           ####        ####             ####  ####
    ######               ####        ####             ####  ####             ####        ####           ####        ####           ####        ####             ####  ####
    ######               ####        ####               ######               ##############             ####        ####           ####        ####               ######
    ######               ####        ####               ######               ##############             ####        ####           ####        ####               ######
    ######               ##############                 ######               ####        ####           ####        ####           ####        ####               ######
    ######               ##############                 ######               ####        ####           ####        ####           ####        ####               ######
    ######               ####      ####                 ######               ####        ####           ####        ####           ####        ####               ######
    ######               ####      ####                 ######               ####        ####           ####        ####           ####        ####               ######
    ######               ####        ####               ######               ##############               ############             ##############                 ######
    ######               ####        ####               ######               ##############               ############             ##############                 ######


# SUDO_USER only exists during execution of sudo
# REF: https://stackoverflow.com/questions/7358611/get-users-home-directory-when-they-run-a-script-as-root
# Global:
# THISSCRIPTNAME=`basename "$0"`

# function execute_as_sudo(){
#     # Sample use:
#     # being of script add
#     # THISSCRIPTNAME=`basename "$0"`
#     # ...
#     # execute_as_sudo
#     # USER_HOME=$(getent passwd $SUDO_USER | cut -d: -f6)
#     # passed Caller user identified:$USER_HOME
#     #
#   if [ -z $SUDO_USER ] ; then
#     if [[ -z "$THISSCRIPTNAME" ]] ; then
#     {
#         echo "error You need to add THISSCRIPTNAME variable like this:"
#         echo "     THISSCRIPTNAME=\`basename \"\$0\"\`"
#     }
#     else
#     {
#         if [ -e "./$THISSCRIPTNAME" ] ; then
#         {
#           sudo "./$THISSCRIPTNAME"
#         }
#         elif ( command -v "$THISSCRIPTNAME" >/dev/null 2>&1 );  then
#         {
#           echo "sudo sudo sudo "
#           sudo "$THISSCRIPTNAME"
#         }
#         else
#         {
#           echo -e "\033[05;7m*** Failed to find script to recall it as sudo ...\033[0m"
#           exit 1
#         }
#         fi
#     }
#     fi
#     wait
#     exit 0
#   fi
#   # REF: http://superuser.com/questions/93385/run-part-of-a-bash-script-as-a-different-user
#   # REF: http://superuser.com/questions/195781/sudo-is-there-a-command-to-check-if-i-have-sudo-and-or-how-much-time-is-left
#   local CAN_I_RUN_SUDO=$(sudo -n uptime 2>&1|grep "load"|wc -l)
#   if [ ${CAN_I_RUN_SUDO} -gt 0 ]; then
#     echo -e "\033[01;7m*** Installing as sudo...\033[0m"
#   else
#     echo "Needs to run as sudo ... ${0}"
#   fi
# } # end execute_as_sudo
function _find_downloads_folder(){
  # Sample Use
  #
  #      local DOWNLOADFOLDER="$(_find_downloads_folder)"
  #      enforce_variable_with_value DOWNLOADFOLDER "${DOWNLOADFOLDER}"
  #      cd "${DOWNLOADFOLDER}"
  #      _download_mac "${TARGET_URL}" "${DOWNLOADFOLDER}"
  #
  local DOWNLOADFOLDER=""
  local -i _err=0
  # first try typical assignation
  # check operation systems
  if [[ "$(uname)" == "Darwin" ]] ; then
    # Do something under Mac OS X platform
    DOWNLOADFOLDER=/Users/"${SUDO_USER}"/Downloads
  elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]] ; then
    # Do something under GNU/Linux platform
    DOWNLOADFOLDER=/home/"${SUDO_USER}"/Downloads
  elif [[ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" ]] ; then
    # Do something under Windows NT platform
    DOWNLOADFOLDER=/C/Users/"${SUDO_USER}"/Downloads
    # nothing here
  fi
  if [ -n "${DOWNLOADFOLDER}" ] ; then
  {
    if it_exists_with_spaces "${DOWNLOADFOLDER}" ; then
    {
      cd "${DOWNLOADFOLDER}"
      echo -n "${DOWNLOADFOLDER}"
      return 0
    }
    fi
  }
  fi


  if ( command -v xdg-user-dir >/dev/null 2>&1; ) ; then
  {
    enforce_variable_with_value SUDO_USER "${SUDO_USER}"
    local DOWNLOADFOLDER="$(su - "${SUDO_USER}" -c 'xdg-user-dir DOWNLOAD')"
    _err=$?
    # this could have failed live above, because of login problems or broken user, or lack of rights, etc
    # so try again with normal call
    if [ -z "${DOWNLOADFOLDER}" ] || [ ${_err} -gt 0 ] ; then
    {
      # getting /root/Downloads ?
      DOWNLOADFOLDER="$(xdg-user-dir DOWNLOAD)"
      _err=$?
    }
    fi
    # check again for value in case that fails also
    #  if so, then create with mkdir process, I assume this will always work, #nevermakeassumptions btw
    if [ -z "${DOWNLOADFOLDER}" ] || [ ${_err} -gt 0 ] ; then
    {
      DOWNLOADFOLDER="$(mktemp -d 2>/dev/null || mktemp -d -t 'tempdownloads')"
      _err=$?
    }
    fi
    # check empty of error
    if [ -z "${DOWNLOADFOLDER}" ] || [ ${_err} -gt 0 ] ; then
    {
      return 1  # here one is for error
      exit 1
    }
    fi
    # finally check we got a value
    enforce_variable_with_value DOWNLOADFOLDER "${DOWNLOADFOLDER}"
    cd "${DOWNLOADFOLDER}"
    echo -n "${DOWNLOADFOLDER}"
  }
  else
  {
    local _temp_dir="$(mktemp -d 2>/dev/null || mktemp -d -t 'tempdownloads')"
    cd "${_temp_dir}"
    echo -n "${_temp_dir}"
   }
  fi
  return 0
} # end _find_downloads_folder

function _download_win() {
   curl -O "${*}"
} # end _download_win

function progressfilt() {
    # REF https://stackoverflow.com/questions/4686464/how-to-show-wget-progress-bar-only
    # Usage Usage:
    # $ wget --progress=bar:force http://somesite.com/TheFile.jpeg 2>&1 | progressfilt
    # 100%[======================================>] 15,790      48.8K/s   in 0.3s
    # 2011-01-13 22:09:59 (48.8 KB/s) - 'TheFile.jpeg' saved [15790/15790]
    local _err=$?
    if [ ${_err} -ne 0 ] ; then
    {
       echo "$0:progressfilt: error: ${_err} cannot continue"
       return ${_err}
       exit ${_err}
    }
    fi
    local flag=false c count cr=$'\r' nl=$'\n'

    while IFS='' read -d '' -rn 1 c; do
    {
        if $flag;  then
        {
            printf '%s' "$c"
        }
        else
        {
            if [[ $c != $cr && $c != $nl ]];   then
            {
              count=0
            }
            else
            {
                (( count++ ))
                if (( count > 1 )) ;               then
                {
                 flag=true
                }
                fi
            }
            fi
        }
        fi
    }
    done
} # end progressfilt

function _download_mac() {
  # Sample use
  #
  #       _download_mac "${URL}" "${USER_HOME}/Downloads"
  #
  local target_url="${1}"
  local download_folder=""
  if [ -n "${2}" ] ; then # if not empty
  {
    download_folder="${2}"
  }
  fi
  echo "     target url 1:<${target_url}>"
  [ -z "${target_url}" ] && echo "empty"
  echo "download folder 2:<${download_folder}>"
  [ -z "${target_url}" ] && echo "empty"
  echo "  download file 3:<${3}>"
  #   file_exists_with_spaces "${download_folder}"
  directory_exists_with_spaces "${download_folder}"
  cd "${download_folder}"
  #   [ -z "${3}" ] && echo "empty"
  #   echo
  # echo "# arguments called with ---->  ${@}     "
  # echo "# \$1 ---------------------->  $1       "
  # echo "# \$2 ---------------------->  $2       "
  # echo "# path to me --------------->  ${0}     "
  # echo "# parent path -------------->  ${0%/*}  "
  # printf '$0 is: %s\n$BASH_SOURCE is: %s\n' "$0" "$BASH_SOURCE"
  # echo "# my name ------------------>  ${0##*/} "
  # echo
  [ -z "${1}" ] && failed "\\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 1.target_url string or it was empty. Expected one Parameter 1:<> URL <target url>"
  [ -z "${2}" ] && failed "\\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 2.download_folder string or it was empty. Expected one Parameter 2:<> <download folder>"
  if enforce_web_is_reachable $(echo "${target_url}") && [ $? -gt 0 ] ;  then # if not empty
  {
    failed \\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 1.target_url URL is Broken or not Reachable "<<${target_url}>>"
  }
  fi
  # -c Resume Downloads  -c option only works with FTP / HTTP servers that support the “range” header
  if ( command -v curl >/dev/null 2>&1; ); then
  {
    pwd
    # _try
    echo "curl -LO  -k -s --url  \"${target_url}\" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable"
set -ex
    # curl -LO  -k -s --url  "${target_url}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
    curl -kLO "${target_url}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
      echo $?
      ls -la
set +ex
    wait
  }
  elif ( command -v wget >/dev/null 2>&1; ) ; then
  {
    # REF: https://www.linuxquestions.org/questions/linux-general-1/how-to-create-a-bash-script-to-wait-for-wget-to-finish-and-then-continue-621754/
    for url in $(echo "${download_folder}"); do
    {
      # _try wget -c --directory-prefix=\"${USER_HOME}/Downloads/\"  --quiet --no-check-certificate "${download_folder}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
      echo "wget -c --progress=bar:force --directory-prefix=\"${download_folder}\" --no-check-certificate \"${target_url}\" 2>&1 | progressfilt"
set -ex
      wget -c --progress=bar:force --directory-prefix="${download_folder}" --no-check-certificate "${target_url}" 2>&1 | progressfilt
      echo $?
      ls -la
set +ex
      # wget -c --directory-prefix=\"${USER_HOME}/Downloads/\"  --quiet --no-check-certificate "${download_folder}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
    }
    done
  }
  else
  {
    failed "I cannot find wget or curl to download! ${target_url}"
  }
  fi
} # end _download_mac

function _download() {
    # check operation systems
    if [[ "$(uname)" == "Darwin" ]] ; then
    # Do something under Mac OS X platform
      _download_mac "${@}"
    elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]] ; then
    # Do something under GNU/Linux platform
      _download_linux "${@}"
    elif [[ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" ]] ; then
    # Do something under Windows NT platform
      _download_win "${*}"
    # nothing here
    fi
} # end _download

function _download_linux() {


  # You're close. The correct way to approach this is using the HEAD method.

  # With cURL:

  # if curl --head --silent --fail ftp://ftp.somewhere.com/bigfile.gz 2> /dev/null;
  #  then
  #   echo "This page exists."
  #  else
  #   echo "This page does not exist."
  # fi

  # or using wget:

  # if wget -q --method=HEAD ftp://ftp.somewhere.com/bigfile.gz;
  #  then
  #   echo "This page exists."
  #  else
  #   echo "This page does not exist."
  # fi


  local thisscriptname=$(dirname "struct_testing")
  _trap_try_start
  local target_url="${1}"
  local download_folder=""
  if [ -n "${2}" ] ; then # if not empty
  {
      download_folder="${2}"
  }
  fi
  echo "     target url 1:<${1}>"
  [ -z "${1}" ] && echo "empty"
  echo "download folder 2:<${download_folder}>"
  [ -z "${2}" ] && echo "empty"
  echo "  download file 3:<${3}>"
  #   file_exists_with_spaces "${download_folder}"
  directory_exists_with_spaces "${download_folder}"
    #   [ -z "${3}" ] && echo "empty"
    #   echo
    # echo "# arguments called with ---->  ${@}     "
    # echo "# \$1 ---------------------->  $1       "
    # echo "# \$2 ---------------------->  $2       "
    # echo "# path to me --------------->  ${0}     "
    # echo "# parent path -------------->  ${0%/*}  "
    # printf '$0 is: %s\n$BASH_SOURCE is: %s\n' "$0" "$BASH_SOURCE"
    # echo "# my name ------------------>  ${0##*/} "
    # echo
  [ -z "${1}" ] && failed "\\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 1.target_url string or it was empty. Expected one Parameter 1:<> URL <target url>"
  [ -z "${2}" ] && failed "\\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 2.download_folder string or it was empty. Expected one Parameter 2:<> <download folder>"
  [ -z "${3}" ] && failed "\\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 3.download_file string or it was empty. Expected one Parameter 3:<> <download file>"
  if enforce_web_is_reachable "${1}" && [ $? -gt 0 ] ;  then # if not empty
  {
    failed \\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 1.target_url URL is Broken or not Reachable "<<${1}>>"
  }
  fi


  local download_file="${3}" || ""

  _trap_catch_check
  # wget --directory-prefix="${USER_HOME}/Downloads/" --quiet --no-check-certificate "${target_url}" 2>/dev/null
  echo -e "\033[01;7m*** Downloading file to temp location...\033[0m"

  if ( command -v wget >/dev/null 2>&1; ) ; then
    ensure wget or "Wget is required"
    # # REF: about :> http://unix.stackexchange.com/questions/37507/what-does-do-here
    _trap_try_start
    local _temp_dir="$(mktemp -d 2>/dev/null || mktemp -d -t '_download_linux')"
    :> ${_temp_dir}/wgetrc   # here :> equals to Equivalent to the following: cat /dev/null > wgetrc which Nulls out the file called "wgetrc" in the current directory. As in creates an empty file "wgetrc" if one doesn't exist or overwrites one with nothing if it does.
    _trap_catch_check
    file_exists_with_spaces ${_temp_dir}/wgetrc
    _trap_try_start
    echo "noclobber=off" >> ${_temp_dir}/wgetrc
    _trap_catch_check
    echo "dirstruct=off" >> ${_temp_dir}/wgetrc
    # echo "verbose=off" >> ${_temp_dir}/wgetrc     # NOTE Can't be verbose and quiet at the same time.--quiet
    echo "verbose=on" >> ${_temp_dir}/wgetrc     # NOTE Can't be verbose and quiet at the same time.--quiet
    echo "progress=bar:default" >> ${_temp_dir}/wgetrc
    echo "tries=3" >> ${_temp_dir}/wgetrc
    echo "max-redirect=10" >> ${_temp_dir}/wgetrc
    echo "check_certificate=off" >> ${_temp_dir}/wgetrc
    echo "mirror=on" >> ${_temp_dir}/wgetrc
    echo "content_disposition=on" >> ${_temp_dir}/wgetrc
    echo "dir_prefix=." >> ${_temp_dir}/wgetrc
    # echo "dir_prefix=${download_folder}" >> ${_temp_dir}/wgetrc
    echo "directory-prefix=${download_folder}" >> ${_temp_dir}/wgetrc
    # echo "output-document=${download_file}" >> ${_temp_dir}/wgetrc    # Set the output filename--the same as '-O FILE'.
    # echo "input=${target_url}" >> ${_temp_dir}/wgetrc    #  Read the URLs from STRING, like '-i FILE'.
    # _trap_try_start # _trap_catch_check
    # WGETRC=wgetrc wget --directory-prefix="${USER_HOME}/Downloads/" --quiet --no-check-certificate "${target_url}" 2>/dev/null
    #  _trap_catch_check
    # WGETRC=${_temp_dir}/wgetrc  wget --quiet --no-check-certificate "${target_url}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
    # _try "WGETRC=${_temp_dir}/wgetrc  wget --mirror --directory-prefix=\"${download_folder}\" --quiet --no-check-certificate \"${target_url}\"" # 2>/dev/null"
    _trap_try_start # _trap_catch_check
    WGETRC=${_temp_dir}/wgetrc
    # WGETRC=${_temp_dir}/wgetrc  wget --max-redirect=10 --mirror --directory-prefix="${download_folder}" --no-check-certificate "${target_url}" # 2>/dev/null"
    # WGETRC=${_temp_dir}/wgetrc  wget --mirror --content-disposition "${download_folder}" "${download_file}" --no-check-certificate "${target_url}" # 2>/dev/null"
    local WGETCOMMAND=""
    echo "WGET:"
    echo "OPTIONS WGETRC:"
    cat -n ${_temp_dir}/wgetrc
    echo "COMMAND WGET:"
    passed "WGETRC=${_temp_dir}/wgetrc  wget --max-redirect=10 --mirror --directory-prefix=${download_folder} -O ${download_file} --no-check-certificate ${target_url}"
    cd "${download_folder}"
    pwd
    # exit 0
    # if not defined and not empty try code normal
    if ( ! typeset -p "SUDO_USER"  &>/dev/null ) ; then
    {
       cd "${download_folder}"
       _trap_try_start
       wget --max-redirect=10 --mirror --directory-prefix="${download_folder}" -O "${download_file}" --no-check-certificate "${target_url}" # 2>/dev/null"
       _trap_catch_check
    }
    elif  ( typeset -p "SUDO_USER"  &>/dev/null ) ; then
    {
      _trap_try_start
      echo -e RUNNING:\nsu - "$SUDO_USER" -c 'cd "'"${download_folder}"'" && wget --max-redirect=10 --mirror --directory-prefix="'"${download_folder}"'" -O "'"${download_file}"'" --no-check-certificate '"${target_url}"' && pwd ' # 2>/dev/null"
      su - "$SUDO_USER" -c 'cd "'"${download_folder}"'" && wget --max-redirect=10 --mirror --directory-prefix="'"${download_folder}"'" -O "'"${download_file}"'" --no-check-certificate '"${target_url}"' && pwd ' # 2>/dev/null"
      _trap_catch_check
    }
    fi
    # ( typeset -p "SUDO_USER"  &>/dev/null ) ||  wget --max-redirect=10 --mirror  --no-check-certificate "${target_url}" # 2>/dev/null"
    # if defined and not empty
    # ( typeset -p "SUDO_USER"  &>/dev/null ) && echo "sudo user " >&2
    # ( typeset -p "SUDO_USER"  &>/dev/null ) &&  su - $SUDO_USER -c 'wget --max-redirect=10 --mirror  --no-check-certificate '"${target_url}"' ' # 2>/dev/null"

    # WGETRC=${_temp_dir}/wgetrc  wget "${WGETCOMMAND}" # 2>/dev/null"
    _assure_success
    echo "${msg}"
    echo -e "\033[7m*** Download Wget executed completed.\033[0m"
    rm -f ${_temp_dir}/wgetrc
    file_does_not_exist_with_spaces ${_temp_dir}/wgetrc
    # file_exists_with_spaces "${download_folder}/${download_file}"
  elif ( command -v curl >/dev/null 2>&1; ); then
    ensure curl or "curl is required"
   # if not defined and not empty try code normal
    ( typeset -p "SUDO_USER"  &>/dev/null ) ||  cd "${download_folder}" && curl -O "${target_url}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
    # if defined and not empty
    # ( typeset -p "SUDO_USER"  &>/dev/null ) && echo "sudo user " >&2
    ( typeset -p "SUDO_USER"  &>/dev/null ) &&  su - "$SUDO_USER" -c 'cd  '"${download_folder}"' && curl -O  '"${download_folder}/${download_file}"' '"${target_url}"' 2>/dev/null'   # suppress only wget download messages, but keep wget output for variable

    # _assure_success
  else
    failed \\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\n"I cannot find wget or curl programs to perform a download action! ${target_url}"
  fi
} # end _download_linux


function _assure_success() {
  if [ $? != 0 ] ; then
    failed -e "\033[38;5;1m Something went wrong \033[0m"
    exit 1
  fi
  wait
}

function _trap_try_start() {
  trap _term SIGTERM
}

function _trap_catch_check() {
  declare -i ret=$?
  local child
  if [ $ret -gt 0 ] ; then
  {
    child=$!
    wait $child
    warning "${YELLOW}Error SIGNAL_RETURN(${RED}${ret}${YELLOW}) executing: \n${action}"
    return 1 # non zero is error
  }
  fi
  return 0
}

function _action_runner() {
  local action
  while read -r action ; do
  {
    if [[ ! -z "${action}" ]] ; then # if not empty
    {
      _trap_try_start
      echo "${action}"
      "${action}"
      _trap_catch_check
    }
    fi
  }
  done <<< "${@}"
} # end _action_runner

function _try_runner() {
  local body=$(_function_body "${1}")
  function_exists "${1}"
  while read -r action ; do
  {
    if [[ ! -z "${action}" ]] ; then # if not empty
    {
      _trap_try_start
      echo "${action}"
      "${action}"
      _trap_catch_check
    }
    fi
  }
  done <<< "${body}"
} # end _try_runner

function _function_body() {
  local functionname="${1}"
  # function_exists "${functionname}"
  # ensure head or Cancel. Missing head command
  # ensure tail or Cancel. Missing tail command
  # ensure declare or Cancel. Missing declare command
  # ensure wc or Cancel. Missing declare command
  local functioncomplete=$(declare -f "${functionname}")
  # echo complete:"${functioncomplete}"
  local functionbody=$(echo "${functioncomplete}" | cüt "${functionname} ()")
  # echo body:"${functionbody}"
  local functionlength=$(echo "${functionbody}" | wc -l)
  # echo length:${functionlength}
  # echo less:${functionlengthless}
  (( functionlength-- ))
  # echo lenght:${functionlength}
  functionbody=$(echo "${functionbody}" | head -${functionlength} )
  # echo body:"${functionbody}"
  (( functionlength-- ))
  # echo length:${functionlength}
  functionbody=$(echo "${functionbody}" | tail -${functionlength} )
  # echo body:"${functionbody}"
  echo "${functionbody}"
}

function _try_body() {
  local body=$(_function_body "${1}")
  _trap_try_start
  echo "${body}"
  "${body}"
  _trap_catch_check
}

function _try() {
  local body="${@}"
  _trap_try_start
  echo -e "\033[01;7m***${body}\033[0m***"
  local msg="${body}"
  declare -i ret=_trap_catch_check
  echo "${msg}"
  unset body
  unset msg
  if [ $ret -gt 0 ] ; then
    unset ret
    return 1
  else
    unset ret
    return 0
  fi
}


function function_is_defined_with_spaces() {
            # Sample usage
            #
            #          if  ! function_is_defined_with_spaces "/home/vagrant/.zshrc" ; then    is like is NOT installed
            #          if  function_is_defined_with_spaces "/root/.zshrc ; then      it makes more sense to make it this way
            #
            local ONE_FUNCTION FUNCTIONS="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FUNCTION; do
                # if not empty
                if [ ! -z "${ONE_FUNCTION}" ] ; then
                    if [ -n "$(LC_ALL=C type -t "${ONE_FUNCTION}")" ] && [ "$(LC_ALL=C type -t "${ONE_FUNCTION}")" = function ]; then
                    {
                        return 0 # function exists
                    }
                    fi
                fi
                done <<< "${FUNCTIONS}"
                return 1 # function does not exists
            }
            fi
            unset ONE_FUNCTION
            unset FUNCTIONS
            unset TESTING
} # end function_is_defined_with_spaces

function function_is_defined() {
            # Sample usage
            #
            #          if  ! function_is_defined determine_os_and_fire_action ; then    is like is NOT installed
            #          if  function_is_defined "$FUNCTION_TO_CALL" ; then      it makes more sense to make it this way
            #
            local ONE_FUNCTION FUNCTIONS="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                FUNCTIONS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_FUNCTION; do
                # if not empty
                if [ ! -z "${ONE_FUNCTION}" ] ; then
                if [ -n "$(LC_ALL=C type -t "${ONE_FUNCTION}")" ] && [ "$(LC_ALL=C type -t "${ONE_FUNCTION}")" = function ]; then
                    {
                        return 0 # function exists
                    }
                    fi
                fi
                done <<< "${FUNCTIONS}"
                return 1 # function does not exists
            }
            fi
            unset ONE_FUNCTION
            unset FUNCTIONS
            unset TESTING

} # end function_is_defined

function function_exists() {
            # Sample usage
            #
            #     function_exists determine_os_and_fire_action
            #     function_exists  "$FUNCTION_TO_CALL"
            #     function_exists "Function1
            #                      Function2
            #                      Function2"
            #
            local TESTING ONE_FUNCTION FUNCTIONS="${@}"
            if [ ! -z "${FUNTIONS-x}" ] ; then # if its set and not empty
            {
                FUNCTIONS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_FUNCTION; do
                if [ ! -z "${ONE_FUNCTION}" ] ; then # if not empty
                    TESTING="that function ${CYAN}${ONE_FUNCTION}${LIGHTYELLOW} exists"
                    if function_is_defined "${ONE_FUNCTION}" ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${FUNCTIONS}"
            }
            fi
        unset ONE_FUNCTION
        unset FUNCTIONS
        unset TESTING

} # end function_exists

# function_exists ls
# build_table_from_installed_components $USER
# build_table_from_installed_components $SUDO_USER

function function_exists_with_spaces() {
            # Sample usage
            #
            #     function_exists_with_spaces determine_os_and_fire_action
            #     function_exists_with_spaces  "$FUNCTION_TO_CALL"
            #     function_exists_with_spaces "Function1
            #                      Function2
            #                      Function2"
            #
            local TESTING ONE_FUNCTION FUNCTIONS="${@}"
            if [ ! -z "${FUNTIONS-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FUNCTION; do
                if [ ! -z "${ONE_FUNCTION}" ] ; then # if not empty
                    TESTING="that function ${CYAN}${ONE_FUNCTION}${LIGHTYELLOW} exists"
                    if function_is_defined_with_spaces "${ONE_FUNCTION}" ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
            done <<< "${FUNCTIONS}"
            }
            fi
            unset ONE_FUNCTION
            unset FUNCTIONS
            unset TESTING
} # end function_exists_with_spaces

function get_architecture(){
  # How to use
  #    FUNCTION_TO_CALL=$(get_architecture "debian")
  # > _debian__64
  # > _debian__32
  #    FUNCTION_TO_CALL=$(get_architecture "${DISTRO}")
  #
  local system_nick="${1}"
  local return_function_to_call=""
  if [[ "$(uname -i)" == "x86_64" ]] ; then
  {
    return_function_to_call="_${system_nick}__64"
  }
  elif [[ "$(uname -i)" == "i686"   ]] ; then
  {
    return_function_to_call="_${system_nick}__32"
  }
  fi
  if [ -z ${return_function_to_call} ] || [[ "${return_function_to_call}" =~ 'nknown' ]] ; then
  {
     if [[ "$(uname -a)" =~  'x86_64' ]] ; then
     {
       return_function_to_call="_${system_nick}__64"
     }
     fi
     if [[ "$(uname -a)" =~  'i686' ]] ; then
     {
       return_function_to_call="_${system_nick}__32"
     }
     fi
  }
  fi
  echo -n ${return_function_to_call}
  return 0
} # end get_architecture

function determine_os_and_fire_action() {
  # Interface
  # How to use
  # First implement the target functions
  #              _fedora__64(){ }
  #              _fedora__32(){ }
  #              _ubuntu__64(){ }
  #              _ubuntu__32(){ }
  #              _mingw__64(){ }
  #              _mingw__32(){ }
  #              _darwin__64(){ }
  #              _darwin__32(){ }
  # Then call this function
  #              determine_os_and_fire_action  """${*}"""
  # remember to pass the  """${*}""" for the parameters to pass
  # If will fail is the function has not been implemented with Error message
  # of the function that is missing like _archlinux__64
  local FUNCTION_TO_CALL=""
  local PARAMETERS=""
  local -i DEBUG=0
  # Check operating systems
  # echo  ${@}
  if [[ "$(uname)" == "Darwin" ]] ; then
      if (( DEBUG )) ; then
        echo "Darwin"
      fi
      # Do something under Mac OS X platform
      if [[ "$(uname -m)" == "x86_64" ]] ; then
      {
         FUNCTION_TO_CALL='_darwin__64'
         PARAMETERS="$@"
      }
      elif [[ "$(uname -m)" == "i686"   ]] ; then
      {
         FUNCTION_TO_CALL='_darwin__32'
         PARAMETERS="$@"
      }
      elif [[ "$(uname -m)" == "arm64"   ]] ; then
      {
         FUNCTION_TO_CALL='_darwin__arm64'
         PARAMETERS="$@"
      }
      else
      {
        FUNCTION_TO_CALL="_darwin__$(uname -m)"
        PARAMETERS="$@"
        warning "ERROR to determine "$(uname)" architecture (uname -m)  for: <$(uname -m)>"  
      }
      fi
  elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]] ; then
    if (( DEBUG )) ; then
      echo "Linux"
    fi
    # Do something under GNU/Linux platform
    # Determine OS platform
    local UNAME=$(uname | tr "[:upper:]" "[:lower:]")
    if (( DEBUG )) ; then
      echo "UNAME: $UNAME"
    fi
    local DISTRO=""
    local ID=""
    local VERSION_ID=""
    # If Linux, try to determine specific distribution
    if [[ "$UNAME" == "linux" ]]; then
    {
      # If available, use LSB to identify distribution
      if [ -f /etc/lsb-release -o -d /etc/lsb-release.d ]; then
      {
        if ( command -v lsb_release >/dev/null 2>&1; ); then
        {
          if (( DEBUG )) ; then
            echo "RELEASE Option: 1"
          fi
          DISTRO=$(lsb_release -i | cut -d: -f2 | sed s/'^\t'// | head -1)
        }
        else
        {
          if (( DEBUG )) ; then
            echo "RELEASE Option: 2"
          fi
          DISTRO=$(ls -d /etc/[A-Za-z]*[_-][rv]e[lr]* | grep -v "lsb" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1 | head -1)
        }
        fi
      }
      else # Otherwise, use release info file
      {
        if (( DEBUG )) ; then
          echo "RELEASE Option: 3"
        fi
        DISTRO=$(ls -d /etc/[A-Za-z]*[_-][rv]e[lr]* | grep -v "lsb" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1 | head -1)
      }
      fi
    }
    fi
    if (( DEBUG )) ; then
      echo "DISTRO:$DISTRO"
    fi
    if [[ -z "$DISTRO" ]]; then  # if empty
    {
      if (( DEBUG )) ; then
        echo "DISTRO empty"
      fi
      # If available, use /etc/os-release to identify distribution
        if [ -f /etc/os-release ]; then
        {
        source /etc/os-release
                # file_exists "/etc/os-release"
                _assure_success
                # source /etc/os-release
                # $ echo $ID
                # fedora
                # $ echo $VERSION_ID
                # 17
                # $ echo $VERSION
                # 17 (Beefy Miracle)
                DISTRO=$ID
        }
        fi
    }
    fi
    if [[ -z "$DISTRO" ]]; then  # if empty
    {
        failed to determine DISTRO for this linux. uname -a, cat /etc/os-release, lsb_release -i
    }
    fi

    if [[ "$DISTRO" == *"edora"* ]]; then
    {
      FUNCTION_TO_CALL=$(get_architecture "fedora")
      PARAMETERS="$@"
    }
    elif [[ "$DISTRO" == *"untu"* ]]; then
    {
      # ubuntu lsb_release -i | sed 's/Distributor\ ID://g' = \tUbuntu\n
      FUNCTION_TO_CALL=$(get_architecture "ubuntu")
      PARAMETERS="$@"
    }
    elif [[ "$DISTRO" == *"bian"* ]]; then
    {
      FUNCTION_TO_CALL=$(get_architecture "debian")
      PARAMETERS="$@"
    }
    else
    {
      FUNCTION_TO_CALL=$(get_architecture "${DISTRO}")
      PARAMETERS="$@"
    }
    fi
    if (( DEBUG )) ; then
      echo "FUNCTION_TO_CALL: $FUNCTION_TO_CALL"
      echo "uname -i: $(uname -i)"
    fi
    # For everything else (or if above failed), just use generic identifier
    unset UNAME
    unset DISTRO
    unset ID

  elif [[ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" ]] ; then
    # Do something under Windows NT platform
    if [[ "$(uname -i)" == "x86_64" ]] ; then
    {
      FUNCTION_TO_CALL='_mingw__64'
      PARAMETERS="$*"
    }
    elif [[ "$(uname -i)" == "i686"   ]] ; then
    {
      FUNCTION_TO_CALL='_mingw__32'
      PARAMETERS="$*"
    }
    fi
    # nothing here
  else
    failed system not recognized
  fi
  if [[ -z "${FUNCTION_TO_CALL}" ]]; then  # if empty
  {
     failed "ERROR to determine FUNCTION_TO_CALL for this OS. uname -a, cat /etc/os-release, lsb_release -i <${FUNCTION_TO_CALL}>"
  }
  else
  {
        if function_is_defined "${FUNCTION_TO_CALL}" ; then
        {
           "${FUNCTION_TO_CALL}" "${PARAMETERS}"
            _assure_success
        }
        else
        {
           failed to find function for this OS or DISTRO:  "${FUNCTION_TO_CALL}" "${PARAMETERS}"
           _assure_success
        }
    fi

  }
  fi
  _assure_success
  unset FUNCTION_TO_CALL
  unset PARAMETERS
} # end determine_os_and_fire_action

function _move_to_target_dir() {
  # Sample use
  #
  #   _move_to_target_dir "${DOWNLOADFOLDER}" ${_target_dir_install}" "${TARGETFOLDER}"
  #
  local DOWNLOADFOLDER="${1}" #    param order    varname             varvalue                   sample_value
  enforce_parameter_with_value     "1"             DOWNLOADFOLDER      "${DOWNLOADFOLDER}"        "\${USER_HOME}/Downloads \${DOWNLOADFOLDER}"

  local _target_dir_install="${2}" # param order   varname             varvalue                   sample_value
  enforce_parameter_with_value         "2"         _target_dir_install  "${_target_dir_install}"   "${USER_HOME}/_/software/phpstorm"

  local TARGETFOLDER="${3}" # param order      varname           varvalue                   sample_value
  enforce_parameter_with_value     "3"        TARGETFOLDER     "${TARGETFOLDER}"   "${USER_HOME}/_/software"

  local NEWDIRCODENAME=$(ls -1tr "${DOWNLOADFOLDER}/"  | tail  -1)
  local FROMUZIPPED="${DOWNLOADFOLDER}/${NEWDIRCODENAME}"
  directory_exists_with_spaces  "${FROMUZIPPED}"

  _backup_current  "${_target_dir_install}"

  [ ! -d "${TARGETFOLDER}" ] &&  mkdir -p "${TARGETFOLDER}"
  directory_exists_with_spaces "${TARGETFOLDER}"

  [ -e "${_target_dir_install}" ] && rm -rf "${_target_dir_install}"
  mv "${FROMUZIPPED}" "${_target_dir_install}"

  directory_does_not_exist_with_spaces "${FROMUZIPPED}"
  directory_exists_with_spaces "${_target_dir_install}"

} # end _move_to_tartget_dir

function _backup_current(){
  # Sample use:
  #
  #   _backup_current  "${USER_HOME}/_/software/phpstorm"
  #
  local __dir="${*}"  #           param order   varname   varvalue      valid_options
  # enforce_parameter_with_options 1            __dir     "${__dir}"    "/home/user/Downloads /home/user2/Downloads"
  #                  #             param order  varname   varvalue      sample_value
  enforce_parameter_with_value     "*"          __dir     "${__dir}"    "${USER_HOME}/_/software/phpstorm"

  if  it_exists_with_spaces "${__dir}" ; then
  {
     local folder_date=$(date +"%Y%m%d")
     if  it_exists_with_spaces "${__dir}_${folder_date}" ; then
     {
       warning A backup already exists for today "${ret}:${msg} \n ... adding time"
       folder_date=$(date +"%Y%m%d%H%M")
     }
     fi
     local msg=$(mv "${__dir}" "${__dir}_${folder_date}")
     local ret=$?
     if [ $ret -gt 0 ] ; then
     {
       warning failed to move backup "${ret}:${msg} \n"
     }
     fi
     directory_exists_with_spaces "${__dir}_${folder_date}"
     file_does_not_exist_with_spaces "${__dir}"
  }
  fi
} # end backup_current

function _untar_gz_download(){
  # Sample use:
  #    _untar_gz_download  "${DOWNLOADFOLDER}"   "${DOWNLOADFOLDER}/${CODENAME}.tar.gz"
  #
  local DOWNLOADFOLDER="${1}" #  param order  varname        varvalue                 sample_value
  enforce_parameter_with_value     "1"        DOWNLOADFOLDER "${DOWNLOADFOLDER}"    "\${USER_HOME}/Downloads \${DOWNLOADFOLDER}"
  local _tar_file="${2}"
  enforce_parameter_with_value     "2"        _tar_file      "${_tar_file}"         "\${DOWNLOADFOLDER}/\${CODENAME}.tar.gz"

  ensure tar or "Canceling Install. Could not find tar command to execute unzip"
  ensure awk or "Canceling Install. Could not find awk command to execute unzip"
  ensure pv or "Canceling Install. Could not find pv command to execute unzip"
  ensure du or "Canceling Install. Could not find du command to execute unzip"
  ensure gzip or "Canceling Install. Could not find gzip command to execute unzip"
  # ensure gio or "Canceling Install. Could not find gio command to execute gio"
  # ensure update-mime-database or "Canceling Install. Could not find update-mime-database command to execute update-mime-database"
  # ensure update-desktop-database or "Canceling Install. Could not find update-desktop-database command to execute update"
  ensure touch or "Canceling Install. Could not find touch command to execute touch"

  # provide error handling , once learned goes here. LEarn under if, once learned here.
  # Start loop while ERROR flag in case needs to try again, based on error
  cd "${DOWNLOADFOLDER}"
  #_try "tar xvzf  \"${DOWNLOADFOLDER}/${CODENAME}.tar.gz\"--directory=${DOWNLOADFOLDER}"
  # GROw bar with tar Progress bar tar REF: https://superuser.com/questions/168749/is-there-a-way-to-see-any-tar-progress-per-file
  # Compress tar cvfj big-files.tar.bz2 folder-with-big-files
  # Compress tar cf - ${DOWNLOADFOLDER}/${CODENAME}.tar.gz --directory=${DOWNLOADFOLDER} -P | pv -s $(du -sb ${DOWNLOADFOLDER}/${CODENAME}.tar.gz | awk '{print $1}') | gzip > big-files.tar.gz
  # Extract tar Progress bar REF: https://coderwall.com/p/l_m2yg/tar-untar-on-osx-linux-with-progress-bars
  # Extract tar sample pv file.tgz | tar xzf - -C target_directory
  # Working simplme tar:  tar xvzf ${DOWNLOADFOLDER}/${CODENAME}.tar.gz --directory=${DOWNLOADFOLDER}
  pv "${_tar_file}"  | tar xzf - -C "${DOWNLOADFOLDER}"
  #local msg=$(_try "tar xvzf  \"${DOWNLOADFOLDER}/${CODENAME}.tar.gz\" --directory=${DOWNLOADFOLDER} " )
  #  tar xvzf file.tar.gz
  # Where,
  # x: This option tells tar to extract the files.
  # v: The “v” stands for “verbose.” This option will list all of the files one by one in the archive.
  # z: The z option is very important and tells the tar command to uncompress the file (gzip).
  # f: This options tells tar that you are going to give it a file name to work with.
  local msg
  local folder_date
  local ret=$?
  if [ $ret -gt 0 ] ; then
  {
    failed "${ret}:${msg}"
    # add error handling knowledge while learning.
  }
  else
  {
    passed Install with Untar Unzip success!
  }
  fi
} # end _untar_gz_download


function _do_not_downloadtwice(){
  # Sample usage:
  #
  #   enforce_variable_with_value USER_HOME "${USER_HOME}"
  # local CODENAME=teamviewer.x86_64.rpm
  # enforce_variable_with_value CODENAME "${CODENAME}"
  # local TARGET_URL=https://download.teamviewer.com/download/linux/teamviewer.x86_64.rpm
  # enforce_variable_with_value TARGET_URL "${TARGET_URL}"
  # local DOWNLOADFOLDER="${USER_HOME}/Downloads"
  # enforce_variable_with_value DOWNLOADFOLDER "${DOWNLOADFOLDER}"
  #
  # _do_not_downloadtwice "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
  #
  #
  local TARGET_URL="${1}"
  enforce_parameter_with_value 1 TARGET_URL "${TARGET_URL}" "https://download.teamviewer.com/download/linux/teamviewer.x86_64.rpm"
  local DOWNLOADFOLDER="${2}"
  Comment "DOWNLOADFOLDER:„${DOWNLOADFOLDER}”"
  enforce_parameter_with_value 2 DOWNLOADFOLDER "${DOWNLOADFOLDER}" "$USER_HOME/Downloads"
  file_exists_with_spaces "${DOWNLOADFOLDER}"
  local CODENAME="${3}"
  enforce_parameter_with_value 3 CODENAME "${CODENAME}" "teamviewer.x86_64.rpm"
  (( VERBOSE )) && echo  _do_not_downloadtwice "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"

  if it_exists_with_spaces "${DOWNLOADFOLDER}/${CODENAME}" ; then
  {
    file_exists_with_spaces "${DOWNLOADFOLDER}/${CODENAME}"
  }
  else
  {
    cd "${DOWNLOADFOLDER}"
    (( VERBOSE )) && pwd
    (( VERBOSE )) && echo  _download "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
    _download "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
    file_exists_with_spaces "${DOWNLOADFOLDER}/${CODENAME}"
  }
  fi
} # end _do_not_downloadtwice

function _remove_downloaded_codename_or_err(){
  local _err=${1}
  local DOWNLOADFOLDER_CODENAME="${2}"
  if [ $_err -eq 0 ] ; then
  {
    if it_exists_with_spaces "${DOWNLOADFOLDER_CODENAME}"; then
    {
      Message Removing Downloaded file "${DOWNLOADFOLDER_CODENAME}"
      rm "${DOWNLOADFOLDER_CODENAME}"
      _err=$?
      [ $_err -gt 0 ] && return $_err
      file_does_not_exist_with_spaces "${DOWNLOADFOLDER_CODENAME}"
      passed Removed Downloaded file "${DOWNLOADFOLDER_CODENAME}"
      return 0
    }
    fi
  }
  fi
  return $_err
} # end _remove_downloaded_codename_or_err

function _install_apt() {
  #   Sample usage:
  #
  # local TARGET_URL=https://zoom.us/client/latest/zoom_amd64.deb
  # enforce_variable_with_value TARGET_URL "${TARGET_URL}"
  #   local CODENAME=$(basename "${TARGET_URL}")
  #   enforce_variable_with_value CODENAME "${CODENAME}"
  #   local DOWNLOADFOLDER="${USER_HOME}/Downloads"
  #   enforce_variable_with_value DOWNLOADFOLDER "${DOWNLOADFOLDER}"
  #   _do_not_downloadtwice "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
  # _install_apt "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}" 0
  #
  #
    local TARGET_URL="${1}"
    enforce_parameter_with_value 1 TARGET_URL "${TARGET_URL}" "https://download.teamviewer.com/download/linux/teamviewer.amd64.deb"
    local DOWNLOADFOLDER="${2}"
    enforce_parameter_with_value 2 DOWNLOADFOLDER "${DOWNLOADFOLDER}" "$USER_HOME/Downloads"
    local CODENAME="${3}"
    enforce_parameter_with_value 3 CODENAME "${CODENAME}" "teamviewer.amd64.deb"
    local -i LOOP="${4}"
    enforce_parameter_with_value 4 LOOP "${LOOP}" "1 or 2 or 0"
    file_exists_with_spaces "${DOWNLOADFOLDER}/${CODENAME}"
    local TARGET_DOWNLOAD_PATH="${DOWNLOADFOLDER}/${CODENAME}"
    enforce_parameter_with_value COMPOSITE TARGET_DOWNLOAD_PATH "${TARGET_DOWNLOAD_PATH}" "$USER_HOME/Downloads/teamviewer.amd64.deb"

    if  it_exists_with_spaces "${TARGET_DOWNLOAD_PATH}" ; then
    {
      echo Attempting to install "${TARGET_DOWNLOAD_PATH}"
    }
    else
    {
      return 1
    }
    fi
    ensure dpkg or "Canceling Install. Could not find dpkg command to execute install"
    ensure apt or "Canceling Install. Could not find apt command to execute install"
    _trap_try_start # _trap_catch_check
    local msg=$(apt install -y "${TARGET_DOWNLOAD_PATH}")
    _trap_catch_check
    echo "${msg}"
    if [[ "${msg}" == *"not an dpkg package"* ]] ; then
    {
        Warning Package appearts broken, downloading again
      _download "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
      _install_apt "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
    }
    elif [[ "${msg}" == *"libQt5WebKit.so.5"* ]] && [[ "${msg}" == *"is needed"* ]] && (( ! LOOP )) ; then
    {
          echo "Suggested Fix "
      echo "# when error error: Failed dependencies:
            #        libQt5Svg.so.5()(64bit) is needed by "${CODENAME}"
            # then correct with
            # fix with
            # then fix with
            # sudo apt install -y qt5-devel qt-creator qt5-qtbase qt5-qtbase-devel
            # dpkg again"
      Attempting to fix
      apt install -y qt5-devel qt-creator qt5-qtbase qt5-qtbase-devel
      _install_apt "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}" 1
    }
    elif [[ "${msg}" == *"libQt5WebKit.so.5"* ]] && [[ "${msg}" == *"is needed"* ]] && (( LOOP )) ; then
    {
          echo "Suggested Fix "
      echo "# when error error: Failed dependencies:
            #        libQt5Svg.so.5()(64bit) is needed by "${CODENAME}"
            # then correct with
            # fix with
            # then fix with
            # sudo apt install -y qt5-devel qt-creator qt5-qtbase qt5-qtbase-devel
            # I could not install it automatically
            # dpkg again"
      failed "ERROR MSG:\n ${msg}"
    }
    elif [[ "${msg}" == *"Failed dependencies"* ]] && [[ "${msg}" == *"is needed"* ]] ; then
    {
      # echo "Suggested Fix "
      # echo "# when error error:
      #       # fix with
      #       # then fix with
      #       # dpkg again"
      failed "ERROR MSG:\n ${msg}"
    }
    else
    {
      passed "Seems there were no errors"
    }
    fi
    rm -f "${TARGET_DOWNLOAD_PATH}"
    return 0
} # end _install_apt

function _install_rpm() {
  #   Sample usage:
  #
  # local TARGET_URL=https://zoom.us/client/latest/zoom_x86_64.rpm
  # enforce_variable_with_value TARGET_URL "${TARGET_URL}"
  #   local CODENAME=$(basename "${TARGET_URL}")
  #   enforce_variable_with_value CODENAME "${CODENAME}"
  #   local DOWNLOADFOLDER="${USER_HOME}/Downloads"
  #   enforce_variable_with_value DOWNLOADFOLDER "${DOWNLOADFOLDER}"
  #   _do_not_downloadtwice "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
  # _install_rpm "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}" 0
  #
  #
    local TARGET_URL="${1}"
    enforce_parameter_with_value 1 TARGET_URL "${TARGET_URL}" "https://download.teamviewer.com/download/linux/teamviewer.x86_64.rpm"
    local DOWNLOADFOLDER="${2}"
    enforce_parameter_with_value 2 DOWNLOADFOLDER "${DOWNLOADFOLDER}" "$USER_HOME/Downloads"
    local CODENAME="${3}"
    enforce_parameter_with_value 3 CODENAME "${CODENAME}" "teamviewer.x86_64.rpm"
    local -i LOOP="${4}"
    enforce_parameter_with_value 4 LOOP "${LOOP}" "1 or 2 or 0"
    Comment testing "${DOWNLOADFOLDER}/${CODENAME}"
    file_exists_with_spaces "${DOWNLOADFOLDER}/${CODENAME}"
    local TARGET_DOWNLOAD_PATH="${DOWNLOADFOLDER}/${CODENAME}"
    enforce_parameter_with_value COMPOSITE TARGET_DOWNLOAD_PATH "${TARGET_DOWNLOAD_PATH}" "$USER_HOME/Downloads/teamviewer.x86_64.rpm"

    if  it_exists_with_spaces "${TARGET_DOWNLOAD_PATH}" ; then
    {
      echo Attempting to install "${TARGET_DOWNLOAD_PATH}"
    }
    else
    {
      return 1
    }
    fi
    ensure rpm or "Canceling Install. Could not find rpm command to execute install"
    ensure dnf or "Canceling Install. Could not find dnf command to execute install"
    _trap_try_start # _trap_catch_check
    local msg=$(dnf install -y "${TARGET_DOWNLOAD_PATH}")
    _trap_catch_check
    echo "${msg}"
    if [[ "${msg}" == *"not an rpm package"* ]] ; then
    {
        Warning Package appearts broken, downloading again
      _download "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
      _install_rpm "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
    }
    elif [[ "${msg}" == *"libQt5WebKit.so.5"* ]] && [[ "${msg}" == *"is needed"* ]] && (( ! LOOP )) ; then
    {
          echo "Suggested Fix "
      echo "# when error error: Failed dependencies:
            #        libQt5Svg.so.5()(64bit) is needed by "${CODENAME}"
            # then correct with
            # fix with
            # then fix with
            # sudo dnf install -y qt5-devel qt-creator qt5-qtbase qt5-qtbase-devel
            # rpm again"
      Attempting to fix
      dnf install -y qt5-devel qt-creator qt5-qtbase qt5-qtbase-devel
      _install_rpm "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}" 1
    }
    elif [[ "${msg}" == *"libQt5WebKit.so.5"* ]] && [[ "${msg}" == *"is needed"* ]] && (( LOOP )) ; then
    {
          echo "Suggested Fix "
      echo "# when error error: Failed dependencies:
            #        libQt5Svg.so.5()(64bit) is needed by "${CODENAME}"
            # then correct with
            # fix with
            # then fix with
            # sudo dnf install -y qt5-devel qt-creator qt5-qtbase qt5-qtbase-devel
            # I could not install it automatically
            # rpm again"
      failed "ERROR MSG:\n ${msg}"
    }
    elif [[ "${msg}" == *"Failed dependencies"* ]] && [[ "${msg}" == *"is needed"* ]] ; then
    {
      # echo "Suggested Fix "
      # echo "# when error error:
      #       # fix with
      #       # then fix with
      #       # rpm again"
      failed "ERROR MSG:\n ${msg}"
    }
    else
    {
      passed "Seems there were no errors"
    }
    fi
    rm -f "${TARGET_DOWNLOAD_PATH}"
    return 0
} # end _install_rpm


export raise_to_sudo_and_user_home
function raise_to_sudo_and_user_home() {
  #
  # Sample usage:
  #
  # Place this on the start of the script  that
  #  needs to reloaded as sudo "MOTHER" script:
  #
  #   export  THISSCRIPTCOMPLETEPATH
  #   typeset -gr THISSCRIPTCOMPLETEPATH="$(basename "$0")"   # § This goes in the FATHER-MOTHER script
  #   export _err
  #   typeset -i _err=0
  #
  # ...
  # wrapp it in local function exported
  # export sudo_it
  # function sudo_it() {
  #   raise_to_sudo_and_user_home
  # } # end sudo_it
  #
  # ...
  # then call it the wrapper
  # ...
  #
  #  sudo_it
  #  [ $? -gt 0 ] && failed to sudo_it raise_to_sudo_and_user_home
  #   enforce_variable_with_value USER_HOME "${USER_HOME}"
  #
  load_execute_boot_basic_with_sudo(){
    # shellcheck disable=SC2030
    if ( typeset -p "SUDO_USER"  &>/dev/null ) ; then
    {
      export USER_HOME
      # typeset -rg USER_HOME=$(getent passwd $SUDO_USER | cut -d: -f6)  # Get the caller's of sudo home dir Just Linux
      # shellcheck disable=SC2046
      # shellcheck disable=SC2031
      if ! ( env | grep "USER_HOME" &>/dev/null ) ; then
      {
          typeset USER_HOME="$(echo -n $(bash -c "cd ~${SUDO_USER} && pwd"))"  # Get the caller's of sudo home dir LINUX and MAC
      }
      fi
    }
    else
    {
      local USER_HOME=$HOME
    }
    fi
    # shellcheck disable=SC1090
    echo "... sudologic identified USER_HOME:$USER_HOME"
    local -r provider="$USER_HOME/_/clis/execute_command_intuivo_cli/execute_boot_basic.sh"
    local _err=0 bootbasicsource
    if [   -e "${provider}"  ] ; then
      if (( DEBUG )) ; then
        echo "$0 execute_command_intuivo_cli/struct_testing load_execute_boot_basic_with_sudo() Loading locally"
      fi
      bootbasicsource="""$(<"${provider}")"""
      _err=$?
      [ $_err -gt 0 ] &&  echo -e "\n \n  ERROR! Loading execute_boot_basic.sh. running 'source locally' returned error did not download or is empty err:$_err  \n \n  " && exit 1
    else
      if ( command -v curl >/dev/null 2>&1; )  ; then
        if (( DEBUG )) ; then
          echo "$0 execute_command_intuivo_cli/struct_testing load_execute_boot_basic_with_sudo() curl Loading execute_boot_basic.sh from the net using curl "
        fi
        bootbasicsource="""$(curl https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/execute_boot_basic.sh  -so -   2>/dev/null )"""  #  2>/dev/null suppress only curl download messages, but keep curl output for variable
        _err=$?
        [ $_err -gt 0 ] &&  echo -e "\n \n  ERROR! Loading execute_boot_basic.sh. running 'curl' returned error did not download or is empty err:$_err  \n \n  " && exit 1
      elif ( command -v wget >/dev/null 2>&1; ) ; then
        if (( DEBUG )) ; then
          echo "$0 execute_command_intuivo_cli/struct_testing load_execute_boot_basic_with_sudo() wget Loading execute_boot_basic.sh from the net using wget "
        fi
        bootbasicsource="""$(wget --quiet --no-check-certificate  https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/execute_boot_basic.sh -O -   2>/dev/null )"""  #  2>/dev/null suppress only wget download messages, but keep wget output for variable
        _err=$?
        [ $_err -gt 0 ] &&  echo -e "\n \n  ERROR! Loading execute_boot_basic.sh. running 'wget' returned error did not download or is empty err:$_err  \n \n  " && exit 1
      else
        echo -e "\n \n  ERROR! Loading execute_boot_basic.sh could not find wget or curl to download  \n \n "
        exit 69
      fi
    fi
    [[ -z "${bootbasicsource}" ]] && echo -e "\n \n  ERROR! Loading execute_boot_basic.sh  bootbasicsource did not download or is empty " && exit 1
    local _temp_dir="$(mktemp -d 2>/dev/null || mktemp -d -t 'execute_boot_basic_source')"
    echo "${bootbasicsource}">"${_temp_dir}/execute_boot_basic_source"
    if (( DEBUG )) ; then
      echo "$0 execute_command_intuivo_cli/struct_testing load_execute_boot_basic_with_sudo() Temp execute_boot_basic.sh location ${_temp_dir}/execute_boot_basic_source"
    fi
    echo "2. sudologic execute_boot_basic.sh Temp location ${_temp_dir}/execute_boot_basic_source"
    source "${_temp_dir}/execute_boot_basic_source"
    _err=$?
    [ $_err -gt 0 ] &&  echo -e "\n \n  ERROR! Loading execute_boot_basic.sh. Occured while running 'source' err:$_err  \n \n  " && exit 1
    if  ! typeset -f on_int >/dev/null 2>&1; then
      echo -e "\n \n  ERROR! Loading execute_boot_basic.sh. on_int function was not found.. was not loaded !!!  \n \n "
      exit 69;
    fi
    return 0
  } # end load_execute_boot_basic_with_sudo

  load_execute_boot_basic_with_sudo
  _err=$?
  if [ $_err -ne 0 ] ;  then
  {
    >&2 echo -e "ERROR There was an error loading load_execute_boot_basic_with_sudo Err:$_err "
    exit $_err
  }
  fi

  # Overwrite trap
  # function _trap_on_exit(){
    # echo -e "\033[01;7m*** TRAP $THISSCRIPTCOMPLETEPATH EXITS ...\033[0m"
  # }
  #trap kill ERR
  # trap _trap_on_exit EXIT
  #trap kill INT
} # end raise_to_sudo_and_user_home

function enforce_node_is_version(){
  # Sample use:
  # enforce_node_is_version  "12.20.1"
  #
  if (( DEBUG )) ; then
    echo "  Checking for node version to be ${1}"
  fi
  local msg
  msg=$(node --version | cut -c2- | grep "${1}" 2>&1; )
  _err=$?
  local TESTING="node is version ${1} "
  if [ $_err -gt 0 ] ; then
  {
    failed "expected ${TESTING} but got <$(node --version)> "
  }
  fi
  if (( DEBUG )) ; then
    passed "${TESTING}"
  fi
  return 0
} # end enforce_node_is_version

function enforce_vpn_is_on(){
  # Sample use:
  # enforce_vpn_is_on  "diginet"
  #
  (( DEBUG )) && echo "  Checking for connection to ${1}"
  local msg
  msg=$(/usr/bin/nmcli c show --active | /bin/grep vpn | /bin/grep "${1}" 2>&1; )
  _err=$?
  local TESTING="vpn is on ${1} "
  if [ $_err -gt 0 ] ; then
  {
    failed "${TESTING}"
  }
  fi
  (( DEBUG )) && passed "${TESTING}"
  return 0
} # end enforce_vpn_is_on

function extract_domainname(){
  # Sample usage
  #  local _domain=$(extract_domainname "https://www.cyberciti.biz/faq/")
  #  enforce_variable_with_value _domain "${_domain}"
  #
  # REF: https://www.cyberciti.biz/faq/get-extract-domain-name-from-url-in-linux-unix-bash/
  local _url="${1}"

  ## Remove protocol part of url  ##
  _url="${_url#http://}"
  _url="${_url#https://}"
  _url="${_url#ftp://}"
  _url="${_url#scp://}"
  _url="${_url#scp://}"
  _url="${_url#sftp://}"

  ## Remove username and/or username:password part of URL  ##
  _url="${_url#*:*@}"
  _url="${_url#*@}"

  ## Remove rest of urls ##
  _url=${_url%%/*}

  ## Show domain name only ##
  echo "${_url}"
  return 0
} # end enforce_vpn_is_on

function enforce_web_is_reachable(){
  # Sample use:
  # enforce_web_is_reachable  "cms.artbox.one"
  #
  local _url="${1}"
  local _domain=$(extract_domainname "${_url}")
  enforce_variable_with_value _domain "${_domain}"
  echo "  Checking for connection to ${_domain}"
  local msg
  msg=$(curl -I --connect-timeout 5 --max-time 10 "${_domain}" 2>&1; )
  _err=$?
  local DEBUG=1
  (( DEBUG )) && echo enforce_web_is_reachable curl -I --connect-timeout 5  --max-time 10 "${1}"
  (( DEBUG )) && echo enforce_web_is_reachable curl exit code $_err
  local TESTING="web address ${BRIGHT_BLUE87}««${RED}${1}${BRIGHT_BLUE87}»»${LIGHTYELLOW} is reachable"
  if [ $_err -gt 0 ] ; then
  {
    [ $_err -eq 28 ] && failed "ERROR Connection resolving timed out . ${TESTING}"
    failed "${TESTING}"
  }
  fi
  passed "${TESTING}"
} # end enforce_web_is_reachable


function enforce_ip_resolves(){
  # Sample use:
  # enforce_ip_resolves  "pis.pixum.com" to "127.0.0.1"
  # enforce_ip_resolves  "pis.pixum.com" not-to "127.0.0.1"
  #
  if [[ -n "${1}" ]] && ([[ "${2}" == "not-to" ]] || [[ "${2}" == "to" ]]) && [[ -n "${3}" ]]; then
  {
    echo "  Checking ip for to ${1} ${2} be ${3}"
  }
  else
  {
    echo "Wrong usage, sample call is:  enforce_ip_resolves  \"pis.pixum.com\" to \"127.0.0.1\" "
    echo "Wrong usage, sample call is:  enforce_ip_resolves  \"pis.pixum.com\" not-to \"127.0.0.1\" "
    failed callling enforce_ip_resolves
    exit 1
  }
  fi
  local msg
  # msg=$(dig  "${1}" | grep SERVER | cut -d\( -f2 | cut -d\) -f1 2>&1; )
  msg=$(resolveip "${1}" | cut -d' ' -f6  2>&1; )
  _err=$?
  local TESTING="web  that ip from ${1} resolves ${2} ${3}"
  if [ $_err -gt 0 ] ; then
  {
    [ $_err -eq 28 ] && failed "ERROR Connection resolving dig tool . ${TESTING}"
    failed "${TESTING}"
    exit 1
  }
  fi
  if [[ "${2}" == "to" ]] && [[ "${msg}" != "${3}" ]] ; then
  {
    failed "${TESTING}"
    exit 1
  }
  fi
  if [[ "${2}" == "not-to" ]] && [[ "${msg}" == "${3}" ]] ; then
  {
    failed "${TESTING}"
    exit 1
  }
  fi
  passed "${TESTING}"
} # end enforce_ip_resolves

function _remove_dmgs_app_if_exists() {
  # Sample use
  #       _remove_dmgs_app_if_exists "${APPDIR}"
  local APPDIR="${1}"
  [[ -n "${APPDIR}" ]] && APPDIR="$(basename "${1}")"
  DEBUG=1
  if (( DEBUG )) ; then
  {
    echo "        APPDIR 1: <${1}>"
    echo "  APPDIR after  : <${APPDIR}>"
  }
  fi
  enforce_parameter_with_value 1 APPDIR "${APPDIR}" "Beyond Compare.app"
  if  it_exists_with_spaces "/Applications/${APPDIR}" ; then
  {
    echo Remove installed "/Applications/${APPDIR}"
    sudo rm -rf  "/Applications/${APPDIR}"
    directory_does_not_exist_with_spaces  "/Applications/${APPDIR}"
  }
  fi
  return 0
} # end _remove_dmgs_app_if_exists
function _process_dmgs_dmg_or_zip() {
  # Sample use
  #     _process_dmgs_dmg_or_zip "${extension}" "${DOWNLOADFOLDER}" "${CODENAME}" "${APPDIR}" "${UNZIPDIR}"
  local extension="${1}"
  local DOWNLOADFOLDER="${2}"
  local CODENAME="${3}"
  local APPDIR="${4}"
  [[ -n "${APPDIR}" ]] && APPDIR="$(basename "${4}")"
  local UNZIPDIR="${5}"
  [[ -n "${UNZIPDIR}" ]] && UNZIPDIR="$(basename "${5}")"
  DEBUG=1
  if (( DEBUG )) ; then
  {
    echo "     extension 1: <${1}>"
    echo "DOWNLOADFOLDER 2: <${2}>"
    echo "      CODENAME 3: <${3}>"
    echo "        APPDIR 4: <${4}>"
    echo "  APPDIR after  : <${APPDIR}>"
    echo "      UNZIPDIR 5: <${5}>"
    echo "UNZIPDIR after  : <${UNZIPDIR}>"
  }
  fi
  [[ "${UNZIPDIR}" == "." ]] && UNZIPDIR=""
  enforce_parameter_with_options 1 extension "${extension}" "dmg zip"
  enforce_parameter_with_value 2 DOWNLOADFOLDER "${DOWNLOADFOLDER}" "/Users/user or /home/user"
  enforce_parameter_with_value 3 CODENAME "${CODENAME}" "Beyond Compare or BCompareOSX*.*.*.*.zip"
  enforce_parameter_with_value 4 APPDIR "${APPDIR}" "Beyond Compare.app"
  enforce_parameter_with_value 5 UNZIPDIR "${UNZIPDIR}" "BCompareOSX*.*.*.*.zip"
  if [[ -n "${extension}" ]] && [[ "${extension}"  == "zip" ]] ; then
  {
    echo Unzipping downloaded
    if it_exists_with_spaces "${DOWNLOADFOLDER}/${APPDIR}" ; then
    {
      echo Removing previous found unzipped
      rm -rf "${DOWNLOADFOLDER}/${APPDIR}"
    }
    fi
    cd "${DOWNLOADFOLDER}"
    if unzip "${DOWNLOADFOLDER}/${CODENAME}" ; then
    {
        echo "unzipped "
        pwd
    }
    else
    {
        echo "else unzipped"
        pwd
    }
    fi
    directory_exists_with_spaces "${DOWNLOADFOLDER}/${APPDIR}"
    echo "sudo  cp -R \"${DOWNLOADFOLDER}/${APPDIR}\" \"/Applications/\""
    cp -R "${DOWNLOADFOLDER}/${APPDIR}" "/Applications/"
  }
  else # elif [[ -n "${extension}" ]] && [[ "${extension}"  == "dmg" ]] ; then
  {
    echo Attaching dmg downloaded
    hdiutil attach "${DOWNLOADFOLDER}/${CODENAME}"
    ls "/Volumes"
    directory_exists_with_spaces "/Volumes/${UNZIPDIR}"
    directory_exists_with_spaces "/Volumes/${UNZIPDIR}/${APPDIR}"
    echo "sudo  cp -R \"/Volumes/${UNZIPDIR}/${APPDIR}\" \"/Applications/\""
    cp -R "/Volumes/${UNZIPDIR}/${APPDIR}" "/Applications/"
    hdiutil detach "/Volumes/${UNZIPDIR}"
  }
  fi
  return 0
} # end _process_dmgs_dmg_or_zip

function _trust_dmgs_application() {
  # Sample use
  #  _trust_dmgs_application "${APPDIR}"
  local APPDIR="${1}"
  [[ -n "${APPDIR}" ]] && APPDIR="$(basename "${1}")"
  DEBUG=1
  if (( DEBUG )) ; then
  {
    echo "        APPDIR 1: <${1}>"
    echo "  APPDIR after  : <${APPDIR}>"
  }
  fi
  enforce_parameter_with_value 1 APPDIR "${APPDIR}" "Beyond Compare.app"
  echo  Removing macOS gatekeeper quarantine attribute
  chown  -R $SUDO_USER "/Applications/${APPDIR}"
  chgrp  -R staff "/Applications/${APPDIR}"
  #xattr -d com.apple.quarantine  "/Applications/${APPDIR}"
  return 0
} # end  _trust_dmgs_application

function _install_dmgs_dmg__64() {
  # Sample use
  # local target_name="LittleSnitch-4.6.dmg"
  # local target_app="Little Snitch 4.6/Little Installer.app"
  # local target_url="https://www.obdev.at/ftp/pub/Products/littlesnitch/LittleSnitch-4.6.dmg"
  #  _install_dmgs_dmg__64 "${target_name}" "${target_app}" "${target_url}"
  #
  #  or zip
  #
  # local target_name="BetterTouchTool.zip"
  # local target_app="BetterTouchTool.app"
  # local target_url="https://raw.githubusercontent.com/danielng01/product-builds/master/iris/macos/Iris-1.2.0-OSX.zip"
  # _install_dmgs_dmg__64 "${target_name}" "${target_app}" "${target_url}"
  #
  local CODENAME="${1}"
  local extension="$(echo "${CODENAME}" | rev | cut -d'.' -f 1 | rev)"
  local APPDIR="${2}"
  local TARGET_URL="${3}"
  # CODENAME="$(basename "${TARGET_URL}" )"
  echo "${CODENAME}";
  echo "Extension:${extension}"
  # local VERSION="$(echo -en "${CODENAME}" | sed 's/RubyMine-//g' | sed 's/.dmg//g' )"
  # enforce_variable_with_value VERSION "${VERSION}"
  # local UNZIPDIR="$(echo -en "${CODENAME}" | sed 's/.dmg//g'| sed 's/-//g')"
  # local UNZIPDIR="$(echo -en "${APPDIR}" | sed 's/.app//g')"
  # echo "$(pwd)"
  local UNZIPDIR="$(dirname  "${APPDIR}")"
  local APPDIR="${APPDIR##*/}"    # same as  $(basename "${APPDIR}")
  #local APPDIR=$(basename "${APPDIR}")
  # local APPDIR="$(echo -en "${CODENAME}" | sed 's/.dmg//g'| sed 's/-//g').app"
  # echo "${CODENAME}";
  # echo "${URL}";
  echo "CODENAME: ${CODENAME}"
  enforce_variable_with_value CODENAME "${CODENAME}"
  enforce_variable_with_value TARGET_URL "${TARGET_URL}"
  enforce_variable_with_value USER_HOME "${USER_HOME}"
  echo "UNZIPDIR: ${UNZIPDIR}"
  enforce_variable_with_value UNZIPDIR "${UNZIPDIR}"
  echo "APPDIR: ${APPDIR}"
  enforce_variable_with_value APPDIR "${APPDIR}"
  local DOWNLOADFOLDER="${USER_HOME}/Downloads"
  enforce_variable_with_value DOWNLOADFOLDER "${DOWNLOADFOLDER}"
  directory_exists_with_spaces "${DOWNLOADFOLDER}"

  _do_not_downloadtwice "${TARGET_URL}" "${DOWNLOADFOLDER}"  "${CODENAME}"
  if _remove_dmgs_app_if_exists "${APPDIR}" ; then
  {
    passed ${ORANGE} WARNING! ${YELLOW_OVER_DARKBLUE} failed to remove ${YELLOW_OVER_GRAY241}"${APPDIR}"${RESET}
  }
  fi
  if [[ "${UNZIPDIR}" == '.' ]] ; then
  {
    UNZIPDIR="$(echo -en "${CODENAME}" | sed 's/.zip//g' | sed 's/.dmg//g')"
  }
  fi

  if ( ! _check_size_bigger_than 1000 "${DOWNLOADFOLDER}/${CODENAME}" ) ; then 
  {
    return 0
  }
  fi

  _process_dmgs_dmg_or_zip "${extension}" "${DOWNLOADFOLDER}" "${CODENAME}" "${APPDIR}" "${UNZIPDIR}"

  directory_exists_with_spaces "/Applications/${APPDIR}"
  ls -d "/Applications/${APPDIR}"

  _trust_dmgs_application "${APPDIR}"
  return 0
} # end _install_dmgs_dmg__64

function _check_size_bigger_than() {
  # Sample use 
  #  if ( ! _check_size_bigger_than 1000 "${DOWNLOADFOLDER}/${CODENAME}" ) ; then 
  #  {
  #    return 0
  #  }
  #  fi
  # 
  local -i size=0
  local -i than=${1:1000}
  local _file="${2}"
  enforce_parameter_with_value 2 _file "${_file}" "/home/user/work/filename.html"
  
  size=$(du "${_file}" | cut -d/ -f1)
  if [ ${size} -lt ${than} ] ; then
  {
    nurindatei "${_file}" 404
    echo -e "${RED} 𝞦 SKIPPING ${LIGHTYELLOW} failed to download this one. It seems too small  ${RESET}"
    return 1
  }
  fi
  return 0
} # end _check_size_bigger_than

function _install_dmgs_list(){
  # Sample use
  #
  #     local TARGET_URL
  #     TARGET_URL="VSCode-darwin.zip|Visual Studio Code - Insiders.app|https://code.visualstudio.com/sha/download?build=insider&os=darwin"
  #     enforce_variable_with_value TARGET_URL "${TARGET_URL}"
  #     _install_dmgs_list "${TARGET_URL}"
  # or
  #    local installlist
  #    installlist="
  #      Caffeine.dmg|Caffeine/Caffeine.app|https://github.com/IntelliScape/caffeine/releases/download/1.1.3/Caffeine.dmg
  #      Keybase.dmg|Keybase App/Keybase.app|https://prerelease.keybase.io/Keybase.dmg
  #      Brave-Browser.dmg|Brave Browser/Brave Browser.app|https://referrals.brave.com/latest/Brave-Browser.dmg
  #      Firefox 84.0.2.dmg|Firefox/Firefox.app|https://download-installer.cdn.mozilla.net/pub/firefox/releases/84.0.2/mac/de/Firefox%2084.0.2.dmg
  #      MFF2_latest.dmg|MultiFirefox/MultiFirefox.app|http://mff.s3.amazonaws.com/MFF2_latest.dmg
  #      vlc-3.0.11.dmg|VLC media player/VLC.app|https://download.vlc.de/vlc/macosx/vlc-3.0.11.dmg
  #      mattermost-desktop-4.6.2-mac.dmg|Mattermost 4.6.2.app/Mattermost.app|https://releases.mattermost.com/desktop/4.6.2/mattermost-desktop-4.6.2-mac.dmg
  #      gimp-2.10.22-x86_64-2.dmg|GIMP 2.10 Install/GIMP-2.10.app|https://ftp.lysator.liu.se/pub/gimp/v2.10/osx/gimp-2.10.22-x86_64-2.dmg
  #      sketch-70.3-109109.zip|Sketch.app|https://download.sketch.com/sketch-70.3-109109.zip
  #      Iris-1.2.0-OSX.zip|Iris.app|https://raw.githubusercontent.com/danielng01/product-builds/master/iris/macos/Iris-1.2.0-OSX.zip
  #      BetterTouchTool.zip|BetterTouchTool.app|https://folivora.ai/releases/BetterTouchTool.zip
  #      Options_8.36.76.zip|LogiMgr Installer 8.36.76.app|https://download01.logi.com/web/ftp/pub/techsupport/options/Options_8.36.76.zip
  #      tsetup.2.5.7.dmg|Telegram Desktop/Telegram.app|https://updates.tdesktop.com/tmac/tsetup.2.5.7.dmg
  #      VSCode-darwin.zip|Visual Studio Code.app|https://az764295.vo.msecnd.net/stable/ea3859d4ba2f3e577a159bc91e3074c5d85c0523/VSCode-darwin.zip
  #      VSCode-darwin.zip|Visual Studio Code.app|https://code.visualstudio.com/sha/download?build=stable&os=darwin
  #      VSCode-darwin.zip|Visual Studio Code - Insiders.app|https://az764295.vo.msecnd.net/insider/5a52bc29d5e9bc419077552d336ea26d904299fa/VSCode-darwin.zip
  #      VSCode-darwin.zip|Visual Studio Code - Insiders.app|https://code.visualstudio.com/sha/download?build=insider&os=darwin
  #      BCompareOSX-4.3.7.25118.zip|Beyond Compare.app|https://www.scootersoftware.com/BCompareOSX-4.3.7.25118.zip
  #      dbeaver-ce-7.3.4-macos.dmg|DBeaver Community/DBeaver.app|https://download.dbeaver.com/community/7.3.4/dbeaver-ce-7.3.4-macos.dmg
  #      Inkscape-1.0.2.dmg|Inkscape/Inkscape.app|https://media.inkscape.org/dl/resources/file/Inkscape-1.0.2.dmg
  #      LittleSnitch-4.6.dmg|Little Snitch 4.6/Little Installer.app|https://www.obdev.at/ftp/pub/Products/littlesnitch/LittleSnitch-4.6.dmg
  #    "
  #     _install_dmgs_dmg__64 "${installlist}"
  # Pending how to do pkg automatic?   # 1Password.pkg|https://c.1password.com/dist/1P/mac7/1Password-7.7.pkg
  local installlist one  target_name target_url target_app app_name # extension
  installlist="${*}"
  DEBUG=1
  if (( DEBUG )) ; then
  {
    echo "        installlist 1: <${*}>"
    echo "  installlist after  : <${installlist}>"
  }
  fi
  enforce_parameter_with_value 1 installlist "${installlist}" "
  LittleSnitch-4.6.dmg|Little Snitch 4.6/Little Installer.app|https://www.obdev.at/ftp/pub/Products/littlesnitch/LittleSnitch-4.6.dmg
  BetterTouchTool.zip|BetterTouchTool.app|https://folivora.ai/releases/BetterTouchTool.zip
  "
  Checking dmgs apps
  while read -r one ; do
  {
    if [[ -n "${one}" ]] ; then
    {

      target_name="$(echo "${one}" | cut -d'|' -f1)"
      # extension="$(echo "${target_name}" | rev | cut -d'.' -f 1 | rev)"
      target_app="$(echo "${one}" | cut -d'|' -f2)"
      app_name="$(echo "$(basename "${target_app}")")"
      target_url="$(echo "${one}" | cut -d'|' -f3-)"
      if [[ -n "${target_name}" ]] ; then
      {
        if [[ -n "${target_url}" ]] ; then
        {
          if [[ ! -d "/Applications/${app_name}" ]] ; then
          {
            Installing "${app_name}"
            _install_dmgs_dmg__64 "${target_name}" "${target_app}" "${target_url}"
          }
          else
          {
            passed  "/Applications/${app_name}"  --skipping already installed
          }
          fi
        }
        fi
      }
      fi
    }
    fi
  }
  done <<< "${installlist}"
  return 0
} # end _install_dmgs_list



    #[ ! -z "$0" ] && [ -e "$0" ] && THISSCRIPTNAME=`basename "$0"`

    # TRAP
    #[ ! -z "$0" ] && [   -e "$0" ] &&  trap '{  \" `basename "$0"` KEYBOARD INTERRUPT.\"; exit 69; }' INT
    #[   -z "$0" ] && [ ! -e "$0" ] &&  trap '{  \" STRUCT TESTING KEYBOARD INTERRUPT.\"; exit 69; }' INT
    #[ ! -z "$0" ] && [ ! -e "$0" ] &&  trap '{  \" STRUCT TESTING KEYBOARD INTERRUPT.\"; exit 69; }' INT

        #
        # Template:
        #
        #  echo -e "${GREEN} Installing ${RED}PYENV${GREEN} and ${CYAN} {PYTHON_VERSION}  ${CERO}"
        #
        #  procedure "${PYTHON_VERSION}"  >/dev/null 2>&1 # suppress stdln and errln output
        #
        #  Testing Checking install
        #  FOLDER MUST EXIST  /home/vagrant/.pyenv
        #  LINK MUST EXIST /root/.pyenv
        #  Python Must be PYTHON VERSION
        #
        #  directory_exists "/home/vagrant/.pyenv"
        #  file_exists "/home/vagrant/.zshrc"
        #  softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
        #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
        #
        #  CURRENT_VERSION=$(cat /home/vagrant/.pyenv/version)
        #  check_equality "${CURRENT_VERSION}=${PYTHON_VERSION}"

        #  echo -e " END ${THISSCRIPTNAME} ${CERO}"
        #  echo -e "${RED}  END ${THISSCRIPTNAME} ${CERO}"
        #  echo -e " END ${THISSCRIPTNAME} ${CERO}"

#
# STRUCT TESTING - END
#

   ##                    ######## ##    ## ########
  ##                     ##       ###   ## ##     ##
 ##                      ##       ####  ## ##     ##
##    ####### #######    ######   ## ## ## ##     ##
 ##                      ##       ##  #### ##     ##
  ##                     ##       ##   ### ##     ##
   ##                    ######## ##    ## ########

 ######  ######## ########  ##     ##  ######  ########
##    ##    ##    ##     ## ##     ## ##    ##    ##
##          ##    ##     ## ##     ## ##          ##
 ######     ##    ########  ##     ## ##          ##
      ##    ##    ##   ##   ##     ## ##          ##
##    ##    ##    ##    ##  ##     ## ##    ##    ##
 ######     ##    ##     ##  #######   ######     ##

######## ########  ######  ######## #### ##    ##  ######
   ##    ##       ##    ##    ##     ##  ###   ## ##    ##
   ##    ##       ##          ##     ##  ####  ## ##
   ##    ######    ######     ##     ##  ## ## ## ##   ####
   ##    ##             ##    ##     ##  ##  #### ##    ##
   ##    ##       ##    ##    ##     ##  ##   ### ##    ##
   ##    ########  ######     ##    #### ##    ##  ######
