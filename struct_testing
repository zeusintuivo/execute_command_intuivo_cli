#!/usr/bin/env bash
#!/bin/bash
#
# @author Zeus Intuivo <zeus@intuivo.com>
#
#
# Helper For testing installations, check files, softlinks, etc......checklist style

# Sample use

function sample_use_verify_mongo() {


    MONGO_VERSION="3.0.11"
    if [ ! -z "${1}" ] ;  then
        MONGO_VERSION="${1}"
    fi

    echo -e "${GREEN} Verify mongo version"
    CURRENT_VERSION=$(mongo --version  | egrep "MongoDB shell version" | head -1  | cut -d' ' -f4 | cut -d'v' -f2)
    check_equality "${CURRENT_VERSION}=${MONGO_VERSION}"
    echo -e "${GREEN} Verify mongod version"
    MONGOD_VERSION=$(mongod --version | egrep "db version" | head -1 | cut -d'v' -f3)
    check_equality "${MONGOD_VERSION}=${MONGO_VERSION}"

    TESTING=" verify that MongoDB has started ${CYAN}successfully${LIGHTYELLOW}"
    if [ ! -z "${MONGO_PID}" ] && [ ! -z "${MONGO_TASKID}" ] && [[ "${MONGO_SERVICE_STATUS}" == *"mongod start/running"* ]] ; then
    {

        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}       Service Status: ${CYAN}${MONGO_SERVICE_STATUS} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}            Mongo PID: ${CYAN}${MONGO_PID} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}        Mongo Task ID: ${CYAN}${MONGO_TASKID} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}      Which Mongo cli: ${CYAN}${WHICH_MONGO} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}        Mongo version: ${CYAN}${CURRENT_VERSION} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}   Which Mongo Server: ${CYAN}${WHICH_MONGOD} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW} Mongo Server version: ${CYAN}${MONGOD_VERSION} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}     Log last 4 lines: ${CYAN}${MONGO_LOG} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}     hugepage/enabled: ${CYAN}${FILE_CONTENTS_ENABLED} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}      hugepage/defrag: ${CYAN}${FILE_CONTENTS_DEFRAG} "
        passed "${TESTING}"

    }
    else
    {
        failed "${TESTING}"
    }
    fi

    directory_exists "
    /data
    /data/db
    /var/log/mongodb
    "

    # Disabled
    #/_/version-manager                             # Patch mongoo-manager form nodejs
    #/home/vagrant/.mongodb
    #softlink_exists "/root/.mongodb>/home/vagrant/.mongodb"

    file_exists "/etc/mongod.conf
    /etc/init/mongod.conf
    /etc/sysfs.conf
    /etc/mongo_vm_settings.conf
    /sys/kernel/mm/transparent_hugepage/khugepaged/defrag
    /sys/kernel/mm/transparent_hugepage/defrag
    /sys/kernel/mm/transparent_hugepage/enabled
    "
    # Extra notes
    # /etc/init/mongod.conf                           # This is the mongo service start|stop|status
    # /etc/default/mongod                             # There is ref to this file inside the service /etc/init/mongod.conf

    # Disabled
    #/etc/systemd/system/mongodb-hugepage-fix.service # service systemd  16.04
    #/etc/systemd/system/mongodb.service              # service systemd  16.04
    #/_/version-manager/bin/m.js                      # Patch mongoo-manager form nodejs
    #/_/version-manager/package.json                  # Patch mongoo-manager form nodejs

    #  softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
    #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
    #

}
# end function sample_use_verify_mongo

function HOW_TO_LOAD_SEVERAL_FILES() {

    load_execute_commands_wget() {
        local URL=""
        local cached_directory="$HOME$HOME/_/clis/execute_command_intuivo_cli/"
        local EXECOMCLI=""
        local provider=""
        [   -d "${cached_directory}" ] &&  provider="file://${cached_directory}"
        [ ! -d "${cached_directory}" ] &&  provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/"
        local BASH_SCRIPTS="
    struct_testing
    execute_command
    "
    #execute_command
        while read -r ONE_SCRIPT; do
        {
            if [ -n "${ONE_SCRIPT}" ] ; then         # if not empty
            {
                URL="${provider}${ONE_SCRIPT}"
                [   -d "${cached_directory}" ] && source "$URL"
                [ ! -d "${cached_directory}" ] &&eval """$(wget --quiet --no-check-certificate $URL  -O -  2>/dev/null )"""   # suppress only wget download messages, but keep wget output for variable
                echo "$URL Loaded"
            }
            fi
        }
        done <<< "${BASH_SCRIPTS}"
        unset URL
        unset EXECOMCLI
        unset ONE_SCRIPT
        unset BASH_SCRIPTS
        unset provider
        ( ( ! command -v type passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    }
    # end load_execute_commands_wget
    load_execute_commands_wget

    load_execute_commands_curl() {
        local URL=""
        local EXECOMCLI=""
        local cached_directory="$HOME$HOME/_/clis/execute_command_intuivo_cli/"
        local provider=""
        [   -d "${cached_directory}" ] &&  provider="file://${cached_directory}"
        [ ! -d "${cached_directory}" ] &&  provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/"
        local BASH_SCRIPTS="
    struct_testing
    execute_command
    "
    #execute_command
        while read -r ONE_SCRIPT; do
        {
            if [ ! -z "${ONE_SCRIPT}" ] ; then         # if not empty
            {
                URL="${provider}${ONE_SCRIPT}"
                eval """$(curl $URL  2>/dev/null )"""  # suppress only curl download messages, but keep curl output for variable
                echo "$URL Loaded"
            }
            fi
        }
        done <<< "${BASH_SCRIPTS}"
        unset URL
        unset EXECOMCLI
        unset ONE_SCRIPT
        unset BASH_SCRIPTS
        unset provider
        ( ( ! command -v type passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    }
    # end load_execute_commands_curl
    load_execute_commands_curl

}
# end function HOW_TO_LOAD_SEVERAL_FILES

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_EXECUTE_COMMAND() {

    #Sample short call for loading execute command
    load_execute_command_curl() {
        local provider="file://$HOME$HOME/_/clis/execute_command_intuivo_cli/execute_command"
        [ ! -d "$HOME$HOME/_/clis/execute_command_intuivo_cli/" ] && provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/execute_command"
        local EXECOMCLI=$(curl $provider  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading execute_command \n \n " && exit 69; )
    }
    # end load_struct_testing_curl
    load_struct_testing_curl
}
# end HOW_TO_LOAD_JUST_ONE_SCRIPT_EXECUTE_COMMAND

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL() {

    #Sample short call for loading struct_testing
    load_struct_testing_curl() {
        local provider="file://$HOME$HOME/_/clis/execute_command_intuivo_cli/struct_testing"
        [ ! -d "$HOME$HOME/_/clis/execute_command_intuivo_cli/" ] && provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing"
        local EXECOMCLI=$(curl $provider  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    }
    # end load_struct_testing_curl
    load_struct_testing_curl

}
# end HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_WGET() {

    #Sample short call for loading struct_testing
    load_struct_testing_wget() {
        local provider="$HOME$HOME/_/clis/execute_command_intuivo_cli/struct_testing"
        [   -e "${provider}"  ] && source "${provider}"
        [ ! -e "${provider}"  ] && eval """$(wget --quiet --no-check-certificate  https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing -O -  2>/dev/null )"""   # suppress only wget download messages, but keep wget output for variable
        ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    }
    # end load_struct_testing_wget
    load_struct_testing_wget

}
# end HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_WGET

function HOW_TO_LOAD_JUST_ONE_SCRIPT_ONLINE_ALWAYS_STRUCT_USING_WGET() {

    load_struct_testing_wget() {
        # HOW TO LOAD JUST ONE SCRIPT
        EXECOMCLI=$(wget --quiet --no-check-certificate https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing -O -  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v type passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    }
    # end load_struct_testing_wget
    load_struct_testing_wget

}
# end HOW_TO_LOAD_JUST_ONE_SCRIPT_ONLINE_ALWAYS_STRUCT_USING_WGET





 ######  ######## ########  ##     ##  ######  ########
##    ##    ##    ##     ## ##     ## ##    ##    ##
##          ##    ##     ## ##     ## ##          ##
 ######     ##    ########  ##     ## ##          ##
      ##    ##    ##   ##   ##     ## ##          ##
##    ##    ##    ##    ##  ##     ## ##    ##    ##
 ######     ##    ##     ##  #######   ######     ##

######## ########  ######  ######## #### ##    ##  ######
   ##    ##       ##    ##    ##     ##  ###   ## ##    ##
   ##    ##       ##          ##     ##  ####  ## ##
   ##    ######    ######     ##     ##  ## ## ## ##   ####
   ##    ##             ##    ##     ##  ##  #### ##    ##
   ##    ##       ##    ##    ##     ##  ##   ### ##    ##
   ##    ########  ######     ##    #### ##    ##  ######

 ######  ########    ###    ########  ########                    ##
##    ##    ##      ## ##   ##     ##    ##                        ##
##          ##     ##   ##  ##     ##    ##                         ##
 ######     ##    ##     ## ########     ##       ####### #######    ##
      ##    ##    ######### ##   ##      ##                         ##
##    ##    ##    ##     ## ##    ##     ##                        ##
 ######     ##    ##     ## ##     ##    ##                       ##


#
# STRUCT TESTING - START
#

RED="\033[01;31m"
#RED="\033[38;5;1m"
ORANGE="\033[38;5;202m"

WHITE="\033[38;5;15m"
WHITEBOLD="\033[01;37m"
YELLOW="\033[01;33m"
YELLOW226="\033[38;5;226m"


GRAY="\033[38;5;8m"
GRAY241="\033[38;5;241m"
GRAYEDOUT="\033[01;30m"

GREEN="\033[01;32m"
LIGHTGREEN="\033[38;5;83m"
LIGHTPINK="\033[1;204m"
LIGHTYELLOW="\033[38;5;227m"


CYAN="\033[01;36m"
PURPLE="\033[01;35m"
DARKBLUE="\033[01;34m"
PURPLE_BLUE="\033[38;5;93m"
BRIGHT_BLUE87="\033[38;5;87m"

YELLOW_OVER_DARKBLUE="\033[38;5;220m\033[48;5;20m"
YELLOW_OVER_DARKBLUE2="\033[38;5;11m\033[48;5;18m"

RESET="\033[0m"
CERO="\033[01;0m"

        function passed() {
            ARGS="${@}"
            if [ ! -z "${ARGS-x}" ] ; then # if its set and not empty
            {
                echo -e "${LIGHTGREEN} âœ” ${LIGHTYELLOW} ${ARGS}  ${RESET}"
            }
            fi
        }
        function kill_execution() {
            echo -e " â˜  ${LIGHTPINK} KILL EXECUTION SIGNAL SEND ${RESET}"
            exit 69;
        }

        function warning() {
            ARGS="${@}"
            if [[ ! -z "${ARGS-x}" ]] ; then # if its set and not empty
            {
                # echo -e "${BRIGHT_BLUE87} ${BASH_SOURCE}:${BASH_LINENO[0]} ${FUNCNAME[0]}()"
                # echo -e "${BRIGHT_BLUE87} ${BASH_SOURCE}:${BASH_LINENO[-1]} ${FUNCNAME[-1]}()"
                local len="${#BASH_LINENO[@]}"
                for (( i=0; i<$len; i++ )); do
                    echo -e "${BRIGHT_BLUE87} ${BASH_SOURCE[$i]}:${BASH_LINENO[$i]} ${FUNCNAME[$i]}()"
                done
                echo -e "$0:${BASH_LINENO[1]} ${FUNCNAME[1]}()"
                echo -e "${RED} ðž¦ ${LIGHTYELLOW} ${ARGS} ${RESET}"
            }
            fi
        }

        function failed() {
            warning "${@}  ${RED} has failed! "
            kill_execution
        }

        function assert() {
            # Sample usage
            #
            #     assert not empty "${SUBLIMEDEVLASTESTBUILD}"
            #     assert not empty "${SUBLIMEDEVLASTESTBUILD}"
            #     /home/vagrant/.pyenv"
            #
            #    0     1    2    3
            # assert not empty $VALUE
            if [  -z "${1+x}" ] || [ -z "${2+x}" ] || [ -z "${3+x}" ] ; then # check if all parameters are set and not empty
            {
                failed ${FUNCNAME[1]} requires to have 3 parameters :: ${FUNCNAME[1]} not empty \$VALUE ::
            }
            fi
            local not="${1}"
            local empty="${2}"
            local value="${3}"
            TESTING="${FUNCNAME[0]} that value ${CYAN}${value}${LIGHTYELLOW} is not empty"
            if [[ ! -z "${value+x}" ]] ; then
            {
                passed "${TESTING}"
            }
            else
            {
                failed "${TESTING}"
            }
            fi

        }
        # end assert

        testself_assert() {
            assert not empty "hola"
        }
        #testself_assert  >/dev/null 2>&1 # suppress stdln and errln output

        function enhance_message() {
            local msg=""
            [[ ! -z "${1+x}"  ]] && msg="${1}"  ;  # check if a variable is set and not empty and reassign value
            msg=$(echo "${msg}" | sed  -e 's/ancel /anceling /g')
            msg=$(echo "${msg}" | sed  -e 's/uit /uiting /g')
            msg=$(echo "${msg}" | sed  -e 's/xit /xiting /g')
            echo "${msg}"
            [[ "${msg}" == *"anceling "* ]] && exit 69
            [[ "${msg}" == *"uiting "* ]] && exit 69
            [[ "${msg}" == *"xiting "* ]] && exit 69
        } # end enhance_message

        function ensure() {
            # Sample usage:
            # assuming mongo bin is in your path
            #            ensure mongo or " Cancel export"
            #            ensure mongoexport or " Cancel export"
            #            ensure bsondump or " Cancel export"
            #
            TESTING="that command ${CYAN}${1}${LIGHTYELLOW} exists in the path or can be reached from command line."
            if ! command -v "${1}" >/dev/null 2>&1;  then # Command Does not-exist
            {
              failed "${TESTING}"
              [[ ! -z "${3+x}"  ]] && enhance_message "${3}"
              return 1
            }
            else
            {
              passed "${TESTING}"
              return 0
            }
            fi
        } # end ensure

        function Installing() {
            echo -e "${GREEN} Installing ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Installing
        alias installing=Installing


        function Testing() {
            echo -e "${GRAY} Testing ${PURPLE}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Testing
        alias testing=Testing


        function Configuring() {
            echo -e "${GREEN} Configuring ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Configuring

        alias configuring=Configuring

        function Setting() {
            echo -e "${GREEN} Setting ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Setting

        alias setting=Setting

        function Final() {
            echo -e "${GREEN} Setting ${RED}${1}${GREEN}, ${RED}${2} ${GREEN}${3} ${CYAN}${4}, ${RED}${5} ${GREEN}${6} ${CYAN}${*:7} ${GREEN}.${RESET}"
        } # end Final

        function Showing() {
            echo -e "${ORANGE} Ã¸  ${PURPLE}${1}${ORANGE} ${CYAN}${2} ${DARKBLUE}${3} ${PURPLE_BLUE}${4} ${BRIGHT_BLUE87}${5} ${GREEN}${6} ${RED}${*:7} ${GREEN}.${RESET}"
            "${@}"
        } # end Showing

        alias showing=Showing

        function Message() {
            local msg1="$1"
            local msg2=$(echo "$*" | cÃ¼t "$1")
            echo  -e "${PURPLE}${PURPLE}+---${LIGHTYELLOW} ${LIGHTYELLOW} ${msg1} ${CYAN} ${msg2} ${RESET}"
        }
        alias message=Message

        function not() {
            local order="empty"  # Tasjgjgggg
            if [[ ! -z "${1+x}"  ]] ; then  # check if a variable is set and not empty
                NODE_VERSION="${1}"
            fi
        } # end not

        function directory_exists() {
            # Sample usage
            #
            #     directory_exists "/home/vagrant/.pyenv"
            #     directory_exists "/root/.pyenv
            #     /home/vagrant/.pyenv"
            #
            local _TESTING _ONE_DIR _DIRS="${@}"
            if [ ! -z "${DIRS-x}" ] ; then # if its set and not empty
            {
                _DIRS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r _ONE_DIR; do
                # if not empty
                if [ ! -z "${_ONE_DIR}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # _ONE_DIR="/Users/administrator/.pyenv"
                    _TESTING="that directory ${CYAN}${_ONE_DIR}${LIGHTYELLOW} exists"
                    if [[ -d "${_ONE_DIR}" && ! -L "${_ONE_DIR}" ]] ; then
                    {
                        passed "${_TESTING}"
                    }
                    else
                    {
                        failed "${_TESTING}"
                    }
                    fi
                fi
                done <<< "${_DIRS}"
            }
            fi
        } # end directory_exists

        function directory_exists_with_spaces() {
            # Sample usage
            #
            #     directory_exists_with_spaces "/Applications/Google Chrome.app/"
            #     directory_exists_with_spaces "/Applications/Google\ Chrome.app/"
            #
            local _TESTING _ONE_DIR="${*}"
            if [ ! -z "${_ONE_DIR-x}" ] ; then # if its set and not empty
            {
                # if not empty
                if [ ! -z "${_ONE_DIR}" ] ; then
                {
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # _ONE_DIR="/Users/administrator/.pyenv"
                    _TESTING="that directory ${CYAN}${_ONE_DIR}${LIGHTYELLOW} exists"
                    if [[ -d "${_ONE_DIR}" && ! -L "${_ONE_DIR}" ]] ; then
                    {
                        passed "${_TESTING}"
                        return 0
                    }
                    else
                    {
                        failed "${_TESTING}"
                        return 1
                    }
                    fi
                }
                fi

            }
            fi
        } # end directory_exists_with_spaces

        function does_not_exist() {
            # Sample usage
            #
            #     does_not_exist "/home/vagrant/.pyenv"
            #     does_not_exist "/root/.pyenv
            #     /home/vagrant/.pyenv"
            #
            local _TESTING _ONE_DIR  _DIRS="${@}"
            if [ ! -z "${_DIRS-x}" ] ; then # if its set and not empty
            {
                _DIRS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r _ONE_DIR; do
                # if not empty
                if [ ! -z "${_ONE_DIR}" ] ; then
                {
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # _ONE_DIR="/Users/administrator/.pyenv"
                    _TESTING="that ${CYAN}${_ONE_DIR}${LIGHTYELLOW} does not exist"
                    if [[ ! -e "${_ONE_DIR}" ]] ; then
                    {
                        passed "${_TESTING}"
                    }
                    else
                    {
                        failed "${_TESTING}"
                    }
                    fi
                }
                fi
                done <<< "${_DIRS}"
            }
            fi
        } # end does_not_exist

        function does_not_exist_with_spaces() {
            # Sample usage
            #
            #     does_not_exist_with_spaces "/Applications/Google\ Chrome.app/"
            #     does_not_exist_with_spaces "/Applications/Google Chrome.app/"
            #
            local _TESTING _ONE_DIR="${*}"
            if [ ! -z "${_ONE_DIR-x}" ] ; then # if its set and not empty
            {
                # if not empty
                if [ ! -z "${_ONE_DIR}" ] ; then
                {
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # _ONE_DIR="/Users/administrator/.pyenv"
                    _TESTING="that ${CYAN}${_ONE_DIR}${LIGHTYELLOW} does not exist"
                    if [[ ! -e "${_ONE_DIR}" ]] ; then
                    {
                        passed "${_TESTING}"
                    }
                    else
                    {
                        failed "${_TESTING}"
                    }
                    fi
                }
                fi
            }
            fi
        } # end does_not_exist_with_spaces

        function directory_does_not_exist() {
            does_not_exist $@
        } # end directory_does_not_exist

        function directory_does_not_exist_with_spaces() {
            does_not_exist_with_spaces "${*}"
        } # end directory_does_not_exist_with_spaces

        function file_does_not_exists() {
            does_not_exist $@
        } # end file_does_not_exists

        function file_does_not_exist() {
            does_not_exist $@
        } # end file_does_not_exist

        function file_does_not_exist_with_spaces() {
            does_not_exist_with_spaces "${*}"
        } # end file_does_not_exist_with_spaces


        function it_exists() {
            # Sample usage
            #
            #          if  ! it_exists "/home/vagrant/.zshrc" ; then    is like is NOT installed
            #          if  it_exists "/root/.zshrc ; then      it makes more sense to make it this way
            #
            local ONE_FILE FILES="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
	    {
                FILES=$(switch_spaces_to_newlines <<< "${@}")
                echo testing $FILES
		while read -r ONE_FILE; do
                # if not empty
		echo testing $ONE_FILE
		# echo $ONE_FILE | hexdump -c
		ONE_FILE=$(trim_end_newlines <<< $ONE_FILE)
			# echo $ONE_FILE | hexdump -c
                if [ ! -z "${ONE_FILE}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.zshrc <-- will fail always
                    # But /home/user/.zshrc  <-- will pass
                    # OR Users/administrator/.zshrc  in mac <-- will pass
                    # ONE_FILE="/Users/administrator/.zshrc"
                    if [[ -s "${ONE_FILE}" && ! -L "${ONE_FILE}" ]] ; then
                    {
		      unset FILES
		      unset ONE_FILE
                      return 0 # it exists
                    }
                    fi
                fi
                done <<< "${FILES}"
		unset FILES
		unset ONE_FILE
                return 1 # it does not exists
            }
            fi
	    unset FILES
	    unset ONE_FILE

        } # end it_exists

        function it_exists_with_spaces() {
            # Sample usage
            #
            #          if  ! it_exists_with_spaces "/home/vagrant/.zshrc" ; then    is like is NOT installed
            #          if  it_exists_with_spaces "/root/.zshrc ; then      it makes more sense to make it this way
            #
            local ONE_FILE FILES="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FILE; do
                # if not empty
                # DEBUG echo -e "${BASH_SOURCE[0]} ->\n  .. ${FUNCNAME[0]}():${ONE_FILE}"
                if [ ! -z "${ONE_FILE}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.zshrc <-- will fail always
                    # But /home/user/.zshrc  <-- will pass
                    # OR Users/administrator/.zshrc  in mac <-- will pass
                    # ONE_FILE="/Users/administrator/.zshrc"
                    if [[ -e "${ONE_FILE}" ]] ; then
                    {
                        return 0 # it exists
                    }
                    fi
                fi
                done <<< "${FILES}"
                return 1 # it does not exists
            }
            fi
        } # end it_exists_with_spaces
        function it_does_not_exist_with_spaces() {
            # Sample usage
            #
            #          if  ! it_exists_with_spaces "/home/vagrant/.zshrc" ; then    is like is NOT installed
            #          if  it_exists_with_spaces "/root/.zshrc ; then      it makes more sense to make it this way
            #
            local ONE_FILE FILES="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FILE; do
                # if not empty
                # DEBUG echo -e "${BASH_SOURCE[0]} ->\n  .. ${FUNCNAME[0]}():${ONE_FILE}"
                if [ ! -z "${ONE_FILE}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.zshrc <-- will fail always
                    # But /home/user/.zshrc  <-- will pass
                    # OR Users/administrator/.zshrc  in mac <-- will pass
                    # ONE_FILE="/Users/administrator/.zshrc"
                    if [[ -e "${ONE_FILE}" ]] ; then
                    {
                        return 1 # it exists
                    }
                    fi
                fi
                done <<< "${FILES}"
                return 0 # it does not exists
            }
            fi
        } # end it_exists_with_spaces
        function file_exists() {
            # Sample usage
            #
            #     file_exists "/home/vagrant/.zshrc"
            #     file_exists "/root/.zshrc
            #     /home/vagrant/.pyenzshrcv"
            #
            local TESTING ONE_FILE FILES="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                FILES=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_FILE; do
                if [ ! -z "${ONE_FILE}" ] ; then # if not empty
                    TESTING="that file ${CYAN}${ONE_FILE}${LIGHTYELLOW} exists"
		    echo -e $TESTING
                    if it_exists "${ONE_FILE}" ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${FILES}"
            }
            fi
	    unset ONE_FILE
	    unset FILES
	    unset TESTING
        } # end file_exists

        function file_exists_with_spaces() {
            # Sample usage
            #
            #     file_exists_with_spaces "/home/vagrant/.zshrc"
            #     file_exists_with_spaces "/root/.zshrc
            #     /home/vagrant/.pyenzshrcv"
            #
            local ONE_FILE FILES="${*}"
            # DEBUG echo -e "${BASH_SOURCE[0]} ->\n  .. ${FUNCNAME[0]}():$FILES"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FILE; do
                if [ ! -z "${ONE_FILE}" ] ; then # if not empty
                    TESTING="that file ${CYAN}${ONE_FILE}${LIGHTYELLOW} exists"
                    # DEBUG echo -e "${BASH_SOURCE[0]} ->\n  .. ${FUNCNAME[0]}():$ONE_FILE"
                    if it_exists_with_spaces "${ONE_FILE}" ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${FILES}"
            }
            fi
        } # end file_exists_with_spaces

        function softlink_exists() {
            # Sample usage
            #
            #     softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
            #     softlink_exists "/Users/administrator/.nix-profile
            #     /Users/administrator/.nix-profile>/nix/var/nix/profiles/default"
            #     softlink_exists "/root/.pyenv"
            #     softlink_exists "/root/.pyenv
            #     /root/.pyenv>/home/vagrant/.pyenv"
            #
            local FOUND_LINK_TARGET ONE_LINK_ORDER _LINKS="${@}"
            if [ ! -z "${_LINKS-x}" ] ; then # if its set and not empty
            {
                _LINKS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_LINK_ORDER; do
                    # if not empty
                    if [ ! -z "${ONE_LINK_ORDER}" ] ; then
                    {
                        local CHECK_TARGET_TOO="NO"
                        local ONE_LINK_LOCATION="${ONE_LINK_ORDER}"
                        local ONE_LINK_TARGET=""

                        [[ "${ONE_LINK_ORDER}" == *">"* ]] && CHECK_TARGET_TOO="YES"
                        if [[ "${CHECK_TARGET_TOO}" == "YES" ]] ; then
                        {
                            ONE_LINK_LOCATION=$(cut -d'>' -f1 <<< "${ONE_LINK_ORDER}")
                            ONE_LINK_TARGET=$(cut -d'>' -f2 <<< "${ONE_LINK_ORDER}")
                        }
                        fi
                        # AS a NOTE ~/  <-- will fail always
                        # SO ~/.pyenv <-- will fail always
                        # But /home/user/.pyenv  <-- will pass
                        # OR Users/administrator/.pyenv  in mac <-- will pass
                        # ONE_LINK_LOCATION="/Users/administrator/.nix-profile"
                        local TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} exists"
                        if [[ -L "${ONE_LINK_LOCATION}" ]] ; then
                        {
                            # is a softlink
                            passed "${TESTING}"

                            # Test pointing
                            if [[ "${CHECK_TARGET_TOO}" == "YES" && ! -z "${ONE_LINK_TARGET}" ]] ; then
                            {
                                TESTING="${PURPLE} +-- and that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} points to ${CYAN}${ONE_LINK_TARGET}${GREEN} location \n"
                                FOUND_LINK_TARGET=$(ls -l ${ONE_LINK_LOCATION} | awk '{print $11}') # Find target symlink
                                if [[ "${FOUND_LINK_TARGET}" == "${ONE_LINK_TARGET}" ]] ; then
                                {
                                    # points to right location
                                    passed "${TESTING}"

                                    TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} is not broken"
                                    local empty_means_not_broken=$(find ${ONE_LINK_LOCATION} -type l ! -exec test -e {} \; -print  2>&1 | xargs -I {} ls -la "{}")
                                    if [[ -z "${empty_means_not_broken}" ]] ; then
                                    {
                                        # points to right location
                                        TESTING=""
                                        passed "${TESTING}"
                                    }
                                    elif  [[ "${empty_means_not_broken}" == *"No such file or directory"* ]] ; then
                                    {
                                        TESTING="but softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} is was not created"
                                        failed "${TESTING}"
                                    }
                                    elif  [[ "${empty_means_not_broken}" == *"Permission denied"* ]] ; then
                                    {
                                        TESTING="but softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW}. Permission denied. Check Target -> ${ONE_LINK_TARGET} is accesible."
                                        failed "${TESTING}"
                                    } else {
                                        failed "${TESTING}"
                                    }
                                    fi
                                }
                                else
                                {
                                    TESTING+="${GREEN}     +++ expected${LIGHTYELLOW}:${CYAN}${ONE_LINK_TARGET}${LIGHTYELLOW}:${RED} --- actual${LIGHTYELLOW}:${RED}${FOUND_LINK_TARGET}${LIGHTYELLOW}:"
                                    failed "${TESTING}"
                                }
                                fi
                            }
                            fi # TACHECK_TARGET_TOO is correct

                        }
                        else
                        {
                            failed "${TESTING}"
                        }
                        fi # ONE_LINK_LOCATION Exists
                    }
                    fi # not empty one link
                done <<< "${_LINKS}"
            }
            fi # not empty links
        } # end softlink_exists

        function ensure_unlink() {
            if [ -s """${*}""" ] ; then
             unlink """${*}"""
            fi
        } # end ensure_unlink

        function ensure_rmdir() {
            if [ -d """${*}""" ] ; then
                rm -rf """${*}"""
            fi
        } # end ensure_rmdir

        function softlink_exists_with_spaces() {
            # Sample usage
            #
            #     softlink_exists_with_spaces "/Applications/Google\ Chrome.app/Contents/Profile/NativeMessagingHosts"
            #     softlink_exists_with_spaces "~/Library/Application\ Support/Google/Chrome/NativeMessagingHosts"
            #
            local FOUND_LINK_TARGET ONE_LINK_ORDER _LINKS="${*}"
            if [ ! -z "${_LINKS-x}" ] ; then # if its set and not empty
            {
                ONE_LINK_ORDER="${_LINKS}"
                    # if not empty
                    if [ ! -z "${ONE_LINK_ORDER}" ] ; then
                    {
                        local CHECK_TARGET_TOO="NO"
                        local ONE_LINK_LOCATION="${ONE_LINK_ORDER}"
                        local ONE_LINK_TARGET=""

                        [[ "${ONE_LINK_ORDER}" == *">"* ]] && CHECK_TARGET_TOO="YES"
                        if [[ "${CHECK_TARGET_TOO}" == "YES" ]] ; then
                        {
                            ONE_LINK_LOCATION=$(cut -d'>' -f1 <<< "${ONE_LINK_ORDER}")
                            ONE_LINK_TARGET=$(cut -d'>' -f2 <<< "${ONE_LINK_ORDER}")
                        }
                        fi
                        passed "${ONE_LINK_ORDER}"
                        # AS a NOTE ~/  <-- will fail always
                        # SO ~/.pyenv <-- will fail always
                        # But /home/user/.pyenv  <-- will pass
                        # OR Users/administrator/.pyenv  in mac <-- will pass
                        # ONE_LINK_LOCATION="/Users/administrator/.nix-profile"
                        local TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} exists"
                        if [[ -L "${ONE_LINK_LOCATION}" ]] ; then
                        {
                            # is a softlink
                            passed "${TESTING}"

                            # Test pointing
                            if [[ "${CHECK_TARGET_TOO}" == "YES" && ! -z "${ONE_LINK_TARGET}" ]] ; then
                            {
                                TESTING="${PURPLE} +-- and that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} points to ${CYAN}${ONE_LINK_TARGET}${GREEN} location \n"
                                FOUND_LINK_TARGET=$(ls -l ${ONE_LINK_LOCATION} | cut -d'>' -f2 | trim) # Find target symlink
                                if [[ "${FOUND_LINK_TARGET}" == "${ONE_LINK_TARGET}" ]] ; then
                                {
                                    # points to right location
                                    passed "${TESTING}"

                                    TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} is not broken"
                                    local empty_means_not_broken=$(find ${ONE_LINK_LOCATION} -type l ! -exec test -e {} \; -print  2>&1 | xargs -I {} ls -la "{}")
                                    if [[ -z "${empty_means_not_broken}" ]] ; then
                                    {
                                        # points to right location
                                        TESTING=""
                                        passed "${TESTING}"
                                    }
                                    elif  [[ "${empty_means_not_broken}" == *"No such file or directory"* ]] ; then
                                    {
                                        TESTING="but softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} is was not created"
                                        failed "${TESTING}"
                                        return 1
                                    }
                                    elif  [[ "${empty_means_not_broken}" == *"Permission denied"* ]] ; then
                                    {
                                        TESTING="but softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW}. Permission denied. Check Target -> ${ONE_LINK_TARGET} is accesible."
                                        failed "${TESTING}"
                                        return 1
                                    } else {
                                        failed "${TESTING}"
                                        return 1
                                    }
                                    fi
                                }
                                else
                                {
                                    TESTING+="${GREEN}     +++ expected${LIGHTYELLOW}:${CYAN}${ONE_LINK_TARGET}${LIGHTYELLOW}:${RED}${RESET} --- actual:${FOUND_LINK_TARGET}:"
                                    failed "${TESTING}"
                                    return 1
                                }
                                fi
                            }
                            fi # TACHECK_TARGET_TOO is correct

                        }
                        else
                        {
                            failed "${TESTING}"
                            return 1
                        }
                        fi # ONE_LINK_LOCATION Exists
                    }
                    fi # not empty one link

            }
            fi # not empty links
            return 0
        } # end softlink_exists_with_spaces

        function check_equality() {
            # Sample usage
            #
	    #     check_equality "1=1"
            #     check_equality "$(cat /home/vagrant/.pyenv/version)=${PYTHON_VERSION}
            #                     $(cat /home/vagrant/.pyenv/version)=2.7.11"
            #
            #     check_equality $(cat ~/.pyenv/version)="2.7.11"
            #
            local ARGS="${@}"
            local LEFT_VALUE=""
            local RIGHT_VALUE=""
            local ONE_EQUALITY_ORDER=""
            if [ ! -z "${ARGS-x}" ] ; then # if its set and not empty
            {
                #ARGS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_EQUALITY_ORDER; do
                    # if not empty
                    if [ ! -z "${ONE_EQUALITY_ORDER}" ] ; then
                    {
                        LEFT_VALUE=$(echo """${ONE_EQUALITY_ORDER}""" | cut -d'=' -f1 | trim)
                        RIGHT_VALUE=$(echo """${ONE_EQUALITY_ORDER}""" | cut -d'=' -f2 | trim)

                        local TESTING="that value left value: ${CYAN}${LEFT_VALUE}${LIGHTYELLOW} exists"
                        if [[ -z "${LEFT_VALUE-x}" ]] ; then
                        {
                            failed "${TESTING}"
                        }
                        fi

                        TESTING="that value right value: ${CYAN}${RIGHT_VALUE}${LIGHTYELLOW} exists"
                        if [[ -z "${RIGHT_VALUE-x}" ]] ; then
                        {
                            failed "${TESTING}"
                        }
                        fi

                        TESTING="that expected:${YELLOW_OVER_DARKBLUE}${RIGHT_VALUE}${RESET}${LIGHTYELLOW}: is equal to actual:${YELLOW_OVER_DARKBLUE}${LEFT_VALUE}${RESET}:"
                        if [[ "${LEFT_VALUE}" ==  "${RIGHT_VALUE}" ]] ; then
                        {
                            passed "${TESTING}"
                        }
                        else
                        {
                            failed "${TESTING}"
                        }
                        fi
                    }
                    fi # not empty
                done <<< "${ARGS}"
            }
            fi
        } # end function check_equality

        alias verify_equality=check_equality
        alias ensure_equality=check_equality

        # REPEATED in execute_command

        trim_start_space() {
            sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g'
        }
        trim_end_space() {
            sed -e 's/[[:space:]]*$//' | sed 's/\ $//g' | sed 's/\t$//g'
        }
        trim() {
            trim_start_space | trim_end_space
        }
        convert_null() {
            if [ -z "${@}" ] ; then
            {
                echo "n8u8l"
            }
            else
            {
                echo """${@}"""
            }
            fi
        }
        convert_expects_internals() {
            if [[ "${@}" == '=' ]] ||  [[ "${@}" == '!' ]] ; then
            {
                echo "n8u8l"
            }
            else
            {
                echo """${@}"""
            }
            fi
        }
        function expect() {
            # Sample usage
            #
            #     expect $(echo "hola") to be equal to "hola"
            #     expect $(echo "hola") to be equal "hola"
            #     expect $(echo "hola") to equal to "hola"
            #     expect $(echo "hola") to equal "hola"
            #     expect $(echo "hola") be equal to "hola"
            #     expect $(echo "hola") be equal "hola"
            #     expect $(echo "hola") to be "hola"
            #     expect $(echo "hola") be "hola"
            #     expect $(echo "hola") = "hola"
            #      0        1           2  3   4
            #
            #     expect $(echo "hola") not to be equal to "hello"
            #     expect $(echo "hola") to not be equal to "hello"
            #     expect $(echo "hola") to be not equal to "hello"
            #     expect $(echo "hola") to be equal not to "hello"
            #     expect $(echo "hola") not to be equal "hello"
            #     expect $(echo "hola") to not be equal "hello"
            #     expect $(echo "hola") to be not equal "hello"
            #     expect $(echo "hola") not to equal "hello"
            #     expect $(echo "hola") to not equal "hello"
            #     expect $(echo "hola") to equal not "hello"
            #     expect $(echo "hola") to be "hello"
            #     expect $(echo "hola") not to be "hello"
            #     expect $(echo "hola") to not be "hello"
            #     expect $(echo "hola") to be not "hello"
            #     expect $(echo "hola") not be "hello"
            #     expect $(echo "hola") be not "hello"
            #     expect $(echo "hola") not "hello"
            #     expect $(echo "hola") â‰  "hello"
            #       0       1            2  3   4     5
            local statement=$(echo """${@}""")
                #| sed 's/'"="'/3QU4L51GN/g' \
                #| sed 's/'"!"'/3XCL4M4T10N/g' \
            local inputo=$(echo """${@}""" \
                | sed 's/'"not to be equal to"'/!/g' \
                | sed 's/'"to not be equal to"'/!/g' \
                | sed 's/'"to be not equal to"'/!/g' \
                | sed 's/'"to be equal not to"'/!/g' \
                | sed 's/'"not to be equal"'/!/g' \
                | sed 's/'"to not be equal"'/!/g' \
                | sed 's/'"to be not equal"'/!/g' \
                | sed 's/'"not to equal"'/!/g' \
                | sed 's/'"to not equal"'/!/g' \
                | sed 's/'"to equal not"'/!/g' \
                | sed 's/'"not to be"'/!/g' \
                | sed 's/'"to not be"'/!/g' \
                | sed 's/'"to be not"'/!/g' \
                | sed 's/'"not be"'/!/g' \
                | sed 's/'"be not"'/!/g' \
                | sed 's/'"not"'/!/g' \
                | sed 's/'"â‰ "'/!/g' \
                | sed 's/'"!!"'/!/g' \
                | sed 's/'"!!"'/!/g' \
                | sed 's/'"!!"'/!/g' \
                | sed 's/'"to be equal to"'/=/g' \
                | sed 's/'"to be equal"'/=/g' \
                | sed 's/'"to equal to"'/=/g' \
                | sed 's/'"to equal"'/=/g' \
                | sed 's/'"be equal to"'/=/g' \
                | sed 's/'"be equal"'/=/g' \
                | sed 's/'"to be"'/=/g' \
                | sed 's/'"be"'/=/g' \
                | sed 's/'"=="'/=/g' \
                | sed 's/'"=="'/=/g' \
                | sed 's/'"=="'/=/g' \
            )
            # echo $inputo
            # return 0
            #    0     1    2   3
            # expect $value = $VALUE
            if [  -z "${1+x}" ] || [ -z "${2+x}" ] || [ -z "${3+x}" ] ; then # check if all parameters are set and not empty
            {
                failed ${FUNCNAME[1]} requires to have 3 parameters :: ${FUNCNAME[1]} [not] to be equal to \$VALUE ::
            }
            fi
            local value_one="${1}"
            local equality="${2}"
            local value_two="${3}"
	    local TESTING IFS
            IFS=\  read value_one equality value_two<<EOF
                ${inputo}
EOF
            value_one=$(convert_expects_internals $(convert_null "${value_one}"))
            # DEBUG echo "0.value_one:,,$value_one''"
            value_two=$(convert_null "${value_two}")
            # DEBUG echo "0.value_two:,,$value_two''"

            # TESTING=$(echo "${FUNCNAME[0]} that value ${statement}" | ag "${value_one}" | ag "${value_two}")
            TESTING=$(echo "${FUNCNAME[0]} that value ${statement}")
            # DEBUG echo "${FUNCNAME[0]} that value ${statement}"
            # DEBUG echo "//"
            # DEBUG echo "${FUNCNAME[0]} that value ${statement}"
            # DEBUG echo "TESTING:${TESTING}"
            # DEBUG echo "inputo:,,$inputo''"
            if [[ "${inputo}" == *"="* ]] ; then
            {
                if [[ "${inputo}" == "=" ]] ; then
                {
                    passed "${TESTING}"
                    return 0
                }
                fi
                value_one=$(echo "${inputo}" | cut -d= -f1 | trim)
                # DEBUG echo "value_one:,,$value_one''"
                value_two=$(echo "${inputo}" | cut -d= -f2 | trim)
                # DEBUG echo "value_two:,,$value_two''"
                value_one=$(convert_null "${value_one}")
                # DEBUG echo "value_one:,,$value_one''"
                value_two=$(convert_null "${value_two}")
                # DEBUG echo "value_two:,,$value_two''"
                if [[ "${value_one}" == "${value_two}" ]] ; then
                {
                    passed "${TESTING}"
                    return 0
                }
                else
                {
                    failed "${TESTING}"
                    return 1
                }
                fi
            }
            else
            {
                if [[ "${inputo}" == "!" ]] ; then
                {
                    failed "${TESTING}"
                    return 1
                }
                fi
                value_one=$(echo "${inputo}" | cut -d! -f1 | trim)
                # DEBUG echo "value_one:,,$value_one''"
                value_two=$(echo "${inputo}" | cut -d! -f2 | trim)
                # DEBUG echo "value_two:,,$value_two''"
                value_one=$(convert_null "${value_one}")
                # DEBUG echo "value_one:,,$value_one''"
                value_two=$(convert_null "${value_two}")
                # DEBUG echo "value_two:,,$value_two''"
                if [[ "${value_one}" != "${value_two}" ]] ; then
                {
                    passed "${TESTING}"
                    return 0
                }
                else
                {
                    failed "${TESTING}"
                    return 1
                }
                fi
            }
            fi

        }
#expect "hola" = "hello"
#expect "hola" = "hola"

        testself_expect() {
            local -a caso
            local -a exito
            local -i COUNTER
            COUNTER=0
            local res
            local nada=""
            caso[0]="hola"
            exito[0]="hola"
            caso[0]="hola el mundo"
            exito[0]="hola el mundo"
            for caso in "${caso[@]}"; do
            {
                test_case="Error: Self test failed: ${FUNCNAME[0]} ... expected <${caso}> to be equal to <${exito[$COUNTER]}>"
                pass_case="Passed: Self test: ${FUNCNAME[0]} ... expected <${caso}> to be equal to <${exito[$COUNTER]}>"
                # DEPRECATED if/pass/fail idea if ( expect "a{caso}" "not to be equal to" "${exito[$COUNTER]}" ) ; then passed "$pass_case"; else failed  "$test_case"; exit 69; fi

                expect "${nada}" "not to be equal to" "${exito[$COUNTER]}"
                expect "a{caso}" "not to be equal to" "${exito[$COUNTER]}"
                expect "a{caso}" not to be equal to "${exito[$COUNTER]}"
                expect "${nada}" "to be equal to" "${nada}"
                expect "${caso}" "to be equal to" "${exito[$COUNTER]}"
                expect "${caso}" "not to be equal to" "${nada}"
                expect "${nada}" "not to be equal to" "${exito[$COUNTER]}"
                expect "${caso}" to be equal to "${exito[$COUNTER]}"

                expect $(echo "${caso}") to be equal "${exito[$COUNTER]}"
                expect $(echo "${caso}") to equal to "${exito[$COUNTER]}"
                expect $(echo "${caso}") to equal "${exito[$COUNTER]}"
                expect $(echo "${caso}") be equal to "${exito[$COUNTER]}"
                expect $(echo "${caso}") be equal "${exito[$COUNTER]}"
                expect $(echo "${caso}") to be "${exito[$COUNTER]}"
                expect $(echo "${caso}") be "${exito[$COUNTER]}"
                expect $(echo "${caso}") = "${exito[$COUNTER]}"

                expect $(echo "${caso}") not to be equal to "hello"
                expect $(echo "${caso}") to not be equal to "hello"
                expect $(echo "${caso}") to be not equal to "hello"
                expect $(echo "${caso}") to be equal not to "hello"
                expect $(echo "${caso}") not to be equal "hello"
                expect $(echo "${caso}") to not be equal "hello"
                expect $(echo "${caso}") to be not equal "hello"
                expect $(echo "${caso}") not to equal "hello"
                expect $(echo "${caso}") to not equal "hello"
                expect $(echo "${caso}") to equal not "hello"
                expect $(echo "${caso}") not to be "hello"
                expect $(echo "${caso}") to not be "hello"
                expect $(echo "${caso}") to be not "hello"
                expect $(echo "${caso}") not be "hello"
                expect $(echo "${caso}") be not "hello"
                expect $(echo "${caso}") not "hello"
                expect $(echo "${caso}") â‰  "hello"
                (( COUNTER++ )) # if (( $COUNTER > 37 )) ; then
            }
            done
            exit 0
        }
        #testself_expect #&> /dev/null # stdln to hide command output in bash
        # testself_expect 2>&1 >/dev/null #  capture onlly sterr error output

        function check_to_be_installed() {
            # Sample usage
            #
            # ...  you want to APT-GET install  ... sysfsutils
            # ...  and you want to say          ... fix for transparent_hugepage
            #
            #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
            #
            package="$1"
            message="$2"
            CHECK_INSTALLED=$(dpkg -s "${package}")
            if [[ "${CHECK_INSTALLED}" == *"Package: ${package}"* ]] ; then
                echo -e "${GREEN} PACKAGE: ${message}  ${package} is there  ${CERO}"
            else
                echo -e "${YELLOW} Installing ${message}   ${CERO}"
                sudo apt install "${package}" -y
            fi
        } # end check_to_be_installed

        function is_service_reponse_not_this_fail() {
            #Sample use
            # ( command -v nginx >/dev/null 2>&1; ) && sudo service nginx start
            #
            # is_service_reponse_not_this_fail "nginx" "$(sudo service nginx status)" "not running"
            # is_service_reponse_not_this_fail "puma" "$(sudo /etc/init.d/pumacontrol.sh status)" "not running"
            #
            local SERVICE_NAME SERVICE_STATUS SERVICE_FAIL_RESPONSE
            SERVICE_NAME="${1}"
            SERVICE_STATUS="${2}"
            SERVICE_FAIL_RESPONSE="${3}"
            TESTING="that service ${CYAN}${SERVICE_NAME}${LIGHTYELLOW} is running"
            if [[ "${SERVICE_STATUS}" == *"${SERVICE_FAIL_RESPONSE}"* ]] ; then
            {
                echo "${SERVICE_STATUS}"
                failed "${TESTING}"
            }
            else
            {
                passed "${TESTING}"
            }
            fi
        } # end is_service_reponse_not_this_fail

        function is_service_running() {
            #Sample use
            # ( command -v nginx >/dev/null 2>&1; ) && sudo service nginx start
            #
            # is_service_running "nginx" "$(sudo service nginx status)" "is running"
            # is_service_running "puma" "$(sudo /etc/init.d/pumacontrol.sh status)" "is running"
            #
            local SERVICE_NAME="${1}"
            local SERVICE_STATUS="${2}"
            local EXPECTED_RESPONSE="${3}"
            echo SERVICE_NAME="${1}"
            echo SERVICE_STATUS="${2}"
            echo EXPECTED_RESPONSE="${3}"
            TESTING="that service ${CYAN}${SERVICE_NAME}${LIGHTYELLOW} ${EXPECTED_RESPONSE}"
            if [[ "${SERVICE_STATUS}" == *"${EXPECTED_RESPONSE}"* ]] ; then
            {
                passed "${TESTING}"
            }
            else
            {
                echo "${SERVICE_STATUS}"
                failed "${TESTING}"
            }
            fi
        } # end is_service_running

        type_function_exists() {
          type "${*}" > /dev/null 2>&1
        } # type_function_exists


        function is_installed() {
            # Sample use
            #
            #          if  ! is_installed wget ; then    is like is NOT installed
            #          if  is_installed wget ; then      it makes more sense to make it this way
            #
            local SERVICE_NAME="${*}"
            if ! type_function_exists "${SERVICE_NAME}"; then
            {
                #failed "${TESTING}"
                return 1
            }
            else
            {
                #passed "${TESTING}"
                return 0
            }
            fi
        } # end is_installed

        function is_not_installed() {
            # Sample use
            #
            #          if  ! is_not_installed wget ; then # you can, but not recommended, because it is confusing to read
            #          if  is_not_installed wget ; then
            #
            local SERVICE_NAME="${*}"
            if ! type_function_exists "${SERVICE_NAME}"; then
            {
                #passed "${TESTING}"
                return 0
            }
            else
            {
                #failed "${TESTING}"
                return 1
            }
            fi
        } # end is_not_installed

        function verify_is_installed() {
            # Sample use
            #
            #            verify_is_installed wget
            #
            local SERVICE_NAME="${1}"
            TESTING="that: ${CYAN}${SERVICE_NAME}${GREEN} is installed"
            if ! is_installed "${SERVICE_NAME}"; then
            {
                failed "${TESTING}"
            }
            else
            {
                passed "${TESTING}"
            }
            fi
        } # end verify_is_installed

        function version_installed_is() {
            # Sample use
            #
            #          if  ! version_installed_is "node --version"  "${node_version}" ;           then    is like     version installed is  12.3.4.1 ?
            #          if  version_installed_is   "phantomjs --version"  "${phantomjs_version}" ; then    it like     NOT version is installed version 12.31.23 ?
            #
            local give_me_something=$(eval """${1}""" 2>&1 | extract_version | head -1)
            local expected="${2}"
            local TESTING="that installed version for ${give_me_something} is ${CYAN}${expected}${GREEN}"
            # passed "${give_me_something}" passed "${expected}" failed  "${TESTING}" 
            # ( declare -p "${give_me_something}"  &>/dev/null ) &&  failed "${left value empty}" && return 0 
            # ( declare -p "${expected}"  &>/dev/null ) &&  failed "${right value empty}" && return 0 
            if [[ "${give_me_something}" == *"${expected}"* ]] || [[ "${give_me_something}" == "${expected}" ]]; then
            {
                return 0  #failed  "${TESTING}"
            }
            else
            {
                return 1  #passed  "${TESTING}"
            }
            fi
        } # end version_installed_is

        alias is_version_installed=version_installed_is
        alias is_installed_version=version_installed_is
        alias is_version=version_installed_is
        alias version_is=version_installed_is

        function verify_installed_version() {
            # Sample use
            #
            #            verify_installed_version "node --version"  "${node_version}"
            #            verify_installed_version "phantomjs --version"  "${phantomjs_version}"
            #            verify_installed_version "casperjs --version"  "${casper_version}"
            #
            local COMMAND_TO_EVAL=$(eval """${1}""" 2>&1 | extract_version | head -1)
            local VERSION_EXPECTED=$(eval """${2}""" 2>&1 | extract_version | head -1)
            # passed "${COMMAND_TO_EVAL}" passed "${VERSION_EXPECTED}" 
            local TESTING="that installed version for <${COMMAND_TO_EVAL}> is ${CYAN}<${VERSION_EXPECTED}>${GREEN} "
            ( declare -p "${COMMAND_TO_EVAL}"  &>/dev/null ) &&  failed "${TESTING} -- left value empty" && return 1
            ( declare -p "${VERSION_EXPECTED}"  &>/dev/null ) &&  failed "${TESTING} -- right value empty" && return 1
            if [[ "${COMMAND_TO_EVAL}" == *"${VERSION_EXPECTED}"* ]] || [[ "${COMMAND_TO_EVAL}" == "${VERSION_EXPECTED}" ]]; then
            {
                failed "${TESTING}"
                return 1
            }
            else
            {
                passed "${TESTING}"
                return 0
            }
            fi
            return 0
        } # end verify_installed_version

        function verify_installed_version_old() {
            # Sample use
            #
            #            verify_installed_version "node --version"  "${node_version}"
            #            verify_installed_version "phantomjs --version"  "${phantomjs_version}"
            #            verify_installed_version "casperjs --version"  "${casper_version}"
            #
            local EVAL_GET_VERSION_STRING=$(eval """${1}""" 2>&1 | head -1)
            local VERSION_EXPECTED="${2}"

            local TESTING="that installed version for ${1} is ${CYAN}${VERSION_EXPECTED}${GREEN}"
            if [[ "${EVAL_GET_VERSION_STRING}" == *"${VERSION_EXPECTED}"* ]] || [[ "${EVAL_GET_VERSION_STRING}" == "${VERSION_EXPECTED}" ]]; then
            {
                passed "${TESTING}"
            }
            else
            {
                echo -e "${RED} ðž¦ I got response: ${YELLOW_OVER_DARKBLUE}${EVAL_GET_VERSION_STRING}"
                failed "${TESTING}"
            }
            fi
        } # end verify_installed_version_old

        function if_user_exists() {
            # Sample use
            #
            #            ( ! if_user_exists "postgres"  ) && failed "${TESTING}"
            #            ( if_user_exists "postgres"  ) && passed "${TESTING}"
            #
            local TARGET_USER="${1}"
            local TESTING="that user ${TARGET_USER} is ${CYAN}exists${GREEN}"
            local LIST_ALL_USERS=$(cut -d: -f1 /etc/passwd) # REF: http://askubuntu.com/questions/410244/a-command-to-list-all-users-and-how-to-add-delete-modify-users
            local USERID=$(id -u ${TARGET_USER})
            # Alternative to check getent passwd $user  > /dev/null
            # Alternative to check getent passwd mongodb  > /dev/null
            [ -z "${USERID}" ] &&  return 1 #failed
            return 0 #found
        } # end if_user_exists

        function check_if_user_exists() {
            # Sample use
            #
            #            check_if_user_exists "postgres"
            #
            local TARGET_USER="${1}"
            local TESTING="checking that user ${TARGET_USER} is ${CYAN}exists${GREEN}"
            ( ! if_user_exists "${TARGET_USER}"  ) && failed "${TESTING}"
            passed "${TESTING}"
        } # end check_if_user_exists

        function has_error_keyword() {
            # Sample use
            #
            #            has_error_keyword "${bulk}"
            #
            local bulk="${*}"
            if    [[ "${bulk}" == *"Could not resolve"*    ]] || \
                  [[ "${bulk}" == *"Repository not found"* ]] || \
                  [[ "${bulk}" == *"Could not read from"*  ]] || \
                  [[ "${bulk}" == *"Could not"*            ]] || \
                  [[ "${bulk}" == *"could not"*            ]] || \
                  [[ "${bulk}" == *"unmatched"*            ]] || \
                  [[ "${bulk}" == *"Fatal"*                ]] || \
                  [[ "${bulk}" == *"FATAL"*                ]] || \
                  [[ "${bulk}" == *"fatal"*                ]] || \
                  [[ "${bulk}" == *"FAILED"*               ]] || \
                  [[ "${bulk}" == *"failed"*               ]] || \
                  [[ "${bulk}" == *"Failed"*               ]] || \
                  [[ "${bulk}" == *"error"*                ]] || \
                  [[ "${bulk}" == *"ERROR"*                ]] || \
                  [[ "${bulk}" == *"Error"*                ]] || \
                  [[ "${bulk}" == *"Denied"*               ]] || \
                  [[ "${bulk}" == *"denied"*               ]] ; then
            {
                #passed "${TESTING}"
                return 0
            }
            else
            {
                #failed "${TESTING}"
                return 1
            }
            fi

        } # end has_error_keyword

        function handle_error() {
            # Sample use
            #
            #            local install_result=$(sudo apt-get install ${missing} -yfq   2>&1)  # capture all input and output
            #            [[ ! -z "${install_result}" ]] && handle_error "${install_result}"
            #
            local err_buff=$?
            # [ $err_buff -eq 0 ] && [ $1 -gt 0 ] && err_buff=$1
            local bulk="${*}"
            local error_happened=""
            [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff != 0 ] && error_happened="1"
            [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff != 0 )) && error_happened="1"
            if [ "${error_happened}" ]  ||  ( has_error_keyword "${bulk}" ) ; then
            {
              echo -e "${PURPLE_BLUE} action ${RED}failed ${YELLOW226}!!!  ${RESET}"
              [[ "${bulk}" == *"Could not resolve"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO INTERNET CONNECTION \o_0/ ${RESET}"
              [[ "${bulk}" == *"Repository not found"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO ACCESS TO THIS FOR YOU ${RED} ${GIT_USER_NAME} ${RESET}"
              [[ "${bulk}" == *"Could not read from"* ]] && echo -e "${BRIGHT_BLUE87} It appears it exists but you are ${RED}NOT ${YELLOW226} ALLOWED ${RED} ${GIT_USER_NAME} ${YELLOW226}!!! ${RESET}"
              failed "${RESET}${bulk}  "
            }
            fi

        } # end handle_error

        function extract_version() {
            # Bash extract version from a string REF:  https://superuser.com/questions/363865/how-to-extract-a-version-number-using-sed
            # sample usage
            # BASH_VERSION=$(extract_version  <<< $(/usr/bin/env bash --version) | head -1)
            # echo "bash version", $BASH_VERSION
            sed -nre 's/^[^0-9]*(([0-9]+\.)*[0-9]+).*/\1/p'
        } # end extract_version

        function vercomp() {
            # REF: https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
            if [[ $1 == $2 ]]
            then
                return 0
            fi
            local IFS=.
            local i ver1=($1) ver2=($2)
            # fill empty fields in ver1 with zeros
            for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
            do
                ver1[i]=0
            done
            for ((i=0; i<${#ver1[@]}; i++))
            do
                if [[ -z ${ver2[i]} ]]
                then
                    # fill empty fields in ver2 with zeros
                    ver2[i]=0
                fi
                if ((10#${ver1[i]} > 10#${ver2[i]}))
                then
                    return 1
                fi
                if ((10#${ver1[i]} < 10#${ver2[i]}))
                then
                    return 2
                fi
            done
            return 0
        } # end vercomp

        function testvercomp() {
            vercomp $1 $2
            case $? in
                0) op='=';;
                1) op='>';;
                2) op='<';;
            esac
            if [[ $op != $3 ]]
            then
                echo "FAIL: Expected '$3', Actual '$op', Arg1 '$1', Arg2 '$2'"
            else
                echo "Pass: '$1 $op $2'"
            fi
            # Tests
            # # Run tests
            # # argument table format:
            # # testarg1   testarg2     expected_relationship
            # echo "The following tests should pass"
            # while read -r test
            # do
            #     testvercomp $test
            # done << EOF
            # 1            1            =
            # 2.1          2.2          <
            # 3.0.4.10     3.0.4.2      >
            # 4.08         4.08.01      <
            # 3.2.1.9.8144 3.2          >
            # 3.2          3.2.1.9.8144 <
            # 1.2          2.1          <
            # 2.1          1.2          >
            # 5.6.7        5.6.7        =
            # 1.01.1       1.1.1        =
            # 1.1.1        1.01.1       =
            # 1            1.0          =
            # 1.0          1            =
            # 1.0.2.0      1.0.2        =
            # 1..0         1.0          =
            # 1.0          1..0         =
            # EOF

            # echo "The following test should fail (test the tester)"
            # testvercomp 1 1 '>'
        } # end testvercomp

        function to_lowercase() {
            # local env_bash_version=$(extract_version  <<< $(/usr/bin/env bash --version) | head -1)
            local env_bash_version=$(extract_version  <<< $(echo $BASH_VERSION) | head -1)
            [ -z "${BASH_VERSION}" ] && env_bash_version=$(extract_version  <<< $(/usr/bin/env bash --version) | head -1)
            echo "bash version", $env_bash_version
            [ -z "${1}" ] && return 1  # no argument passed
            if ( testvercomp $env_bash_version 3 ">" ) ; then
            {
                # greater than version 3
                echo "${1,,}"         # bash Convert string to lowercase Bash 4 REF: https://stackoverflow.com/questions/2264428/converting-string-to-lower-case-in-bash-shell-scripting
            }
            else
            {
                # less than version 3
                echo "${1}" | sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'         # bash Convert string to lowercase Bash 4 REF: https://stackoverflow.com/questions/2264428/converting-string-to-lower-case-in-bash-shell-scripting
            }
            fi
        } # end to_lowercase
        alias downcase=to_lowercase

        function is_included() {
            # Sample use
            #            ( is_included imagemagick "imagemagick imagemagick-common" ) && echo "is included"
            #            packages=$(dpkg -l | egrep "tree" | cut -d' ' -f3 2>&1)
            #            ( is_included "tree" "${packages}" ) && echo "is included"
            #
            #    vagrant@:/var/www$ pacaga=$(dpkg -l | egrep imagemagick | cut -d' ' -f3  2>&1)
            #    vagrant@:/var/www$ [ $? == 0 ] && ( is_included "imagemagick" "${pacaga}" ) && echo "is included"
            #    vagrant@:$ = --->  is included

            #    vagrant@:/var/www$ pacaga=$(dpkg -l | egrep imagemagick | cut -d' ' -f3  2>&1)
            #    vagrant@:/var/www$ [ $? == 0 ] && ( is_included "imick" "${pacaga}" ) && echo "is included"
            #    vagrant@:$ = --->  (nil)

            #    local packages=$(dpkg -l | egrep "$one_required" | cut -d' ' -f3 2>&1)
            #    if [ $? == 0 ] && ( is_included "$one_required" "${packages}" ) ; then
            #    {
            #        passed " ${GREEN} $one_required ${YELLOW} INSTALLED${RESET} ."
            #    }
            #    else
            #    {
            #        echo -e " ${RED}  NEED TO INSTALL ${YELLOW} $one_required${RESET} ."
            #        missing="${missing} ${one_required}"
            #    }
            #    fi
            # echo "all:", $*
            # echo "1:", $1
            # echo "2:", $2
            [ -z "${*}" ] && return 1  # Nothing was passed
            # echo "hola"
            local all=$(switch_spaces_to_newlines <<< "${*}")
            # echo "all:", "$all"
            # local seoking="" # $(trim <<< "${1}")
            local seeking="" # $(to_lowercase "${seoking}")
            # echo $seoking
            # echo $seeking
            local one_item one_hay
            local COUNTER=0
            while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                    (( COUNTER++ ))
                    # echo "--circle", $one_item, $COUNTER
                    if (( $COUNTER == 1 )) ; then
                    {
                        # echo "in"
                        # seoking=$(trim <<< "${one_item}")
                        # seeking=$(to_lowercase <<< "${seoking}")
                        # echo $seoking
                        # echo $seeking
                        seeking="${one_item}"
                    }
                    else
                    {
                        # echo "else"
                        # one_hay=$(trim <<< "${one_item}")
                        # one_hay=$(to_lowercase "${one_hay}")
                        one_hay="${one_item}"
                        if [[ "${one_hay}" == "${seeking}" ]] ; then
                        {
                            # echo "found return 0"
                            return 0  # yes it is included
                        }
                        fi
                    }
                    fi
                }
                fi
            }
            done <<< "${all}"
            return 1  # No is not included
        } # end is_included

        function is_not_included() {
            # Sample use
            #
            #    if is_not_included fedora "imagemagick imagemagick-common" ; then
            #
            if ! is_included "${*}"; then
            {
                #passed "${TESTING}"
                return 0
            }
            else
            {
                #failed "${TESTING}"
                return 1
            }
            fi
        }

        function install_apt_get_requirements() {
            # Sample use
            #               local OS="${1}"
            #               install_apt_get_requirements "${OS}" "
            #                        build-essential
            #                        libreadline-dev
            #                        zlib1g-dev
            #                        flex
            #                        bison
            #                        libxml2-dev
            #                        libxslt-dev
            #                        libssl-dev
            #
            #                        libreadline6-dev
            #                        libossp-uuid-dev
            #                        uuid"
            #
            #

            # room for detecting Linux and OS systems
            local OS="${1}"
            local missing=""
            local one_required=""
            local required=$(grep -vE '^\s+#'<<<"${2}")
            for one_required in ${required}; do
            {
                # REF: https://www.cyberciti.biz/faq/find-out-if-package-is-installed-in-linux/
                local packages=$(dpkg -l | egrep "$one_required" | cut -d' ' -f3 2>&1)
                local query=$(dpkg-query -W -f='${Status} ${Version}\n' "$one_required"  2>&1)
                #if [[ "${query}" == "install ok"* ]] && ( is_included "$one_required" "${packages}" ); then
                if [[ "${query}" == "install ok"* ]] ; then
                {
                    passed " ${GREEN} $one_required ${YELLOW} INSTALLED${RESET} ."
                }
                else
                {
                    echo -e " ${RED}  NEED TO INSTALL ${YELLOW} $one_required${RESET} ${RED}...${query}"
                    missing="${missing} ${one_required}"
                }
                fi
            }
            done
            missing=$(echo ${missing} | sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g' ) # trim_start_space

            # Check Requirements OS Ubuntu 14.04 REF: https://wiki.postgresql.org/wiki/Compile_and_Install_from_source_code#Ubuntu
            [[ ! -z "${missing}" ]] && echo -e " ${CYAN} Installing missing packages: ${YELLOW} ${missing} ${RESET} ."
            local err_buff=0

            if [[ ! -z "${missing}" ]] ; then
            {
                local install_result=$(sudo apt-get install ${missing} -yfq   2>&1) # capture all input and output
                err_buff=$?
            }
            fi
            # echo $install_result;
            if [[ ! -z "${install_result}" ]] ; then #  && handle_error "${install_result}"
            {
                local error_happened=""
                [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff != 0 ] && error_happened="1"
                [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff != 0 )) && error_happened="1"
                if [ "${error_happened}" ]  ||  ( has_error_keyword "${install_result}" ) ; then
                {
                  echo -e "${PURPLE_BLUE} action ${RED}failed ${YELLOW226}!!!  ${RESET}"
                  [[ "${install_result}" == *"Could not resolve"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO INTERNET CONNECTION \o_0/ ${RESET}"
                  [[ "${install_result}" == *"Repository not found"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO ACCESS TO THIS FOR YOU ${RED} ${GIT_USER_NAME} ${RESET}"
                  [[ "${install_result}" == *"Could not read from"* ]] && echo -e "${BRIGHT_BLUE87} It appears it exists but you are ${RED}NOT ${YELLOW226} ALLOWED ${RED} ${GIT_USER_NAME} ${YELLOW226}!!! ${RESET}"
                  RED="\\033[01;31m"
                  CYAN="\\033[01;36m"
                  local display_install_result=$(echo "${install_result}" | sed "s/\(FAILED\|failed\|Failed\|ERROR\|Error\|error\|cannot\|continue\|logged\|inspection\|not\|exit\|more\|details\)/${RED}\1${CYAN}/g")
                  failed "${RESET} \n .... \n ... ${display_install_result} \n ... \n ..."
                }
                fi

            }
            fi
        }
        # end install_apt_get_requirements

        function install_apt_get_should_not_be_installed() {
            # Sample use
            #               local OS="${1}"
            #               install_apt_get_should_not_be_installed "${OS}" "
            #                        build-essential
            #                        libreadline-dev
            #                        zlib1g-dev
            #                        flex
            #                        bison
            #                        libxml2-dev
            #                        libxslt-dev
            #                        libssl-dev
            #
            #                        libreadline6-dev
            #                        libossp-uuid-dev
            #                        uuid"
            #
            #

            # room for detecting Linux and OS systems
            local OS="${1}"
            local removing=""
            local one_required=""
            local required=$(grep -vE '^\s+#'<<<"${2}")
            for one_required in ${required}; do
            {
                dpkg -l | egrep "$one_required" &>/dev/null
                if [ $? == 0 ]; then
                {
                    echo -e " ${RED}  NEED TO REMOVE ${YELLOW} $one_required${RESET} ."
                    removing="${removing} ${one_required}"
                }
                else
                {
                    passed " ${GREEN} $one_required ${YELLOW} NOT PRESENT${RESET} ."
                }
                fi
            }
            done
            removing=$(echo ${removing} | sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g' ) # trim_start_space

            [[ ! -z "${removing}" ]] && echo -e " ${CYAN} Apt-get removing packages: ${YELLOW} ${removing} ${RESET} ."
            [[ ! -z "${removing}" ]] && local remove_result=$(sudo apt-get remove ${removing} -yfq   2>&1 && sudo apt-get purge ${removing} -yfq   2>&1 && sudo apt-get autoremove -yfq   2>&1) # capture all input and output
            local err_buff=$?
            [[ ! -z "${remove_result}" ]] && handle_error "${err_buff}" "${remove_result}"
        }
        # end install_apt_get_should_not_be_installed
        #
        # C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --Start
        #
        function test_positives() {
            # Sample use
            #
            #
            #    local message_response=$(ls asdasdfas1234  2>&1 )  # Perform an action with error ,capture all output, error will return 1 to $?
            #    local err_buff=$?
            #    local ERROR_HAPPENED=""
            #    [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff != 0 ] && ERROR_HAPPENED="1"
            #    [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff != 0 )) && ERROR_HAPPENED="1"
            #    if [ "${ERROR_HAPPENED}" ] || \
            #        [[ "${message_response}" == *"error"* ]] || \
            #        [[ "${message_response}" == *"ERROR"* ]] || \
            #        [[ "${message_response}" == *"denied"* ]] \
            #    ; then
            #    {
            #        failed "There was an error- do something- show something ${message_response}"
            #    }
            #    fi
            #
            #    # Alternative:
            #    local err_buff=$?
            #    local ERROR_HAPPENED=""
            #    (  ( [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff != 0 ]  )  ||  (  [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff != 0 ))  )   )  && ERROR_HAPPENED="1"
            #    if [ "${ERROR_HAPPENED}" ] || \
            #        [[ "${message_response}" == *"error"* ]] || \
            #        [[ "${message_response}" == *"ERROR"* ]] || \
            #        [[ "${message_response}" == *"denied"* ]] \
            #    ; then
            #    {
            #        failed "There was an error- do something- show something ${message_response}"
            #    }
            #    fi

            KIND=""
            # ls werwerwerwerwerwerwerwerwerwerwerr >/dev/null 2>&1;
            # if (( $? == 0 )) ;  then  # Intel processor
                KIND="INTEL"
            # fi
            # if [ $? == 0 ]; then   # Mac Intel processor
            #     KIND="${KIND}MAC"
            # fi
            # echo "clear_error_output" >/dev/null 2>&1;
            echo "${KIND}"
        }
        PROCESSOR_ERROR=$(test_positives)
        # DEBUG test_positives echo "${PROCESSOR_ERROR}"
        # DEBUG test_positives exit 1
        #
        # C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --End
        #

        function escape_spaces() {
            sed "s/ /\\\ /g"
        }
        function escape_single_quotes() {
            sed "s/'/\\\'/g"
        }
        function escape_double_quotes() {
            sed 's/\"/\\\"/g'
        }
        function escape_more_than() {
            sed s/""">"""/\\\>/g
        }
        function escape_less_than() {
            sed s/"""<"""/\\\</g
        }
        function escape_slashes() {
            sed 's/\//\\\//g'
        }
        function escape_bangs() {
            sed 's/\!/\\\!/g'
        }
        function escape_dots() {
            sed 's/\./\\\./g'
        }
        function escape_for_sed_sequence() {
            escape_double_quotes | \
            escape_less_than | escape_more_than | \
            escape_slashes  | escape_single_quotes | \
            escape_bangs | escape_dots
        }
        function remove_letters() {
          sed 's/[a-z-]\|[A-Z-]\|[ -]\|[(-)-]\|[, -]\|86_64//g'
        }
        function trim_start_space() {
            sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g'
        }
        function trim_end_space() {
            sed -e 's/[[:space:]]*$//' | sed 's/\ $//g' | sed 's/\t$//g'
        }
        function trim() {
            trim_start_space | trim_end_space
        }
        # duplicated at commit
        function get_longest_name_length() {
          # Sample usage:
          #               LONGEST_NAME=$(get_longest_name_length "${LIST_OF_FILENAMES_OR_STRINGS}")
          local ONE_CHANGED_FILES_WITH_STATUS
          local CHANGED_FILES_WITH_STATUS_WITH_TAB_CHANGED_TO_PIPE="${1}"
          local FILENAME_LENGTH=0
          local LONGEST_NAME=0

          #while read -r ONE_CHANGED_FILES_WITH_STATUS; do                                                  # Get longest file name
          while read -r ONE_CHANGED_FILES_WITH_STATUS; do
          {
            # if not empty
            if [ ! -z "${ONE_CHANGED_FILES_WITH_STATUS}" ] ; then
            {
              FILENAME_LENGTH="${#ONE_CHANGED_FILES_WITH_STATUS}"   # get string length
              (( FILENAME_LENGTH > LONGEST_NAME )) && LONGEST_NAME=$FILENAME_LENGTH
            }
            fi
            #echo "$(echo "$ONE_CHANGED_FILES_WITH_STATUS" | xargs -I {} echo "{}:1")"
          }
          done <<< "${CHANGED_FILES_WITH_STATUS_WITH_TAB_CHANGED_TO_PIPE}"
          #done <<< "${CHANGED_FILES_WITH_STATUS_WITH_TAB_CHANGED_TO_PIPE}"
          echo $LONGEST_NAME
        }
        # end get_longest_name_length
        # duplicated at commit
        function repeat_single_char_spacer() {
          # Sample usage:
          #               SPACER=$(repeat_single_char_spacer " " $CALCULATE_SPACER)
          #
          #
          # Complete Preparation:
          #
          #               LONGEST_NAME=$(get_longest_name_length "${LIST_OF_FILENAMES_OR_STRINGS}")
          #               FILENAME_LENGTH="${#FILENAME}"   # get string length
          #               CALCULATE_SPACER=$(( $LONGEST_NAME - $FILENAME_LENGTH ))
          #               SPACER=$(repeat_single_char_spacer " " $CALCULATE_SPACER)
          #               echo ${FILENAME}${SPACER}
          #
          local pad="${1}"
          local total=${2}
          [ ${total} -lt 1 ] && echo "${YELLOW} Warning ${FUNCNAME[*]}: ${CYAN} Expected number 'total' to be more than 0 and I got :${total}: value ${RESET}" && total=10
          [ -z "${pad}" ] && [ "${#pad}" -lt 1 ] && echo "${YELLOW} Warning ${FUNCNAME[*]}: ${CYAN} Expected padding 'pad' to be something and I got :${pad}: value ${RESET}" && pad=" "
          for ((x = 0; x < ${total}; x++)); do
            #echo "${1}"
            printf %s "${pad}"
          done
        }
        # end repeat_single_char_spacer

        function add_right_padding() {
          # Sample usage:
          #               add_right_padding "${ONE_VERSION}" ${LONGEST_NAME}  " "
          #
          local string="${1}"
          local longest=${2}
          local pad="${3}"
          local length="${#string}"   # get string length
          local calculate=$(( $longest - $length ))
          local padding=$(repeat_single_char_spacer "${pad}" ${calculate})
          echo "${string}${padding}"
        }
        # end add_right_padding

        function add_left_padding() {
          # Sample usage:
          #               add_left_padding " " ${LONGEST_NAME}   "${ONE_VERSION}"
          #
          local pad="${1}"
          local longest=${2}
          local string="${3}"
          local length="${#string}"   # get string length
          local calculate=$(( $longest - $length ))
          local padding=$(repeat_single_char_spacer ${pad} $calculate)
          echo "${padding}${string}"
        }
        # end add_left_padding

        function build_table_from_installed_components() {
            # Sample usage:
            #                build_table_from_installed_components "${USER_TO_INSTALL}"
            #                build_table_from_installed_components "${USER}"
            #
            local USER_TO_INSTALL="${1}"
            if [[ -z "${USER_TO_INSTALL}" ]] ; then
	    {
              failed to provide USER. Call with build_table_from_installed_components \$USER or build_table_from_installed_components john or some username
	    }
	    fi
            local README_TABLE="INSTALLED_MACHINE=\"
 Service/Software | Version                        | Executable
------------------|--------------------------------|-------------------------------------------"
            local local_commands="
=, Instanced on     , date       , date
=, OS               , lsb_release, lsb_release -sd
=, Timezone         ,            , cat /etc/timezone
=, Processor        , uname      , uname -p
=, CPUS             , getconf    , getconf _NPROCESSORS_ONLN
=, LOCALE LANG      , locale     , locale | grep 'LANG=' | cut -d= -f2
=, LOCALE LC_ALL    , locale     , locale | grep 'LC_ALL=' | cut -d= -f2
x, Nginx            , nginx      , nginx -v
x, localtunnel.me   , lt         ,
x, NodeJS           , node       ,
x, NPM              , npm        ,
x, NVM              , nvm        ,
x, PhantomJS        , phantomjs  ,
x, Ruby             , ruby       ,
x, RVM              , rvm        ,
x, Puma             , puma       ,
x, Python           , python     ,
x, PyENV            , pyenv      ,
x, Mongo            , mongo      ,
x, Redis            , redis-cli  ,
x, PostgresQL       , psql       ,
x, Mysql 5          , mysql      ,  echo \"\${\$(mysql --version 2>&1)#*Distrib}\"
x, PHP 7            , php7.0     ,
x, PHP 7 Xdebug     , php7.0     ,  php7.0 --version | grep Xdebug
x, PHP 7 FPM        , php-fpm7.0 ,
x, PHP 7 FPM Xdebug , php-fpm7.0 ,  php-fpm7.0 --version | grep Xdebug
x, PHP 5            , php5.6     ,
x, PHP 5 Xdebug     , php5.6     ,  php5.6 --version | grep Xdebug
x, PHP 5 FPM        , php-fpm5.6 ,
x, PHP 5 FPM Xdebug , php-fpm5.6 ,  php-fpm5.6 --version | grep Xdebug
x, WP CLI           , wp         ,
x, FRENO            , freno      ,
x, sent             , sentimineo ,
"
            local IFS
            local FILTER_THIS
            local ONE_TITLE
            local ONE_COMMAND
            local ONE_TEST
            local ONE_VERSION
            local ONE_WHICH
            local MIDDLE__LONGEST=$(get_longest_name_length "$(date)")
            local VERSION_EXTRACT_COMMAND
            (( MIDDLE__LONGEST ++ ))
            (( MIDDLE__LONGEST ++ ))
            local TABLE_VERSION_LENGTH
            local GOODIES="
echo \" \"
echo -e \"


"
            while read -r one_line; do
            {
              if [ ! -z "${one_line}" ]; then
              {
                IFS=\, read FILTER_THIS ONE_TITLE ONE_COMMAND ONE_TEST<<EOF
${one_line}
EOF
    echo "sudo -u ${USER_TO_INSTALL} -i -- command -v ${ONE_COMMAND}"
                if ( is_installed ${ONE_COMMAND} ) ; then
                {
                    echo "yup"
                  [ -z "${ONE_TEST}" ] && ONE_TEST="command ${ONE_COMMAND} --version"
                  ONE_VERSION=""
                  [[ "${FILTER_THIS}" == "x" ]] && ONE_VERSION=$(sudo -u ${USER_TO_INSTALL}  -i -- eval """${ONE_TEST}""" 2>&1 | extract_version  |  remove_letters | head -1)
                  [[ "${FILTER_THIS}" == "=" ]] && ONE_VERSION=$(sudo -u ${USER_TO_INSTALL}  -i -- eval """${ONE_TEST}""" 2>&1 | head -1 )
                  ONE_WHICH=""
                  [[ "${FILTER_THIS}" != "=" ]] && ONE_WHICH="$(sudo -u ${USER_TO_INSTALL} -i -- which ${ONE_COMMAND} 2>&1 | head -1 )"
                  ONE_VERSION=$(add_right_padding  "${ONE_VERSION}" ${MIDDLE__LONGEST} " ")
                  README_TABLE="${README_TABLE}
${ONE_TITLE}| ${ONE_VERSION} | ${ONE_WHICH}"

                  [ ! -z "${ONE_WHICH}" ] && ONE_WHICH="${GREEN}\t\t:${GRAYEDOUT}${ONE_WHICH}"
                  VERSION_EXTRACT_COMMAND="${RED}${ONE_TITLE}${GREEN}:${CYAN}${ONE_VERSION}${ONE_WHICH}"
                  GOODIES="${GOODIES}
${VERSION_EXTRACT_COMMAND}"
                }
                else
                {
                    echo "nop"
                     sudo -u "${USER_TO_INSTALL}" -i -- echo "command was ${ONE_COMMAND}"

                }
                fi
              }
              fi
            }
            done <<< "${local_commands}"

            README_TABLE="${README_TABLE}
\""


            GOODIES="${GOODIES}
\"
echo \" \"
echo \" \"
${README_TABLE}

# bash completion for the wp command

_wp_complete() {
  local OLD_IFS=\"\$IFS\"
  local cur=\${COMP_WORDS[COMP_CWORD]}

  IFS=\$'\n';  # want to preserve spaces at the end
  local opts=\"\$(wp cli completions --line=\"\$COMP_LINE\" --point=\"\$COMP_POINT\")\"

  if [[ \"\$opts\" =~ \<file\>\s* ]]
  then
    COMPREPLY=( \$(compgen -f -- \$cur) )
  elif [[ \$opts = \"\" ]]
  then
    COMPREPLY=( \$(compgen -f -- \$cur) )
  else
    COMPREPLY=( \${opts[*]} )
  fi

  IFS=\"\$OLD_IFS\"
  return 0
}
complete -o nospace -F _wp_complete wp

"
            echo "${GOODIES}"
}
# end build_table_from_installed_components

        function switch_spaces_to_newlines() {
            sed 's/ /\n/g'
        } # end switch_spaces_to_newlines
        function switch_spaces_to_underscores() {
            sed 's/ /_/g'
        } # end switch_spaces_to_underscores
        function make_itarable() {
            sed 's/ /\n/g' | trim | enter_encode | sed 's/0N33NT3R/ \r\n/g'
        }
        # end make_itarable

        function chown_it() {
            # Sample use
            #            chown_it "${USER_TO_INSTALL}" /usr/local/rvm
            #            chown_it "${USER_TO_INSTALL}" /usr/local/rvm /usr/local/.nvm /usr/local/.nvm  /usr/local/rvm  /root/.temp
            local USER_TO_INSTALL="${1}"
            local paths=$(switch_spaces_to_newlines <<< "${2}")
            local actions="
                [ -e \"{#}\" ] && chown -R \"${USER_TO_INSTALL}\":\"${USER_TO_INSTALL}\" \"{#}\"
            "
             while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                    if [ ! -e "${one_item}" ] ; then
                    {
                        echo -e "${RED}WARNING: chown_it() ${YELLOW}FILE DOES NOT Exist: ${one_item}"
                    }
                    else
                    {
                        chown -R "${USER_TO_INSTALL}" "${one_item}"
                        if [ $? -gt 0 ] ; then
                        {
                            echo "${RED}ERROR: chown_it() ${YELLOW}Error executing: chown -R \"${USER_TO_INSTALL}\" \"${one_item}\""
                        }
                        fi
                    }
                    fi

                }
                fi
            }
            done <<< "${paths}"
        }
        # end chown_it

        function chmod_it() {
            # Sample use
            #            chmod_it 644 /usr/local/rvm
            #            chmod_it "${chmodmod}" /usr/local/rvm /usr/local/.nvm /usr/local/.nvm  /usr/local/rvm  /root/.temp
            local chmodmod="${1}"
            local paths=$(switch_spaces_to_newlines <<< "${2}")
            local actions="
                [ -e \"{#}\" ] && chmod \"${chmodmod}\" \"{#}\"
            "
            while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                    if [ ! -e "${one_item}" ] ; then
                    {
                        echo -e "${RED}WARNING: chmod_it() ${YELLOW}FILE DOES NOT Exist: ${one_item}"
                    }
                    else
                    {
                        chmod "${chmodmod}" "${one_item}"
                        if [ $? -gt 0 ] ; then
                        {
                            echo "${RED}ERROR: chmod_it() ${YELLOW}Error executing: chmod \"${chmodmod}\" \"${one_item}\""
                        }
                        fi
                    }
                    fi

                }
                fi
            }
            done <<< "${paths}"

        } # end chmod_it

        function link_it() {
            # Sample use
            #            link_it "${USER_TO_INSTALL}" /usr/local/bin/python  /home/${USER_TO_INSTALL}/.pyenv/shims/python
            local USER_TO_INSTALL="${1}"
            local from="${2}"
            local to="${3}"
            [ ! -e "${to}" ] && failed "Trying to link_it ln -sf \"${to}\"      \"${from}\" but target :${to}: does not exist"
            ln -sf "${to}"    "${from}"
            #[ -e "${to}" ] && chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "${to}"
            [ -e "${to}" ] && chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "${to}"
        } # end link_it

        function remove_it() {
            # Sample use
            #            remove_it  /usr/local/rvm
            #            remove_it  /usr/local/rvm /usr/local/.nvm  /usr/local/rvm  /root/.temp
            local paths=$(switch_spaces_to_newlines <<< "${@}")
            local actions="
                [ -e \"{#}\" ] && rm -rf \"{#}\"
                [ -L \"{#}\" ] && unlink \"{#}\"
            "
            .each  "${actions}"   "${paths}"
        } # end remove_it

        function _term() {
            # Sample usage
            # REF: http://man7.org/linux/man-pages/man7/signal.7.html
            # REF: https://unix.stackexchange.com/questions/146756/forward-sigterm-to-child-in-bash
            #        trap _term SIGTERM

            #         echo "Doing some initial work...";
            #         /bin/start/main/server --nodaemon &

            #         child=$!
            #         wait "$child"
            echo "Caught SIGTERM signal!"
            kill -TERM "$child" 2>/dev/null
        } # end _term

        function .each() {
            # Sample use
            #           Prepare .each
            #           ITEMS=$(find . -maxdepth 0 -type d | egrep -v "\.git")
            #           Each ITEM will be executed in {#} \/ ----------\/
            #           ACTIONS="echo \"Showing list for {#}\"  ls -la {#} "
            #
            #                    Perform all actions in
            #                           ACTIONS
            #                             for each ITEM in       as {#}
            #                                              ITEMS
            #           Note ESCape all !, ", $ with \ like \!, \", \$
            #           Call .each
            #           .each  "${ACTIONS}"   "${ITEMS}"
            local local_actions="${1}"
            local local_items="${2}"
            local one_item
            local one_action
            local action
            local child
            local ret
            while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                      while read -r one_action; do
                      {
                            if [ ! -z "${one_action}" ] ; then  # if not empty
                            {
                                  # replace value inside string substitution expresion bash
                                  trap _term SIGTERM
                                  action="${one_action/\{\#\}/${one_item}}"
                                  action="${action/\{\#\}/${one_item}}"
                                  action="${action/\{\#\}/${one_item}}"
                                  eval """${action}"""
                                  ret=$?
                                  if [ $ret -gt 0 ] ; then
                                  {
                                    child=$!
                                    wait $child
                                    warning "${YELLOW}Error SIGNAL_RETURN(${RED}${ret}${YELLOW}) executing: \n${action}"
                                  }
                                  fi
                            }
                            fi
                      }
                      done <<< "${local_actions}"
                }
                fi
            }
            done <<< "${local_items}"
        } # end .each

        function .mix_with() {
            # Sample use
            #           ITEMS="1
            #                  2
            #                  3
            #                  4
            #                  5
            #                  "
            #           Each ITEM will be executed in {#} \/ ----------\/
            #           LIST2="echo \"Showing list for {#}\"  ls -la {#} "
            #
            #          Mixes as items in
            #                           ITEMS
            #                             for each element in
            #                                              ELEMENTS
            #           Note ESCape all ", $ with \ like \", \$
            #           Call .mix_with
            #           .mix_with "\\n"  "${ELEMENTS}"   "${ITEMS}"
            local glue="${1}"
            local local_actions="${2}"
            local local_items="${3}"
            local one_item
            local one_action
            local action

            while read -r one_item; do
            {
                if [ ! -z "${one_item}" ] ; then  # if not empty
                {
                      while read -r one_action; do
                      {
                            if [ ! -z "${one_action}" ] ; then  # if not empty
                            {
                                  echo """${one_action}${glue}${one_item}"""
                            }
                            fi
                      }
                      done <<< "${local_actions}"
                }
                fi
            }
            done <<< "${local_items}"
        } # end .mix_with
enter_last_only_removed() {
  #sed ':a;N;$!ba;s/\n$//g' # GNU sed
  sed -e ':a' -e 'N' -e '$!ba' -e 's/\n$//g'  #  cross-platform compatible syntax which works with BSD sed
}

        # enter_last_only_removed() {
        #  sed ':a;N;$!ba;s/\n$//g' # GNU sed
        function trim_end_newlines() {
            sed -e ':a' -e 'N' -e '$!ba' -e 's/\n$//g'  #  cross-platform compatible syntax which works with BSD sed
        }
        # end trim_end_newlines
        # }

          #sed ':a;N;$!ba;s/\n/0N33NT3R/g'  # GNU sed
        function enter_encode() {
          sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/0N33NT3R/g'  #  cross-platform compatible syntax which works with BSD sed
        }
        # end enter_encode

        function enter_decode() {
          sed 's/0N33NT3R/\n/g'
        }
        # end enter_decode

            # Sample use
            #            test1="asdf xcvb qwe sdfs "
            #            test2="asdf\nasdf\nasdf"
            #            ( ! contains_newlines "${test1}" ) && echo "no newlines"
            #            ( contains_newlines "${test2}" ) && echo "newlines"
            #            if ! contains_newlines "${test1}" ; then
            #            if contains_newlines "${test2}" ; then
            # ' Here I changed \n to 0N33NT3R' why? - For a weird reasons when assigning a var " " it adds \n to the  end of it so t="a" is actually t="a\n"
        function contains_newlines() {
            echo "${@}" | enter_encode
            local trimmed_testing=$(echo "${@}" | enter_encode)
            [[ "${trimmed_testing}" == *"0N33NT3R"* ]] && return 0 # true contains enters
            return 1 # false no newlines
        }
        # end contains_newlines

            # Sample use
            #           you have:       /root/.folder
            #           and you want:  to move from  __root__     to     /home/${USER_TO_INSTALL}
            #           and link it back
            #           and you want:   /root/.folder  --->  /home/${USER_TO_INSTALL}/.folder
            #
            #            sudo mkdir /root/.test
            #            sudo out_of_root_folder_and_soft_link_back docker .test
            #            sudo out_of_root_folder_and_soft_link_back vagrant .test
            #            sudo out_of_root_folder_and_soft_link_back "${USER_TO_INSTALL}" .bundle
            #            sudo out_of_root_folder_and_soft_link_back "${USER_TO_INSTALL}" .bundle .gem .gems
        function out_of_root_folder_and_soft_link_back() {
            local USER_TO_INSTALL="${1}"
            if ( contains_newlines "${@}" ); then
            {
                local targets="${@}"
            }
            else
            {
                local targets=$(echo "${@}" | switch_spaces_to_newlines)
            }
            fi
            echo "${targets}"
            local actions="
                [ -d \"/home/${USER_TO_INSTALL}/{#}/\" ] &&  rm -rf \"/home/${USER_TO_INSTALL}/{#}/\"
                [ -d \"/root/{#}/\" ] &&  mv \"/root/{#}\" \"/home/${USER_TO_INSTALL}/\"
                [ -d \"/home/${USER_TO_INSTALL}/{#}/\" ] &&  ln -sf  \"/home/${USER_TO_INSTALL}/{#}\" \"/root/{#}\"
                [ -d \"/home/${USER_TO_INSTALL}/{#}/\" ] &&  chown -R \"${USER_TO_INSTALL}\":\"${USER_TO_INSTALL}\" \"/home/${USER_TO_INSTALL}/{#}/\"
            "
            .each  "${actions}"   "${targets}"
        }
        # end out_of_root_folder_and_soft_link_back

            # Sample use
            #            out_of_root_file_and_soft_link_back "${USER_TO_INSTALL}" .bundle
            #            out_of_root_file_and_soft_link_back "${USER_TO_INSTALL}" .bundle .gem .gems
        function out_of_root_file_and_soft_link_back() {
            local USER_TO_INSTALL="${1}"
            if contains_newlines "${@}" ; then
            {
                local targets="${@}"
            }
            else
            {
                local targets=$(echo "${@}" | switch_spaces_to_newlines)
            }
            fi
            local actions="
                [ -f \"/home/${USER_TO_INSTALL}/{#}\" ] &&  rm -rf \"/home/${USER_TO_INSTALL}/{#}\"
                [ -f \"/root/{#}\" ] &&  mv \"/root/{#}\" \"/home/${USER_TO_INSTALL}\"
                [ -f \"/home/${USER_TO_INSTALL}/{#}\" ] &&  ln -sf  \"/home/${USER_TO_INSTALL}/{#}\" \"/root/{#}\"
                [ -f \"/home/${USER_TO_INSTALL}/{#}\" ] &&  chown -R \"${USER_TO_INSTALL}\":\"${USER_TO_INSTALL}\" \"/home/${USER_TO_INSTALL}/{#}\"
            "
            .each  "${actions}"   "${targets}"
        }
        # end out_of_root_file_and_soft_link_back

        function move_to_user_folder_and_soft_link_root_to_it() {
            local USER_TO_INSTALL="${1}"
            local target="${2}"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] &&  rm -rf "/home/${USER_TO_INSTALL}/${target}/"
            [ -d "/root/${target}/" ] &&  mv "/root/${target}" "/home/${USER_TO_INSTALL}/"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] &&  ln -sf  "/home/${USER_TO_INSTALL}/${target}" "/root/${target}"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] &&  chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/home/${USER_TO_INSTALL}/${target}/"
            [ -d "/home/${USER_TO_INSTALL}/${target}/" ] &&  chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/root/${target}"
        }
        alias move_folder_out_root_to_user_and_link_it_back=move_to_user_folder_and_soft_link_root_to_it

        function move_to_user_file_and_soft_link_root_to_it() {
            local USER_TO_INSTALL="${1}"
            local target="${2}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] &&  rm -rf "/home/${USER_TO_INSTALL}/${target}"
            [ -f "/root/${target}" ] &&  mv "/root/${target}" "/home/${USER_TO_INSTALL}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] &&  ln -sf  "/home/${USER_TO_INSTALL}/${target}" "/root/${target}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] &&  chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/home/${USER_TO_INSTALL}/${target}"
            [ -f "/home/${USER_TO_INSTALL}/${target}" ] &&  chown -R "${USER_TO_INSTALL}":"${USER_TO_INSTALL}" "/root/${target}"
        }
        alias move_file_out_root_to_user_and_link_it_back=move_to_user_file_and_soft_link_root_to_it

##############           ##############             ####      ####           ##############               ############             ##############             ####      ####
##############           ##############             ####      ####           ##############               ############             ##############             ####      ####
    ######               ####        ####             ####  ####             ####        ####           ####        ####           ####        ####             ####  ####
    ######               ####        ####             ####  ####             ####        ####           ####        ####           ####        ####             ####  ####
    ######               ####        ####               ######               ##############             ####        ####           ####        ####               ######
    ######               ####        ####               ######               ##############             ####        ####           ####        ####               ######
    ######               ##############                 ######               ####        ####           ####        ####           ####        ####               ######
    ######               ##############                 ######               ####        ####           ####        ####           ####        ####               ######
    ######               ####      ####                 ######               ####        ####           ####        ####           ####        ####               ######
    ######               ####      ####                 ######               ####        ####           ####        ####           ####        ####               ######
    ######               ####        ####               ######               ##############               ############             ##############                 ######
    ######               ####        ####               ######               ##############               ############             ##############                 ######


# SUDO_USER only exists during execution of sudo
# REF: https://stackoverflow.com/questions/7358611/get-users-home-directory-when-they-run-a-script-as-root
# Global:
# THISSCRIPTNAME=`basename "$0"`

function execute_as_sudo(){
    # Sample use:
    # being of script add
    # THISSCRIPTNAME=`basename "$0"`
    # ...
    # execute_as_sudo
    # USER_HOME=$(getent passwd $SUDO_USER | cut -d: -f6)
    # passed Caller user identified:$USER_HOME
    #
  if [ -z $SUDO_USER ] ; then
    if [[ -z "$THISSCRIPTNAME" ]] ; then
    {
        echo "error You need to add THISSCRIPTNAME vairable like this:"
        echo "     THISSCRIPTNAME=\`basename \"\$0\"\`"
    }
    else
    {
        if [ -e "./$THISSCRIPTNAME" ] ; then
        {
          sudo "./$THISSCRIPTNAME"
        }
        elif ( command -v type "$THISSCRIPTNAME" >/dev/null 2>&1 );  then
        {
          echo "sudo sudo sudo "
          sudo "$THISSCRIPTNAME"
        }
        else
        {
          echo -e "\033[05;7m*** Failed to find script to recall it as sudo ...\033[0m"
          exit 1
        }
        fi
    }
    fi
    wait
    exit 0
  fi
  # REF: http://superuser.com/questions/93385/run-part-of-a-bash-script-as-a-different-user
  # REF: http://superuser.com/questions/195781/sudo-is-there-a-command-to-check-if-i-have-sudo-and-or-how-much-time-is-left
  local CAN_I_RUN_SUDO=$(sudo -n uptime 2>&1|grep "load"|wc -l)
  if [ ${CAN_I_RUN_SUDO} -gt 0 ]; then
    echo -e "\033[01;7m*** Installing as sudo...\033[0m"
  else
    echo "Needs to run as sudo ... ${0}"
  fi
} # end execute_as_sudo

function _download_win() {
   curl -O "${*}"
} # end _download_win

function progressfilt() {
    # REF https://stackoverflow.com/questions/4686464/how-to-show-wget-progress-bar-only
    # Usage Usage:
    # $ wget --progress=bar:force http://somesite.com/TheFile.jpeg 2>&1 | progressfilt
    # 100%[======================================>] 15,790      48.8K/s   in 0.3s
    # 2011-01-13 22:09:59 (48.8 KB/s) - 'TheFile.jpeg' saved [15790/15790]
    local flag=false c count cr=$'\r' nl=$'\n'
    while IFS='' read -d '' -rn 1 c; do
    {
        if $flag;  then
        {
            printf '%s' "$c"
        }
        else
        {
            if [[ $c != $cr && $c != $nl ]];   then
            {
              count=0
            }
            else
            {
                (( count++ ))
                if (( count > 1 )) ;               then
                {
                 flag=true
                }
                fi
            }
            fi
        }
        fi
    }
    done
} # end progressfilt

function _download_mac() {
    # -c Resume Downloads  -c option only works with FTP / HTTP servers that support the â€œrangeâ€ header
  if ( command -v type wget >/dev/null 2>&1; ) ; then
    # REF: https://www.linuxquestions.org/questions/linux-general-1/how-to-create-a-bash-script-to-wait-for-wget-to-finish-and-then-continue-621754/
    for url in $(echo "${@}"); do
    {
        # _try wget -c --directory-prefix=\"${USER_HOME}/Downloads/\"  --quiet --no-check-certificate "${@}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
        echo "wget -c --progress=bar:force --directory-prefix=\"${USER_HOME}/Downloads/\" --no-check-certificate \"${@}\" 2>&1 | progressfilt"
        wget -c --progress=bar:force --directory-prefix="${USER_HOME}/Downloads/" --no-check-certificate "${@}" 2>&1 | progressfilt
        # wget -c --directory-prefix=\"${USER_HOME}/Downloads/\"  --quiet --no-check-certificate "${@}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
    }
    done
  elif ( command -v type curl >/dev/null 2>&1; ); then
    _try curl -LO "${@}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
    wait
  else
    failed "I cannot find wget or curl to download! ${@}"
  fi
} # end _download_mac

function _download() {
    # check operation systems
    if [[ "$(uname)" == "Darwin" ]] ; then
    # Do something under Mac OS X platform
      _download_mac "${@}"
    elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]] ; then
    # Do something under GNU/Linux platform
      _download_linux "${@}"
    elif [[ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" ]] ; then
    # Do something under Windows NT platform
      _download_win "${*}"
    # nothing here
    fi
} # end _download

function _download_linux() {


# You're close. The correct way to approach this is using the HEAD method.

# With cURL:

# if curl --head --silent --fail ftp://ftp.somewhere.com/bigfile.gz 2> /dev/null;
#  then
#   echo "This page exists."
#  else
#   echo "This page does not exist."
# fi

# or using wget:

# if wget -q --method=HEAD ftp://ftp.somewhere.com/bigfile.gz;
#  then
#   echo "This page exists."
#  else
#   echo "This page does not exist."
# fi


  local thisscriptname=$(dirname "struct_testing")
  _trap_try_start
  local target_url="${1}"
  local download_folder=""
  if [ -n "${2}" ] ; then # if not empty
    {
        download_folder="${2} "
    }
  fi
  echo "     target url 1:${1} "
  [ -z "${1}" ] && echo "empty"
  echo "download folder 2:${2} "
  [ -z "${2}" ] && echo "empty"
  echo "  download file 3:${3} "
    #   [ -z "${3}" ] && echo "empty"
    #   echo
    # echo "# arguments called with ---->  ${@}     "
    # echo "# \$1 ---------------------->  $1       "
    # echo "# \$2 ---------------------->  $2       "
    # echo "# path to me --------------->  ${0}     "
    # echo "# parent path -------------->  ${0%/*}  "
    # printf '$0 is: %s\n$BASH_SOURCE is: %s\n' "$0" "$BASH_SOURCE"
    # echo "# my name ------------------>  ${0##*/} "
    # echo
  [ -z "${1}" ] && failed \\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 1.target_url string or it was empty. Expected one Parameter URL
  [ -z "${2}" ] && failed \\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 2.download_folder string or it was empty. Expected one Parameter URL
  [ -z "${3}" ] && failed \\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\nCould not load 3.download_file string or it was empty. Expected one Parameter URL
  local download_file="${3}" || ""

  _trap_catch_check
  # wget --directory-prefix="${USER_HOME}/Downloads/" --quiet --no-check-certificate "${target_url}" 2>/dev/null
  echo -e "\033[01;7m*** Downloading file to temp location...\033[0m"

  if ( command -v type wget >/dev/null 2>&1; ) ; then
    ensure wget or "Wget is required"
    # # REF: about :> http://unix.stackexchange.com/questions/37507/what-does-do-here
    _trap_try_start
    :> /tmp/wgetrc   # here :> equals to Equivalent to the following: cat /dev/null > wgetrc which Nulls out the file called "wgetrc" in the current directory. As in creates an empty file "wgetrc" if one doesn't exist or overwrites one with nothing if it does.
    _trap_catch_check
    file_exists_with_spaces /tmp/wgetrc
    _trap_try_start
    echo "noclobber=off" >> /tmp/wgetrc
    _trap_catch_check
    echo "dirstruct=off" >> /tmp/wgetrc
    # echo "verbose=off" >> /tmp/wgetrc    # NOTE Can't be verbose and quiet at the same time.--quiet
    echo "verbose=on" >> /tmp/wgetrc    # NOTE Can't be verbose and quiet at the same time.--quiet
    echo "progress=bar:default" >> /tmp/wgetrc
    echo "tries=3" >> /tmp/wgetrc
    echo "max-redirect=10" >> /tmp/wgetrc
    echo "check_certificate=off" >> /tmp/wgetrc
    echo "mirror=on" >> /tmp/wgetrc
    echo "content_disposition=on" >> /tmp/wgetrc
    echo "dir_prefix=." >> /tmp/wgetrc
    # echo "dir_prefix=${download_folder}" >> /tmp/wgetrc
    # echo "output_document=${download_file}" >> /tmp/wgetrc   # Set the output filename--the same as '-O FILE'.
    # echo "input=${target_url}" >> /tmp/wgetrc   #  Read the URLs from STRING, like '-i FILE'.
    # _trap_try_start # _trap_catch_check
    # WGETRC=wgetrc wget --directory-prefix="${USER_HOME}/Downloads/" --quiet --no-check-certificate "${target_url}" 2>/dev/null
    #  _trap_catch_check
    # WGETRC=/tmp/wgetrc wget --quiet --no-check-certificate "${target_url}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
    # _try "WGETRC=/tmp/wgetrc wget --mirror --directory-prefix=\"${download_folder}\" --quiet --no-check-certificate \"${target_url}\"" # 2>/dev/null"
    _trap_try_start # _trap_catch_check
    WGETRC=/tmp/wgetrc
    # WGETRC=/tmp/wgetrc wget --max-redirect=10 --mirror --directory-prefix="${download_folder}" --no-check-certificate "${target_url}" # 2>/dev/null"
    # WGETRC=/tmp/wgetrc wget --mirror --content-disposition "${download_folder}" "${download_file}" --no-check-certificate "${target_url}" # 2>/dev/null"
    local WGETCOMMAND=""
    echo "WGET:"
    echo "OPTIONS WGETRC:"
    cat -n /tmp/wgetrc
    echo "COMMAND WGET:"
    passed "WGETRC=/tmp/wgetrc wget --max-redirect=10 --mirror --directory-prefix="${download_folder}" -O "${download_file}" --no-check-certificate "${target_url}""
    wget --max-redirect=10 --mirror --directory-prefix="${download_folder}" -O "${download_file}" --no-check-certificate "${target_url}" # 2>/dev/null"
    # WGETRC=/tmp/wgetrc wget "${WGETCOMMAND}" # 2>/dev/null"
    _trap_catch_check
    _assure_success
    echo "${msg}"
    echo -e "\033[7m*** Download Wget executed completed.\033[0m"
    rm -f /tmp/wgetrc
    file_does_not_exist_with_spaces wgetrc
  elif ( command -v type curl >/dev/null 2>&1; ); then
    ensure curl or "curl is required"
    curl -O "${target_url}" 2>/dev/null   # suppress only wget download messages, but keep wget output for variable
    _assure_success
  else
    failed \\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[-0]}\(\) \\n$0:${BASH_LINENO[1]} ${FUNCNAME[1]}\(\) \\n"I cannot find wget or curl programs to perform a download action! ${target_url}"
  fi
} # end _download_linux


function _assure_success() {
  if [ $? != 0 ] ; then
    failed -e "\033[38;5;1m Something went wrong \033[0m"
    exit 1
  fi
  wait
}

function _trap_try_start() {
  trap _term SIGTERM
}

function _trap_catch_check() {
  declare -i ret=$?
  local child
  if [ $ret -gt 0 ] ; then
  {
    child=$!
    wait $child
    warning "${YELLOW}Error SIGNAL_RETURN(${RED}${ret}${YELLOW}) executing: \n${action}"
    return 1 # non zero is error
  }
  fi
  return 0
}

function _action_runner() {
  local action
  while read -r action ; do
  {
    if [[ ! -z "${action}" ]] ; then # if not empty
    {
      _trap_try_start
      echo "${action}"
      "${action}"
      _trap_catch_check
    }
    fi
  }
  done <<< "${@}"
} # end _action_runner

function _try_runner() {
  local body=$(_function_body "${1}")
  function_exists "${1}"
  while read -r action ; do
  {
    if [[ ! -z "${action}" ]] ; then # if not empty
    {
      _trap_try_start
      echo "${action}"
      "${action}"
      _trap_catch_check
    }
    fi
  }
  done <<< "${body}"
} # end _try_runner

function _function_body() {
  local functionname="${1}"
  # function_exists "${functionname}"
  # ensure head or Cancel. Missing head command
  # ensure tail or Cancel. Missing tail command
  # ensure declare or Cancel. Missing declare command
  # ensure wc or Cancel. Missing declare command
  local functioncomplete=$(declare -f "${functionname}")
  # echo complete:"${functioncomplete}"
  local functionbody=$(echo "${functioncomplete}" | cÃ¼t "${functionname} ()")
  # echo body:"${functionbody}"
  local functionlength=$(echo "${functionbody}" | wc -l)
  # echo length:${functionlength}
  # echo less:${functionlengthless}
  (( functionlength-- ))
  # echo lenght:${functionlength}
  functionbody=$(echo "${functionbody}" | head -${functionlength} )
  # echo body:"${functionbody}"
  (( functionlength-- ))
  # echo length:${functionlength}
  functionbody=$(echo "${functionbody}" | tail -${functionlength} )
  # echo body:"${functionbody}"
  echo "${functionbody}"
}

function _try_body() {
  local body=$(_function_body "${1}")
  _trap_try_start
  echo "${body}"
  "${body}"
  _trap_catch_check
}

function _try() {
  local body="${@}"
  _trap_try_start
  echo -e "\033[01;7m***${body}\033[0m***"
  local msg="${body}"
  declare -i ret=_trap_catch_check
  echo "${msg}"
  unset body
  unset msg
  if [ $ret -gt 0 ] ; then
    unset ret
    return 1
  else
    unset ret
    return 0
  fi
}


function function_is_defined_with_spaces() {
		    # Sample usage
		    #
		    #          if  ! function_is_defined_with_spaces "/home/vagrant/.zshrc" ; then    is like is NOT installed
		    #          if  function_is_defined_with_spaces "/root/.zshrc ; then      it makes more sense to make it this way
		    #
            local ONE_FUNCTION FUNCTIONS="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FUNCTION; do
                # if not empty
                if [ ! -z "${ONE_FUNCTION}" ] ; then
                    if [ -n "$(LC_ALL=C type -t "${ONE_FUNCTION}")" ] && [ "$(LC_ALL=C type -t "${ONE_FUNCTION}")" = function ]; then
                    {
                        return 0 # function exists
                    }
                    fi
                fi
                done <<< "${FUNCTIONS}"
                return 1 # function does not exists
            }
            fi
            unset ONE_FUNCTION
            unset FUNCTIONS
            unset TESTING
} # end function_is_defined_with_spaces

function function_is_defined() {
            # Sample usage
            #
            #          if  ! function_is_defined determine_os_and_fire_action ; then    is like is NOT installed
            #          if  function_is_defined "$FUNCTION_TO_CALL" ; then      it makes more sense to make it this way
            #
            local ONE_FUNCTION FUNCTIONS="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                FUNCTIONS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_FUNCTION; do
                # if not empty
                if [ ! -z "${ONE_FUNCTION}" ] ; then
	            if [ -n "$(LC_ALL=C type -t "${ONE_FUNCTION}")" ] && [ "$(LC_ALL=C type -t "${ONE_FUNCTION}")" = function ]; then
                    {
                        return 0 # function exists
                    }
                    fi
                fi
                done <<< "${FUNCTIONS}"
                return 1 # function does not exists
            }
            fi
            unset ONE_FUNCTION
            unset FUNCTIONS
            unset TESTING

} # end function_is_defined

function function_exists() {
            # Sample usage
            #
            #     function_exists determine_os_and_fire_action
            #     function_exists  "$FUNCTION_TO_CALL"
            #     function_exists "Function1
	        #                      Function2
            #                      Function2"
            #
            local TESTING ONE_FUNCTION FUNCTIONS="${@}"
            if [ ! -z "${FUNTIONS-x}" ] ; then # if its set and not empty
            {
                FUNCTIONS=$(switch_spaces_to_newlines <<< "${@}")
                while read -r ONE_FUNCTION; do
                if [ ! -z "${ONE_FUNCTION}" ] ; then # if not empty
                    TESTING="that function ${CYAN}${ONE_FUNCTION}${LIGHTYELLOW} exists"
                    if function_is_defined "${ONE_FUNCTION}" ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${FUNCTIONS}"
            }
            fi
	    unset ONE_FUNCTION
	    unset FUNCTIONS
	    unset TESTING

} # end function_exists

# function_exists ls
# build_table_from_installed_components $USER
# build_table_from_installed_components $SUDO_USER

function function_exists_with_spaces() {
            # Sample usage
            #
            #     function_exists_with_spaces determine_os_and_fire_action
            #     function_exists_with_spaces  "$FUNCTION_TO_CALL"
	        #     function_exists_with_spaces "Function1
            #                      Function2
            #                      Function2"
            #
            local TESTING ONE_FUNCTION FUNCTIONS="${@}"
            if [ ! -z "${FUNTIONS-x}" ] ; then # if its set and not empty
            {
                while read -r ONE_FUNCTION; do
                if [ ! -z "${ONE_FUNCTION}" ] ; then # if not empty
                    TESTING="that function ${CYAN}${ONE_FUNCTION}${LIGHTYELLOW} exists"
                    if function_is_defined_with_spaces "${ONE_FUNCTION}" ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
			done <<< "${FUNCTIONS}"
            }
            fi
            unset ONE_FUNCTION
            unset FUNCTIONS
            unset TESTING
} # end function_exists_with_spaces

function determine_os_and_fire_action() {
  # Interface
  # How to use
  # First implement the target functions
  #              _fedora__64(){ }
  #              _fedora__32(){ }
  #              _ubuntu__64(){ }
  #              _ubuntu__32(){ }
  #              _mingw__64(){ }
  #              _mingw__32(){ }
  #              _darwin__64(){ }
  #              _darwin__32(){ }
  # Then call this function
  #              determine_os_and_fire_action  """${*}"""
  # remember to pass the  """${*}""" for the parameters to pass
  # If will fail is the function has not been implemented with Error message
  # of the function that is missing like _archlinux__64
  local FUNCTION_TO_CALL=""
  local PARAMETERS=""
  # Check operating systems
  # echo  ${@}
  if [[ "$(uname)" == "Darwin" ]] ; then
      # Do something under Mac OS X platform
      if [[ "$(uname -m)" == "x86_64" ]] ; then
      {
	     FUNCTION_TO_CALL='_darwin__64'
	     PARAMETERS="$@"
      }
      elif [[ "$(uname -m)" == "i686"   ]] ; then
      {
	     FUNCTION_TO_CALL='_darwin__32'
	     PARAMETERS="$@"
      }
      fi
  elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]] ; then
    # Do something under GNU/Linux platform
    # Determine OS platform
    local UNAME=$(uname | tr "[:upper:]" "[:lower:]")
    local DISTRO=""
    local ID=""
    local VERSION_ID=""
    # If Linux, try to determine specific distribution
    if [ "$UNAME" == "linux" ]; then
        # If available, use LSB to identify distribution
        if [ -f /etc/lsb-release -o -d /etc/lsb-release.d ]; then
	    if ( command -v type lsb_release >/dev/null 2>&1; ); then
            {
              DISTRO=$(lsb_release -i | cut -d: -f2 | sed s/'^\t'//)
            }
            else
            {
              DISTRO=$(ls -d /etc/[A-Za-z]*[_-][rv]e[lr]* | grep -v "lsb" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1)
	    }
            fi
        # Otherwise, use release info file
        else
            DISTRO=$(ls -d /etc/[A-Za-z]*[_-][rv]e[lr]* | grep -v "lsb" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1)
        fi
    fi
    if [[ -z "$DISTRO" ]]; then  # if empty
    {
      # If available, use /etc/os-release to identify distribution
        if [ -f /etc/os-release ]; then
        {
		source /etc/os-release
                # file_exists "/etc/os-release"
                _assure_success
                # source /etc/os-release
                # $ echo $ID
                # fedora
                # $ echo $VERSION_ID
                # 17
                # $ echo $VERSION
                # 17 (Beefy Miracle)
                DISTRO=$ID
	}
        fi
    }
    fi
    if [[ -z "$DISTRO" ]]; then  # if empty
    {
        failed to determine DISTRO for this linux. uname -a, cat /etc/os-release, lsb_release -i
    }
    fi

    if [[ "$DISTRO" == *"edora"* ]]; then
    {
        if [[ "$(uname -i)" == "x86_64" ]] ; then
        {
	        FUNCTION_TO_CALL='_fedora__64'
	        PARAMETERS="$@"
        }
        elif [[ "$(uname -i)" == "i686"   ]] ; then
	    {
	        FUNCTION_TO_CALL='_fedora__32'
            PARAMETERS="$@"
        }
	    fi
    }
    elif [[ "$DISTRO" == *"untu"* ]]; then
    {
        # ubuntu lsb_release -i | sed 's/Distributor\ ID://g' = \tUbuntu\n
        if [[ "$(uname -i)" == "x86_64" ]] ; then
        {
           FUNCTION_TO_CALL='_ubuntu__64'
           PARAMETERS="$@"
        }
        elif [[ "$(uname -i)" == "i686"   ]] ; then
        {
	       FUNCTION_TO_CALL='_ubuntu__32'
	       PARAMETERS="$@"
	    }
	    fi
    }
    fi
    # For everything else (or if above failed), just use generic identifier
    unset UNAME
    unset DISTRO
    unset ID

  elif [[ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" ]] ; then
    # Do something under Windows NT platform
    if [[ "$(uname -i)" == "x86_64" ]] ; then
    {
      FUNCTION_TO_CALL='_mingw__64'
      PARAMETERS="$*"
    }
    elif [[ "$(uname -i)" == "i686"   ]] ; then
    {
      FUNCTION_TO_CALL='_mingw__32'
      PARAMETERS="$*"
    }
    fi
    # nothing here
  else
    failed system not recognized
  fi
  if [[ -z "$FUNCTION_TO_CALL" ]]; then  # if empty
  {
     failed to determine FUNCTION_TO_CALL for this OS. uname -a, cat /etc/os-release, lsb_release -i
  }
  else
  {
        if function_is_defined "${FUNCTION_TO_CALL}" ; then
        {
           "${FUNCTION_TO_CALL}" "${PARAMETERS}"
	        _assure_success
        }
        else
        {
	       failed to find function for this OS or DISTRO:  "${FUNCTION_TO_CALL}" "${PARAMETERS}"
	       _assure_success
        }
	fi

  }
  fi
  _assure_success
  unset FUNCTION_TO_CALL
  unset PARAMETERS
} # end determine_os_and_fire_action

    #[ ! -z "$0" ] && [ -e "$0" ] && THISSCRIPTNAME=`basename "$0"`

    # TRAP
    #[ ! -z "$0" ] && [   -e "$0" ] &&  trap '{  \" `basename "$0"` KEYBOARD INTERRUPT.\"; exit 69; }' INT
    #[   -z "$0" ] && [ ! -e "$0" ] &&  trap '{  \" STRUCT TESTING KEYBOARD INTERRUPT.\"; exit 69; }' INT
    #[ ! -z "$0" ] && [ ! -e "$0" ] &&  trap '{  \" STRUCT TESTING KEYBOARD INTERRUPT.\"; exit 69; }' INT

        #
        # Template:
        #
        #  echo -e "${GREEN} Installing ${RED}PYENV${GREEN} and ${CYAN} {PYTHON_VERSION}  ${CERO}"
        #
        #  procedure "${PYTHON_VERSION}"  >/dev/null 2>&1 # suppress stdln and errln output
        #
        #  Testing Checking install
        #  FOLDER MUST EXIST  /home/vagrant/.pyenv
        #  LINK MUST EXIST /root/.pyenv
        #  Python Must be PYTHON VERSION
        #
        #  directory_exists "/home/vagrant/.pyenv"
        #  file_exists "/home/vagrant/.zshrc"
        #  softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
        #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
        #
        #  CURRENT_VERSION=$(cat /home/vagrant/.pyenv/version)
        #  check_equality "${CURRENT_VERSION}=${PYTHON_VERSION}"

        #  echo -e " END ${THISSCRIPTNAME} ${CERO}"
        #  echo -e "${RED}  END ${THISSCRIPTNAME} ${CERO}"
        #  echo -e " END ${THISSCRIPTNAME} ${CERO}"

#
# STRUCT TESTING - END
#

   ##                    ######## ##    ## ########
  ##                     ##       ###   ## ##     ##
 ##                      ##       ####  ## ##     ##
##    ####### #######    ######   ## ## ## ##     ##
 ##                      ##       ##  #### ##     ##
  ##                     ##       ##   ### ##     ##
   ##                    ######## ##    ## ########

 ######  ######## ########  ##     ##  ######  ########
##    ##    ##    ##     ## ##     ## ##    ##    ##
##          ##    ##     ## ##     ## ##          ##
 ######     ##    ########  ##     ## ##          ##
      ##    ##    ##   ##   ##     ## ##          ##
##    ##    ##    ##    ##  ##     ## ##    ##    ##
 ######     ##    ##     ##  #######   ######     ##

######## ########  ######  ######## #### ##    ##  ######
   ##    ##       ##    ##    ##     ##  ###   ## ##    ##
   ##    ##       ##          ##     ##  ####  ## ##
   ##    ######    ######     ##     ##  ## ## ## ##   ####
   ##    ##             ##    ##     ##  ##  #### ##    ##
   ##    ##       ##    ##    ##     ##  ##   ### ##    ##
   ##    ########  ######     ##    #### ##    ##  ######

