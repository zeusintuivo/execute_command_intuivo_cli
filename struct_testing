#!/bin/bash
#
# @author Zeus Intuivo <zeus@intuivo.com>
#
#
# Helper For testing installations, check files, softlinks, etc......checklist style

# Sample use

function sample_use_verify_mongo() {


    MONGO_VERSION="3.0.11"
    if [ ! -z "${1}" ] ;  then
        MONGO_VERSION="${1}"
    fi

    echo -e "${GREEN} Verify mongo version"
    CURRENT_VERSION=$(mongo --version  | egrep "MongoDB shell version" | head -1  | cut -d' ' -f4 | cut -d'v' -f2)
    check_equality "${CURRENT_VERSION}=${MONGO_VERSION}"
    echo -e "${GREEN} Verify mongod version"
    MONGOD_VERSION=$(mongod --version | egrep "db version" | head -1 | cut -d'v' -f3)
    check_equality "${MONGOD_VERSION}=${MONGO_VERSION}"

    TESTING=" verify that MongoDB has started ${CYAN}successfully${LIGHTYELLOW}"
    if [ ! -z "${MONGO_PID}" ] && [ ! -z "${MONGO_TASKID}" ] && [[ "${MONGO_SERVICE_STATUS}" == *"mongod start/running"* ]] ; then
    {

        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}       Service Status: ${CYAN}${MONGO_SERVICE_STATUS} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}            Mongo PID: ${CYAN}${MONGO_PID} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}        Mongo Task ID: ${CYAN}${MONGO_TASKID} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}      Which Mongo cli: ${CYAN}${WHICH_MONGO} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}        Mongo version: ${CYAN}${CURRENT_VERSION} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}   Which Mongo Server: ${CYAN}${WHICH_MONGOD} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW} Mongo Server version: ${CYAN}${MONGOD_VERSION} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}     Log last 4 lines: ${CYAN}${MONGO_LOG} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}     hugepage/enabled: ${CYAN}${FILE_CONTENTS_ENABLED} "
        echo -e " ${PURPLE}+---- ${LIGHTYELLOW}      hugepage/defrag: ${CYAN}${FILE_CONTENTS_DEFRAG} "
        passed "${TESTING}"

    }
    else
    {
        failed "${TESTING}"
    }
    fi

    directory_exists "
    /data
    /data/db
    /var/log/mongodb
    "

    # Disabled
    #/_/version-manager                             # Patch mongoo-manager form nodejs
    #/home/vagrant/.mongodb
    #softlink_exists "/root/.mongodb>/home/vagrant/.mongodb"

    file_exists "/etc/mongod.conf
    /etc/init/mongod.conf
    /etc/sysfs.conf
    /etc/mongo_vm_settings.conf
    /sys/kernel/mm/transparent_hugepage/khugepaged/defrag
    /sys/kernel/mm/transparent_hugepage/defrag
    /sys/kernel/mm/transparent_hugepage/enabled
    "
    # Extra notes
    # /etc/init/mongod.conf                           # This is the mongo service start|stop|status
    # /etc/default/mongod                             # There is ref to this file inside the service /etc/init/mongod.conf

    # Disabled
    #/etc/systemd/system/mongodb-hugepage-fix.service # service systemd  16.04
    #/etc/systemd/system/mongodb.service              # service systemd  16.04
    #/_/version-manager/bin/m.js                      # Patch mongoo-manager form nodejs
    #/_/version-manager/package.json                  # Patch mongoo-manager form nodejs

    #  softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
    #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
    #

} # end function sample_use_verify_mongo

function HOW_TO_LOAD_SEVERAL_FILES() {

    load_execute_commands_wget(){
        local URL=""
        local cached_directory="/_/clis/execute_command_intuivo_cli/"
        local EXECOMCLI=""
        local provider=""
        [   -d "${cached_directory}" ] &&  provider="file://${cached_directory}"
        [ ! -d "${cached_directory}" ] &&  provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/"
        local BASH_SCRIPTS="
    struct_testing
    execute_command
    "
    #execute_command
        while read -r ONE_SCRIPT; do
        {
            if [ ! -z "${ONE_SCRIPT}" ] ; then         # if not empty
            {
                URL="${provider}${ONE_SCRIPT}"
                [   -d "${cached_directory}" ] && source "$URL"
                [ ! -d "${cached_directory}" ] &&eval """$(wget --quiet --no-check-certificate $URL  -O -  2>/dev/null )"""   # suppress only wget download messages, but keep wget output for variable
                echo "$URL Loaded"
            }
            fi
        }
        done <<< "${BASH_SCRIPTS}"
        unset URL
        unset EXECOMCLI
        unset ONE_SCRIPT
        unset BASH_SCRIPTS
        unset provider
        ( ( ! command -v type passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_execute_commands_wget
    load_execute_commands_wget

    load_execute_commands_curl(){
        local URL=""
        local EXECOMCLI=""
        local cached_directory="/_/clis/execute_command_intuivo_cli/"
        local provider=""
        [   -d "${cached_directory}" ] &&  provider="file://${cached_directory}"
        [ ! -d "${cached_directory}" ] &&  provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/"
        local BASH_SCRIPTS="
    struct_testing
    execute_command
    "
    #execute_command
        while read -r ONE_SCRIPT; do
        {
            if [ ! -z "${ONE_SCRIPT}" ] ; then         # if not empty
            {
                URL="${provider}${ONE_SCRIPT}"
                eval """$(curl $URL  2>/dev/null )"""  # suppress only curl download messages, but keep curl output for variable
                echo "$URL Loaded"
            }
            fi
        }
        done <<< "${BASH_SCRIPTS}"
        unset URL
        unset EXECOMCLI
        unset ONE_SCRIPT
        unset BASH_SCRIPTS
        unset provider
        ( ( ! command -v type passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_execute_commands_curl
    load_execute_commands_curl

} # end function HOW_TO_LOAD_SEVERAL_FILES

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_EXECUTE_COMMAND() {

    #Sample short call for loading execute command
    load_execute_command_curl(){
        local provider="file:///_/clis/execute_command_intuivo_cli/execute_command"
        [ ! -d "/_/clis/execute_command_intuivo_cli/" ] && provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/execute_command"
        local EXECOMCLI=$(curl $provider  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading execute_command \n \n " && exit 69; )
    } # end load_struct_testing_curl
    load_struct_testing_curl
} # end HOW_TO_LOAD_JUST_ONE_SCRIPT_EXECUTE_COMMAND

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL() {

    #Sample short call for loading struct_testing
    load_struct_testing_curl(){
        local provider="file:///_/clis/execute_command_intuivo_cli/struct_testing"
        [ ! -d "/_/clis/execute_command_intuivo_cli/" ] && provider="https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing"
        local EXECOMCLI=$(curl $provider  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_struct_testing_curl
    load_struct_testing_curl

} # end HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL

function HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_WGET() {

    #Sample short call for loading struct_testing
    load_struct_testing_wget(){
        local provider="/_/clis/execute_command_intuivo_cli/struct_testing"
        [   -e "${provider}"  ] && source "${provider}"
        [ ! -e "${provider}"  ] && eval """$(wget --quiet --no-check-certificate  https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing -O -  2>/dev/null )"""   # suppress only wget download messages, but keep wget output for variable
        ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_struct_testing_wget
    load_struct_testing_wget

} # end HOW_TO_LOAD_JUST_ONE_SCRIPT_LOCAL_AND_ONLINE_STRUCT_USING_CURL

function HOW_TO_LOAD_JUST_ONE_SCRIPT_ONLINE_ALWAYS_STRUCT_USING_WGET() {

    load_struct_testing_wget(){
        # HOW TO LOAD JUST ONE SCRIPT
        EXECOMCLI=$(wget --quiet --no-check-certificate https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/struct_testing -O -  2>/dev/null )   # suppress only curl download messages, but keep curl output for variable
        eval """${EXECOMCLI}"""
        ( ( ! command -v type passed >/dev/null 2>&1;) && echo -e "\n \n  ERROR! Loading struct_testing \n \n " && exit 69; )
    } # end load_struct_testing_wget
    load_struct_testing_wget

} # end HOW_TO_LOAD_JUST_ONE_SCRIPT_ONLINE_ALWAYS_STRUCT_USING_WGET





 ######  ######## ########  ##     ##  ######  ########
##    ##    ##    ##     ## ##     ## ##    ##    ##
##          ##    ##     ## ##     ## ##          ##
 ######     ##    ########  ##     ## ##          ##
      ##    ##    ##   ##   ##     ## ##          ##
##    ##    ##    ##    ##  ##     ## ##    ##    ##
 ######     ##    ##     ##  #######   ######     ##

######## ########  ######  ######## #### ##    ##  ######
   ##    ##       ##    ##    ##     ##  ###   ## ##    ##
   ##    ##       ##          ##     ##  ####  ## ##
   ##    ######    ######     ##     ##  ## ## ## ##   ####
   ##    ##             ##    ##     ##  ##  #### ##    ##
   ##    ##       ##    ##    ##     ##  ##   ### ##    ##
   ##    ########  ######     ##    #### ##    ##  ######

 ######  ########    ###    ########  ########                    ##
##    ##    ##      ## ##   ##     ##    ##                        ##
##          ##     ##   ##  ##     ##    ##                         ##
 ######     ##    ##     ## ########     ##       ####### #######    ##
      ##    ##    ######### ##   ##      ##                         ##
##    ##    ##    ##     ## ##    ##     ##                        ##
 ######     ##    ##     ## ##     ##    ##                       ##


#
# STRUCT TESTING - START
#

RED="\033[01;31m"
#RED="\033[38;5;1m"
ORANGE="\033[38;5;202m"

WHITE="\033[38;5;15m"
WHITEBOLD="\033[01;37m"
YELLOW="\033[01;33m"
YELLOW226="\033[38;5;226m"


GRAY="\033[38;5;8m"
GRAY241="\033[38;5;241m"
GRAYEDOUT="\033[01;30m"

GREEN="\033[01;32m"
LIGHTGREEN="\033[38;5;83m"
LIGHTPINK="\033[1;204m"
LIGHTYELLOW="\033[38;5;227m"


CYAN="\033[01;36m"
PURPLE="\033[01;35m"
DARKBLUE="\033[01;34m"
PURPLE_BLUE="\033[38;5;93m"
BRIGHT_BLUE87="\033[38;5;87m"

YELLOW_OVER_DARKBLUE="\033[38;5;220m\033[48;5;20m"
YELLOW_OVER_DARKBLUE2="\033[38;5;11m\033[48;5;18m"

RESET="\033[0m"
CERO="\033[01;0m"

        function passed() {
            ARGS="${@}"
            if [ ! -z "${ARGS-x}" ] ; then # if its set and not empty
            {
                echo -e "${LIGHTGREEN} ✔ ${LIGHTYELLOW} ${ARGS}  ${RESET}"
            }
            fi
        }
        function kill_execution() {
            echo -e " ☠ ${LIGHTPINK} KILL EXECUTION SIGNAL SEND ${RESET}"
            exit 69;
        }

        function failed() {
            ARGS="${@}"
            if [[ ! -z "${ARGS-x}" ]] ; then # if its set and not empty
            {
                echo -e "${RED} 𝞦 ${LIGHTYELLOW} ${ARGS} ${RED} has failed!  ${RESET}"
                kill_execution
            }
            fi
        }

        function ensure() {
            # Sample usage:
            # assuming mongo bin is in your path
            # ensure mongo or " Cancel export"
            # ensure mongoexport or " Cancel export"
            # ensure bsondump or " Cancel export"
            if ! command -v "${1}" >/dev/null 2>&1; then # Command Does not-exist
                echo " "
                echo "Error! '${1}' is not in your PATH environment or cannot be reached.!"
                return 1
            else
                local msg=""
                [[ ! -z "${3+x}"  ]] &&     msg="${3}"  ;  # check if a variable is set and not empty and reassign value
                msg=$(echo "${msg}" | sed  -e 's/ancel /anceling /g')
                msg=$(echo "${msg}" | sed  -e 's/uit /uiting /g')
                msg=$(echo "${msg}" | sed  -e 's/xit /xiting /g')
                echo "${msg}"
                [[ "${msg}" == *"anceling "* ]] && exit 69
                [[ "${msg}" == *"uiting "* ]] && exit 69
                [[ "${msg}" == *"xiting "* ]] && exit 69
                return 1
            fi
        }

        function not() {
            local order="empty"  # Tasjgjgggg
            if [[ ! -z "${1+x}"  ]] ; then  # check if a variable is set and not empty
                NODE_VERSION="${1}"
            fi
        }

        function directory_exists(){
            # Sample usage
            #
            #     directory_exists "/home/vagrant/.pyenv"
            #     directory_exists "/root/.pyenv
            #     /home/vagrant/.pyenv"
            #
            DIRS="${@}"
            if [ ! -z "${DIRS-x}" ] ; then # if its set and not empty
            {
                DIRS=$(sed 's/ /\n/g' <<< "${@}")
                while read -r ONE_DIR; do
                # if not empty
                if [ ! -z "${ONE_DIR}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # ONE_DIR="/Users/administrator/.pyenv"
                    TESTING="that directory ${CYAN}${ONE_DIR}${LIGHTYELLOW} exists"
                    if [[ -d "${ONE_DIR}" && ! -L "${ONE_DIR}" ]] ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${DIRS}"
            }
            fi

        }

        function does_not_exist(){
            # Sample usage
            #
            #     does_not_exist "/home/vagrant/.pyenv"
            #     does_not_exist "/root/.pyenv
            #     /home/vagrant/.pyenv"
            #
            DIRS="${@}"
            if [ ! -z "${DIRS-x}" ] ; then # if its set and not empty
            {
                DIRS=$(sed 's/ /\n/g' <<< "${@}")
                while read -r ONE_DIR; do
                # if not empty
                if [ ! -z "${ONE_DIR}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.pyenv <-- will fail always
                    # But /home/user/.pyenv  <-- will pass
                    # OR Users/administrator/.pyenv  in mac <-- will pass
                    # ONE_DIR="/Users/administrator/.pyenv"
                    TESTING="that ${CYAN}${ONE_DIR}${LIGHTYELLOW} does not exist"
                    if [[ ! -e "${ONE_DIR}" ]] ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${DIRS}"
            }
            fi
        }

        function directory_does_not_exist() {
            does_not_exist $@
        }

        function file_does_not_exist() {
            does_not_exist $@
        }

        function file_exists(){
            # Sample usage
            #
            #     file_exists "/home/vagrant/.zshrc"
            #     file_exists "/root/.zshrc
            #     /home/vagrant/.pyenzshrcv"
            #
            FILES="${@}"
            if [ ! -z "${FILES-x}" ] ; then # if its set and not empty
            {
                FILES=$(sed 's/ /\n/g' <<< "${@}")
                while read -r ONE_FILE; do
                # if not empty
                if [ ! -z "${ONE_FILE}" ] ; then
                    # AS a NOTE ~/  <-- will fail always
                    # SO ~/.zshrc <-- will fail always
                    # But /home/user/.zshrc  <-- will pass
                    # OR Users/administrator/.zshrc  in mac <-- will pass
                    # ONE_FILE="/Users/administrator/.zshrc"
                    TESTING="that file ${CYAN}${ONE_FILE}${LIGHTYELLOW} exists"
                    if [[ -s "${ONE_FILE}" && ! -L "${ONE_FILE}" ]] ; then
                    {
                        passed "${TESTING}"
                    }
                    else
                    {
                        failed "${TESTING}"
                    }
                    fi
                fi
                done <<< "${FILES}"
            }
            fi

        }

        function softlink_exists(){
            # Sample usage
            #
            #     softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
            #     softlink_exists "/Users/administrator/.nix-profile
            #     /Users/administrator/.nix-profile>/nix/var/nix/profiles/default"
            #     softlink_exists "/root/.pyenv"
            #     softlink_exists "/root/.pyenv
            #     /root/.pyenv>/home/vagrant/.pyenv"
            #
            LINKS="${@}"
            if [ ! -z "${LINKS-x}" ] ; then # if its set and not empty
            {
                LINKS=$(sed 's/ /\n/g' <<< "${@}")
                while read -r ONE_LINK_ORDER; do
                    # if not empty
                    if [ ! -z "${ONE_LINK_ORDER}" ] ; then
                    {
                        CHECK_TARGET_TOO="NO"
                        ONE_LINK_LOCATION="${ONE_LINK_ORDER}"
                        ONE_LINK_TARGET=""

                        [[ "${ONE_LINK_ORDER}" == *">"* ]] && CHECK_TARGET_TOO="YES"
                        if [[ "${CHECK_TARGET_TOO}" == "YES" ]] ; then
                        {
                            ONE_LINK_LOCATION=$(cut -d'>' -f1 <<< "${ONE_LINK_ORDER}")
                            ONE_LINK_TARGET=$(cut -d'>' -f2 <<< "${ONE_LINK_ORDER}")
                        }
                        fi
                        # AS a NOTE ~/  <-- will fail always
                        # SO ~/.pyenv <-- will fail always
                        # But /home/user/.pyenv  <-- will pass
                        # OR Users/administrator/.pyenv  in mac <-- will pass
                        # ONE_LINK_LOCATION="/Users/administrator/.nix-profile"
                        TESTING="that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} exists"
                        if [[ -L "${ONE_LINK_LOCATION}" ]] ; then
                        {
                            # Test pointing
                            passed "${TESTING}"

                            if [[ "${CHECK_TARGET_TOO}" == "YES" && ! -z "${ONE_LINK_TARGET}" ]] ; then
                            {
                                TESTING="${PURPLE} +-- and that softlink ${CYAN}${ONE_LINK_LOCATION}${LIGHTYELLOW} points to ${CYAN}${ONE_LINK_TARGET}${GREEN} location"

                                FOUND_LINK_TARGET=$(ls -l ${ONE_LINK_LOCATION} | awk '{print $11}') # Find target symlink
                                if [[ "${FOUND_LINK_TARGET}" == "${ONE_LINK_TARGET}" ]] ; then
                                {
                                    passed "${TESTING}"
                                }
                                else
                                {
                                    failed "${TESTING}"
                                }
                                fi
                            }
                            fi # TACHECK_TARGET_TOO is correct

                        }
                        else
                        {
                            failed "${TESTING}"
                        }
                        fi # ONE_LINK_LOCATION Exists
                    }
                    fi # not empty one link
                done <<< "${LINKS}"
            }
            fi # not empty links
        } # end function

        function check_equality(){
            # Sample usage
            #
            #     check_equality "$(cat /home/vagrant/.pyenv/version)=${PYTHON_VERSION}
            #     $(cat /home/vagrant/.pyenv/version)=2.7.11"
            #
            #     check_equality $(cat ~/.pyenv/version)="2.7.11"
            #
            ARGS="${@}"
            if [ ! -z "${ARGS-x}" ] ; then # if its set and not empty
            {
                #ARGS=$(sed 's/ /\n/g' <<< "${@}")
                while read -r ONE_EQUALITY_ORDER; do
                    # if not empty
                    if [ ! -z "${ONE_EQUALITY_ORDER}" ] ; then
                    {
                        LEFT_VALUE=$(cut -d'=' -f1 <<< "${ONE_EQUALITY_ORDER}")
                        RIGHT_VALUE=$(cut -d'=' -f2 <<< "${ONE_EQUALITY_ORDER}")

                        TESTING="that value left value: ${CYAN}${LEFT_VALUE}${LIGHTYELLOW} exists"
                        if [[ -z "${LEFT_VALUE-x}" ]] ; then
                        {
                            failed "${TESTING}"
                        }
                        fi

                        TESTING="that value right value: ${CYAN}${RIGHT_VALUE}${LIGHTYELLOW} exists"
                        if [[ -z "${RIGHT_VALUE-x}" ]] ; then
                        {
                            failed "${TESTING}"
                        }
                        fi

                        TESTING="that value ${YELLOW_OVER_DARKBLUE}${LEFT_VALUE}${RESET}${LIGHTYELLOW} is equal to ${YELLOW_OVER_DARKBLUE}${RIGHT_VALUE}${RESET}"
                        if [[ "${LEFT_VALUE}" ==  "${RIGHT_VALUE}" ]] ; then
                        {
                            passed "${TESTING}"
                        }
                        else
                        {
                            failed "${TESTING}"
                        }
                        fi
                    }
                    fi # not empty
                done <<< "${ARGS}"
            }
            fi
        } # end function check_equality

        function check_to_be_installed(){
            # Sample usage
            #
            # ...  you want to APT-GET install  ... sysfsutils
            # ...  and you want to say          ... fix for transparent_hugepage
            #
            #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
            #
            package="$1"
            message="$2"
            CHECK_INSTALLED=$(dpkg -s "${package}")
            if [[ "${CHECK_INSTALLED}" == *"Package: ${package}"* ]] ; then
                echo -e "${GREEN} PACKAGE: ${message}  ${package} is there  ${CERO}"
            else
                echo -e "${YELLOW} Installing ${message}   ${CERO}"
                sudo apt install "${package}" -y
            fi
        }


        function is_service_reponse_not_this_fail() {
            #Sample use
            # ( command -v nginx >/dev/null 2>&1; ) && sudo service nginx start
            #
            # is_service_reponse_not_this_fail "nginx" "$(sudo service nginx status)" "not running"
            # is_service_reponse_not_this_fail "puma" "$(sudo /etc/init.d/pumacontrol.sh status)" "not running"
            #
            local SERVICE_NAME SERVICE_STATUS SERVICE_FAIL_RESPONSE
            SERVICE_NAME="${1}"
            SERVICE_STATUS="${2}"
            SERVICE_FAIL_RESPONSE="${3}"
            TESTING="that service ${CYAN}${SERVICE_NAME}${LIGHTYELLOW} is running"
            if [[ "${SERVICE_STATUS}" == *"${SERVICE_FAIL_RESPONSE}"* ]] ; then
            {
                echo "${SERVICE_STATUS}"
                failed "${TESTING}"
            }
            else
            {
                passed "${TESTING}"
            }
            fi
        }

        function is_service_running() {
            #Sample use
            # ( command -v nginx >/dev/null 2>&1; ) && sudo service nginx start
            #
            # is_service_running "nginx" "$(sudo service nginx status)" "is running"
            # is_service_running "puma" "$(sudo /etc/init.d/pumacontrol.sh status)" "is running"
            #
            local SERVICE_NAME="${1}"
            local SERVICE_STATUS="${2}"
            local EXPECTED_RESPONSE="${3}"
            echo SERVICE_NAME="${1}"
            echo SERVICE_STATUS="${2}"
            echo EXPECTED_RESPONSE="${3}"
            TESTING="that service ${CYAN}${SERVICE_NAME}${LIGHTYELLOW} ${EXPECTED_RESPONSE}"
            if [[ "${SERVICE_STATUS}" == *"${EXPECTED_RESPONSE}"* ]] ; then
            {
                passed "${TESTING}"
            }
            else
            {
                echo "${SERVICE_STATUS}"
                failed "${TESTING}"
            }
            fi
        }

        type_function_exists() {
          type "$1" > /dev/null 2>&1
        } # type_function_exists


        function is_installed() {
            # Sample use
            #
            #          if  ! is_installed wget ; then    is like is NOT installed
            #          if  is_installed wget ; then      it makes more sense to make it this way
            #
            local SERVICE_NAME="${1}"
            if ! type_function_exists "${SERVICE_NAME}"; then
            {
                #failed "${TESTING}"
                return 1
            }
            else
            {
                #passed "${TESTING}"
                return 0
            }
            fi
        }

        function is_not_installed() {
            # Sample use
            #
            #          if  ! is_not_installed wget ; then # you can, but not recommended, because it is confusing to read
            #          if  is_not_installed wget ; then
            #
            local SERVICE_NAME="${1}"
            if ! type_function_exists "${SERVICE_NAME}"; then
            {
                #passed "${TESTING}"
                return 0
            }
            else
            {
                #failed "${TESTING}"
                return 1
            }
            fi
        }

        function verify_is_installed() {
            # Sample use
            #
            #            verify_is_installed wget
            #
            local SERVICE_NAME="${1}"
            TESTING="that: ${CYAN}${SERVICE_NAME}${GREEN} is installed"
            if ! is_installed "${SERVICE_NAME}"; then
            {
                failed "${TESTING}"
            }
            else
            {
                passed "${TESTING}"
            }
            fi
        }

        function verify_installed_version() {
            # Sample use
            #
            #            verify_installed_version "node --version"  "${node_version}"
            #            verify_installed_version "phantomjs --version"  "${phantomjs_version}"
            #            verify_installed_version "casperjs --version"  "${casper_version}"
            #
            local EVAL_GET_VERSION_STRING=$(eval "${1}")
            local VERSION_EXPECTED="${2}"

            local TESTING="that installed version for ${1} is ${CYAN}${VERSION_EXPECTED}${GREEN}"
            if [[ "${EVAL_GET_VERSION_STRING}" == *"${VERSION_EXPECTED}"* ]] || [[ "${EVAL_GET_VERSION_STRING}" == "${VERSION_EXPECTED}" ]]; then
            {
                passed "${TESTING}"
            }
            else
            {
                echo -e "${RED} 𝞦 I got response: ${YELLOW_OVER_DARKBLUE}${EVAL_GET_VERSION_STRING}"
                failed "${TESTING}"
            }
            fi
        }

        function if_user_exists(){
            # Sample use
            #
            #            ( ! if_user_exists "postgres"  ) && failed "${TESTING}"
            #            ( if_user_exists "postgres"  ) && passed "${TESTING}"
            #
            local ${TARGET_USER}="${1}"
            local TESTING="that user ${TARGET_USER} is ${CYAN}exists${GREEN}"
            local LIST_ALL_USERS=$(cut -d: -f1 /etc/passwd) # REF: http://askubuntu.com/questions/410244/a-command-to-list-all-users-and-how-to-add-delete-modify-users
            local USERID=$(id -u ${TARGET_USER})
            # Alternative to check getent passwd $user  > /dev/null
            # Alternative to check getent passwd mongodb  > /dev/null
            [ -z "${USERID}" ] &&  return 1 #failed
            return 0 #found
        }
        function check_if_user_exists(){
            # Sample use
            #
            #            check_if_user_exists "postgres"
            #
            local ${TARGET_USER}="${1}"
            local TESTING="checking that user ${TARGET_USER} is ${CYAN}exists${GREEN}"
            ( ! if_user_exists "${TARGET_USER}"  ) && failed "${TESTING}"
            passed "${TESTING}"
        }

        function has_error_keyword() {
            # Sample use
            #
            #            has_error_keyword "${bulk}"
            #
            local bulk="${*}"
            return    [[ "${bulk}" == *"Could not resolve"* ]] || \
                      [[ "${bulk}" == *"Repository not found"* ]] || \
                      [[ "${bulk}" == *"Could not read from"* ]] || \
                      [[ "${bulk}" == *"Could not"* ]] || \
                      [[ "${bulk}" == *"could not"* ]] || \
                      [[ "${bulk}" == *"Fatal"* ]] || \
                      [[ "${bulk}" == *"FATAL"* ]] || \
                      [[ "${bulk}" == *"fatal"* ]] || \
                      [[ "${bulk}" == *"FAILED"* ]] || \
                      [[ "${bulk}" == *"failed"* ]] || \
                      [[ "${bulk}" == *"Failed"* ]] || \
                      [[ "${bulk}" == *"error"* ]] || \
                      [[ "${bulk}" == *"ERROR"* ]] || \
                      [[ "${bulk}" == *"Error"* ]] || \
                      [[ "${bulk}" == *"Denied"* ]] || \
                      [[ "${bulk}" == *"denied"* ]]
        } # end has_error_keyword

        function handle_error() {
            # Sample use
            #
            #            local install_result=$(sudo apt-get install ${missing} -yfq   2>&1)  # capture all input and output
            #            [[ ! -z "${install_result}" ]] && handle_error "${install_result}"
            #
            local bulk="${*}"
            local error_happened=""
            [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $? != 0 ] && error_happened="1"
            [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $? != 0 )) && error_happened="1"
            if [ "${error_happened}" ]  ||  ( has_error_keyword "${bulk}" ) ; then
            {
              echo -e "${PURPLE_BLUE} action ${RED}failed ${YELLOW226}!!!  ${RESET}"
              [[ "${bulk}" == *"Could not resolve"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO INTERNET CONNECTION \o_0/ ${RESET}"
              [[ "${bulk}" == *"Repository not found"* ]] && echo -e "${BRIGHT_BLUE87} It appears YOU HAVE ${YELLOW226}NO ACCESS TO THIS FOR YOU ${RED} ${GIT_USER_NAME} ${RESET}"
              [[ "${bulk}" == *"Could not read from"* ]] && echo -e "${BRIGHT_BLUE87} It appears it exists but you are ${RED}NOT ${YELLOW226} ALLOWED ${RED} ${GIT_USER_NAME} ${YELLOW226}!!! ${RESET}"
              echo -e "${RESET}${bulk}  "
              exit 69;
            }
            fi

        } # end handle_error
        function install_apt_get_requirements(){
            # Sample use
            #               local OS="${1}"
            #               install_apt_get_requirements "${OS}" "
            #                        build-essential
            #                        libreadline-dev
            #                        zlib1g-dev
            #                        flex
            #                        bison
            #                        libxml2-dev
            #                        libxslt-dev
            #                        libssl-dev
            #
            #                        libreadline6-dev
            #                        libossp-uuid-dev
            #                        uuid"
            #
            #

            # room for detecting Linux and OS systems
            local OS="${1}"
            local missing=""
            local one_required=""
            local required=$(grep -vE '^\s+#'<<<"${2}")
            for one_required in ${required}; do
            {
                dpkg -l | egrep "$one_required" &>/dev/null
                if [ $? == 0 ]; then
                {
                    echo -e " ${GREEN} $one_required ${YELLOW} INSTALLED."
                }
                else
                {
                    echo -e " ${RED}  NEED TO INSTALL ${YELLOW} $one_required."
                    missing="${missing} ${one_required}"
                }
                fi
            }
            done
            missing=$(echo ${missing} | sed -e 's/^[[:space:]]*//' | sed 's/^\ //g' | sed 's/^\t//g' ) # trim_start_space

            # Check Requirements OS Ubuntu 14.04 REF: https://wiki.postgresql.org/wiki/Compile_and_Install_from_source_code#Ubuntu
            [[ ! -z "${missing}" ]] && echo -e " ${CYAN} Installing missing packages: ${missing} ${RESET}"
            [[ ! -z "${missing}" ]] && local install_result=$(sudo apt-get install ${missing} -yfq   2>&1) # capture all input and output
            [[ ! -z "${install_result}" ]] && handle_error "${install_result}"
        } # end install_apt_get_requirements
        #
        # C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --Start
        #
        function test_positives(){
            # Sample use
            #
            #
            #    local message_response=$(ls asdasdfas1234  2>&1 )  # Perform an action with error ,capture all output, error will return 1 to $?
            #    local ERROR_HAPPENED=""
            #    [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $? != 0 ] && ERROR_HAPPENED="1"
            #    [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $? != 0 )) && ERROR_HAPPENED="1"
            #    if [ "${ERROR_HAPPENED}" ] || \
            #        [[ "${message_response}" == *"error"* ]] || \
            #        [[ "${message_response}" == *"ERROR"* ]] || \
            #        [[ "${message_response}" == *"denied"* ]] \
            #    ; then
            #    {
            #        failed "There was an error- do something- show something ${message_response}"
            #    }
            #    fi

            KIND=""
            ls werwerwerwerwerwerwerwerwerwerwerr >/dev/null 2>&1;
            if (( $? == 0 )) ;  then  # Intel processor
            KIND="INTEL"
            fi
            if [ $? == 0 ]; then   # Mac Intel processor
            KIND="${KIND}MAC"
            fi
            echo "${KIND}"
        }
        PROCESSOR_ERROR=$(test_positives)
        # DEBUG test_positives echo "${PROCESSOR_ERROR}"
        # DEBUG test_positives exit 1
        #
        # C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --End
        #
    [ ! -z "$0" ] && [ -e "$0" ] && THISSCRIPTNAME=`basename "$0"`

    # TRAP
    [ ! -z "$0" ] && [   -e "$0" ] &&  trap '{  \" `basename "$0"` KEYBOARD INTERRUPT.\"; exit 69; }' INT
    [   -z "$0" ] && [ ! -e "$0" ] &&  trap '{  \" STRUCT TESTING KEYBOARD INTERRUPT.\"; exit 69; }' INT
    [ ! -z "$0" ] && [ ! -e "$0" ] &&  trap '{  \" STRUCT TESTING KEYBOARD INTERRUPT.\"; exit 69; }' INT

        #
        # Template:
        #
        #  echo -e "${GREEN} Installing ${RED}PYENV${GREEN} and ${CYAN} {PYTHON_VERSION}  ${CERO}"
        #
        #  procedure "${PYTHON_VERSION}"  >/dev/null 2>&1 # suppress stdln and errln output
        #
        #  Testing Checking install
        #  FOLDER MUST EXIST  /home/vagrant/.pyenv
        #  LINK MUST EXIST /root/.pyenv
        #  Python Must be PYTHON VERSION
        #
        #  directory_exists "/home/vagrant/.pyenv"
        #  file_exists "/home/vagrant/.zshrc"
        #  softlink_exists "/root/.pyenv>/home/vagrant/.pyenv"
        #  check_to_be_installed "sysfsutils" "fix for transparent_hugepage"
        #
        #  CURRENT_VERSION=$(cat /home/vagrant/.pyenv/version)
        #  check_equality "${CURRENT_VERSION}=${PYTHON_VERSION}"

        #  echo -e " END ${THISSCRIPTNAME} ${CERO}"
        #  echo -e "${RED}  END ${THISSCRIPTNAME} ${CERO}"
        #  echo -e " END ${THISSCRIPTNAME} ${CERO}"

#
# STRUCT TESTING - END
#

   ##                    ######## ##    ## ########
  ##                     ##       ###   ## ##     ##
 ##                      ##       ####  ## ##     ##
##    ####### #######    ######   ## ## ## ##     ##
 ##                      ##       ##  #### ##     ##
  ##                     ##       ##   ### ##     ##
   ##                    ######## ##    ## ########

 ######  ######## ########  ##     ##  ######  ########
##    ##    ##    ##     ## ##     ## ##    ##    ##
##          ##    ##     ## ##     ## ##          ##
 ######     ##    ########  ##     ## ##          ##
      ##    ##    ##   ##   ##     ## ##          ##
##    ##    ##    ##    ##  ##     ## ##    ##    ##
 ######     ##    ##     ##  #######   ######     ##

######## ########  ######  ######## #### ##    ##  ######
   ##    ##       ##    ##    ##     ##  ###   ## ##    ##
   ##    ##       ##          ##     ##  ####  ## ##
   ##    ######    ######     ##     ##  ## ## ## ##   ####
   ##    ##             ##    ##     ##  ##  #### ##    ##
   ##    ##       ##    ##    ##     ##  ##   ### ##    ##
   ##    ########  ######     ##    #### ##    ##  ######

